¡argb
colorSpace_floatToInt8valuealphaopacityredgreenblue
withValues	withAlphawithOpacitywithRed	withGreenwithBlue_linearizeColorComponentcomputeLuminancelerp
alphaBlendgetAlphaFromOpacity==hashCodetoStringclearsrcdstsrcOverdstOversrcIndstInsrcOutdstOutsrcATopdstATopxorplusmodulatescreenoverlaydarkenlighten
colorDodge	colorBurn	hardLight	softLight
difference	exclusionmultiplyhue
saturationcolor
luminositynonelowmediumhighbuttroundsquaremiterbevelfillstrokehardEdge	antiAliasantiAliasWithSaveLayer_data_kIsAntiAliasIndex_kColorRedIndex_kColorGreenIndex_kColorBlueIndex_kColorAlphaIndex_kColorSpaceIndex_kBlendModeIndex_kStyleIndex_kStrokeWidthIndex_kStrokeCapIndex_kStrokeJoinIndex_kStrokeMiterLimitIndex_kFilterQualityIndex_kMaskFilterIndex_kMaskFilterBlurStyleIndex_kMaskFilterSigmaIndex_kInvertColorIndex_kIsAntiAliasOffset_kColorRedOffset_kColorGreenOffset_kColorBlueOffset_kColorAlphaOffset_kColorSpaceOffset_kBlendModeOffset_kStyleOffset_kStrokeWidthOffset_kStrokeCapOffset_kStrokeJoinOffset_kStrokeMiterLimitOffset_kFilterQualityOffset_kMaskFilterOffset_kMaskFilterBlurStyleOffset_kMaskFilterSigmaOffset_kInvertColorOffset_kDataByteCount_objects_ensureObjectsInitialized_kShaderIndex_kColorFilterIndex_kImageFilterIndex_kObjectCountisAntiAlias_kColorDefault_kBlendModeDefault	blendModestylestrokeWidth	strokeCap
strokeJoin_kStrokeMiterLimitDefaultstrokeMiterLimit
maskFilterfilterQualityshadercolorFilterimageFilterinvertColorssRGBextendedSRGB	displayP3rawRgbarawStraightRgbarawUnmodifiedrawExtendedRgba128pngrgba8888bgra8888rgbaFloat32_imageonCreate	onDispose_debugStackwidthheight	_disposeddisposedebugDisposed
toByteDatadebugGetOpenHandleStackTracesclone	isCloneOf_toByteData_dispose_handlesdurationimage
frameCountrepetitionCountgetNextFrame_cachedFrameCount_frameCount_cachedRepetitionCount_repetitionCount_getNextFramenonZeroevenOdd	intersectunionreverseDifferencefillTypemoveTorelativeMoveTolineTorelativeLineToquadraticBezierTorelativeQuadraticBezierTocubicTorelativeCubicToconicTorelativeConicToarcTo
arcToPointrelativeArcToPointaddRectaddOvaladdArc
addPolygonaddRRectaddPathextendWithPathcloseresetcontainsshift	transform	getBoundscombinecomputeMetrics_constructor_clone_getFillType_setFillType_arcTo_arcToPoint_relativeArcToPoint_addRect_addOval_addArc_addPolygon	_addRRect_addPath_addPathWithMatrix_extendWithPath_extendWithPathAndMatrix	_contains_shift
_transform
_getBounds_oppositionvectorangle	_iteratoriterator_pathMetric_pathMeasurecurrentmoveNextlengthisClosedcontourIndex_measuregetTangentForOffsetextractPath_length
_getPosTan_extractPath	_isClosed_nextContour_nativeNextContourcurrentContourIndexnormalsolidouterinner_style_sigma	_TypeNone	_TypeBlurchildvalues_color
_blendMode_matrix_type
_kTypeMode_kTypeMatrix_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGamma_toNativeImageFilter_toNativeColorFilter_shortDescriptioncreator	_initMode_initMatrix_initLinearToSrgbGamma_initSrgbToLinearGammadatanativeFiltersigmaXsigmaYtileMode_modeStringradiusXradiusYinnerFilterouterFilter	_initBlur_initDilate
_initErode_initColorFilter_initComposed_debugDisposedclamprepeatedmirrordecal_initLinear_initRadial_initConical
_initSweep_validateColorStops_initWithImage
_debugName	fromAsset_shaderRegistry_reinitializeShader_uniformFloatCount_samplerCount_initFromAssetfragmentShader_kEmptyFloat32List_floatssetFloatsetImageSampler_setImageSampler_validateSamplers	trianglestriangleStriptriangleFan_initpointslinespolygonsave	saveLayerrestorerestoreToCountgetSaveCount	translatescalerotateskewgetTransformclipRect	clipRRectclipPathgetLocalClipBoundsgetDestinationClipBounds	drawColordrawLine	drawPaintdrawRect	drawRRect
drawDRRectdrawOval
drawCircledrawArcdrawPath	drawImagedrawImageRectdrawImageNinedrawPicturedrawParagraph
drawPointsdrawRawPointsdrawVertices	drawAtlasdrawRawAtlas
drawShadow	_recorder_sorted_saveLayerWithoutBounds
_saveLayer_scale_getTransform	_clipRect
_clipRRect	_clipPath_getLocalClipBounds_getDestinationClipBounds
_drawColor	_drawLine
_drawPaint	_drawRect
_drawRRect_drawDRRect	_drawOval_drawCircle_drawArc	_drawPath
_drawImage_drawImageRect_drawImageNine_drawPicture_drawPoints_drawVertices
_drawAtlas_drawShadowtoImagetoImageSyncapproximateBytesUsed_toImage_toImageSyncisRecordingendRecording_endRecording_canvas_kBytesPerShadow_kColorOffset	_kXOffset	_kYOffset_kBlurOffsetoffset
blurRadiusconvertRadiusToSigma	blurSigmatoPaintlerpList_encodeShadowsfromUint8ListfromFilePath_initFromFileencodedbytesPerPixelinstantiateCodec_initEncoded_initRaw_width	_getWidth_height
_getHeight_bytesPerPixel_getBytesPerPixel_instantiateCodecmessagestack__rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaint
ColorSpace_colorSpaceToIndex_indexToColorSpaceImageByteFormatPixelFormatImageEventCallbackImage_Image
_wrapImageImageDecoderCallback	FrameInfoCodec_NativeCodecinstantiateImageCodecinstantiateImageCodecFromBufferinstantiateImageCodecWithSize_getDefaultImageSizeTargetImageSizeCallbackTargetImageSizedecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayer_NativeEngineLayerPath_NativePathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilter_ColorTransform_IdentityColorTransform_ClampTransform_MatrixColorTransform_getColorTransformColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeWideColorList_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgramFragmentShader
VertexModeVertices	PointModeClipOpCanvas_NativeCanvasPictureEventCallbackPicture_NativePicturePictureRecorder_NativePictureRecorderShadowImmutableBufferImageDescriptor_NativeImageDescriptor	_Callback_CallbackWithError_Callbacker_CallbackerWithError	_futurize_futurizeWithErrorPictureRasterizationException˜dartuiboolRecthasNaNRRectOffsetdxisNaNdyFloat64ListlengtheverydoublevalueisFiniteRadiusxy
withValuesalphaclampDoubleaint
_fromARGBCsRGBfromRGBO
_fromRGBOCfromARGBround
Deprecatedfromredgreenblue
colorSpace	transformmathpowextendedSRGBHSVColormaterialColorstransparentCurveselasticInOutAnimationController_lerpDoublergboverrideObject	identicalruntimeTypehashStringtoStringAsFixedsrcdstclear	saveLayerrestore	blendModesrcOverdstInsrcOutsrcIndstOutdstATopdstOversrcATopplusmultiplyscreenoverlaymodulate	hardLight
colorDodge	colorBurncolor	exclusion
difference
luminosityhue	softLight
saturationblurBackdropFilternonelowmediumhighfilterQualitymatrix	drawImagedrawImageRectdrawImageNine	drawAtlas	strokeCapAsquarestrokeWidthbuttdrawPath
drawPoints
strokeJoinstrokeMiterLimitstyle
drawCirclehardEdge	antiAliasantiAliasWithSaveLayerisAntiAliasbufferasUint32ListsetAll_data_objectstoListpragmaByteDataListfilledgetInt32_kFakeHostEndiansetInt32
getFloat32
setFloat32indexvaluesfillstrokemiterbevel	_TypeNone	_TypeBlur_style_sigmadebugDisposed_validateSamplers	Exception
_debugNamecreator_toNativeColorFilter_toNativeImageFilterfromEnvironmenttoStringStringBufferwrite
toByteDatarawExtendedRgba128	displayP3ArgumentErrorvoidwidgets
StackTracecurrent_handlesaddcallMemoryAllocations	_disposedcontainsremoveisEmptydispose
StateErrorformatrawRgbaFutureUnsupportedErrormaphandle_debugStack__imageNativeFieldWrapperClass1NativeInt32PointerVoidsymbolisLeaf	Uint8Listerrorencodedcallback
asByteDataHandleSetwidthheightgetNextFramecloneDurationimage	CompletersyncdecodeErrorcompleteErrorcompletedurationmillisecondsdurationMillisecondsfuturefromUint8ListtargetWidthtargetHeightallowUpscalinggetTargetSizeintrinsicWidthintrinsicHeightinstantiateCodecthenrawrowBytespixelFormatcodec	frameInfofillTypecombinereverseDifferencexor	intersectSceneBuilderclipPath_clonenonZerozero
fromCircle_opextractPathIterableDoublelefttoprightbottomBoolradiusrotationlargeArc	clockwiseFloat32List_getValue32matrix4fromLTRBforceClosedgetTangentForOffsetcossinatan2computeMetricslineTomoveToIterableBaseIterator
RangeError_nextContourcurrentContourIndexisClosedcloseaddRectstartWithMoveTonextContour
maskFilter
drawShadowcolorFilterfromColorFiltermodelinearToSrgbGammasrgbToLinearGamma_type_listEquals_matrix_color
_blendModehashAll
_kTypeMode_kTypeMatrixfromList_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGammaImageFilteredpushBackdropFilterpushImageFilterclampsigmaXsigmaYtileModeradiusXradiusYMatrix4	diagonal3datainnerFilterinnerouterFilteroutermirrorrepeateddecaldilateerodecomposed_shortDescriptionshaderpaintingGradientLinearGradientRadialGradientBoxDecorationlinearradiali	Int32ListNoSuchMethodError
colorStopsfocalfocalRadiuspi
startAngleendAngle
isNotEmptyUripath
encodeFull	microtask
_fromAssetMap_initFromAsset	debugNamefragmentShader_uniformFloatCount_samplerCountdrawVertices	trianglestriangleStriptriangleFannew
Uint16ListcolorstextureCoordinatesindicesdrawRawPointsclipRectSceneRendererBindingcreateCanvasPictureLayertoImageendRecordingCustomPainterpaintsydoAntiAliasarcTo	ParagraphlayoutParagraphStyleParagraphBuilder	TextAlignParagraphConstraintspointslinespolygonRSTransformscosssintxtyisRecording_canvascullRectlargestminmaxclipOpUint32stack_NativeParagraph_needsLayout_paint
addPicturedrawPicture	onDisposeUint64createPictureRecorder	_recorderonCreate	TextStylenormaloffset
blurRadiusscalelerpshadowIndex_kColorDefaultconvertRadiusToSigma_init_length_initFromFile_initEncodedTttoImageSyncwritelnNativeFieldWrapperClass1CodecEngineLayerPathIterableBaseIterator_ColorTransformImageFilterShaderCanvasPicturePictureRecorderImageDescriptor	Exception§Ä·†7¦¤í(Zvá}   Àƒt À‚TœÔ <€†€¤€µ€¶€Î€ï-Fz­®û‚E‚•‚æƒ6ƒ„ƒÕ„„„d„Š„‹„ª„ê„ù„û„ü……`…o…q…r…—…ñ† †††/†p†Î†İ†ß†à‡‡]‡l‡n‡o‡›‡Ú‡Ü‡İˆˆˆeˆµ‰‰,‰0‰`‰d‰p‰˜‰ÕŠŠEŠMŠQŠ¢Šñ‹A‹m‹q‹}‹ÊŒŒŒŒnŒ¿!%37„Ğ+|ŠÌÒı+Qx£óAou»‘‘-‘F‘_‘ª‘«‘å‘ë’3’‚’£’·’Õ’ğ““)“S“f“w“Š“œ““ã“é”6”F”k”’”¸”¾•••R•_•’•È•É•ã–)–B–ƒ–„–Î–å–ë——7—]—ª—Ú—à˜#˜)˜q˜­˜é˜ê™9™N™l™Š™¨™©™Ğ™Öš'šIš[š\šš“š”š»šÍšÎšô›››,›K›L›r›™›››Ì›Ò›úœ œ(œNœuœšœÒœä'Fdhi¢¨÷2ab•›ìŸŸ'ŸMŸNŸ…ŸŸËŸÌ   L M …  Ë Ì¡¡+¡1¡‚¡•¡©¡¿¡Ò¡ç¡û¢¢:¢ƒ¢©¢Æ¢ß¢ü££?£E£„£¬£ç¤0¤=¤e¤k¤o¤p¤¹¤ï¤õ¥-¥H¥x¥|¥}¥Æ¦¦¦L¦ˆ¦®¦Ü§§§§b§§•§Í§æ¨¨¨¨f¨œ¨¢¨Ú¨õ©%©)©*©{©¨©®©æª ª1ª5ª6ªtª±ªÑªñª÷«8«<«=«ˆ««â¬ ¬¬D¬b¬•¬Õ­­9­k­œ­ ­¡­Ğ­Ö®®a®g®±®ş¯=¯ƒ¯‰¯Ö° °k°·±±U±¢±ó² ²&²u²•²Ê³ ³6³K³b³w³†³®³¶³Ã³Ú³ü´´9´T´’´ÎµµIµmµxµ€µ†µŠµ‹µÎ¶¶¶f¶­¶ø·G·’·Ò¸¸L¸s¸¯¸È¸Î¸õ¹¹N¹g¹y¹¶¹õº3º^ºgº„º¬ºİºú»»,»w»Ä¼¼;¼D¼J¼N¼O¼œ¼¢¼Í½ ½;½?½@½L½o½‘½¤½ª½Ö½ê½ğ¾¾%¾=¾U¾m¾•¾™¾š¾¦¾á¾â¾î¿¿ª¿¬¿­¿à¿äÀ @1À @{À @šÀ @À @ïÀ A<À A‹À AÙÀ B)À BtÀ B¸À B¼À CÀ CWÀ C¨À CôÀ DBÀ DÀ DÖÀ E!À EpÀ E¶À EÑÀ EÕÀ F#À FpÀ FºÀ GÀ GYÀ GªÀ GëÀ GïÀ HÀ HÀ HhÀ H©À HúÀ IGÀ I˜À IçÀ J6À JQÀ JUÀ JcÀ JgÀ J²À JÃÀ JÔÀ K#À K6À K|À K}À KÁÀ KÇÀ LÀ L	À LfÀ LoÀ LpÀ L¯À LµÀ MÀ MÀ MÀ MTÀ MZÀ MµÀ M¼À M½À MüÀ NÀ NMÀ N^À NdÀ N¦À N¬À OÀ OÀ OÀ OLÀ ORÀ O À OñÀ PÀ PÀ PbÀ PÀ P•À PôÀ PÿÀ Q À Q>À QDÀ QmÀ QsÀ QÁÀ QÇÀ R&À R,À R{À R¦À R±À R²À RúÀ SGÀ S”À S¢À S¨À SçÀ SíÀ T:À T‚À T’À T˜À TäÀ TêÀ UGÀ UPÀ UQÀ UÀ UìÀ V6À V<À VvÀ V|À VÉÀ WÀ W!À WmÀ WsÀ WĞÀ WÙÀ WÚÀ X)À X|À XËÀ XÑÀ YÀ YÀ YdÀ YµÀ Y»À ZÀ ZÀ ZlÀ ZvÀ ZwÀ ZËÀ [À [cÀ [iÀ [¤À [ªÀ [üÀ \HÀ \NÀ \›À \¡À \ÿÀ ]	À ]
À ]YÀ ]yÀ ]À ]ÍÀ ]ÓÀ ^#À ^oÀ ^£À ^©À ^ôÀ _À _À _jÀ _uÀ _vÀ _ÅÀ _àÀ _æÀ `4À `:À `ŠÀ `ÑÀ aÀ aÀ aVÀ agÀ amÀ aÌÀ a×À aØÀ b(À b\À bbÀ b¯À bµÀ cÀ cÀ cÀ cWÀ c]À c¬À cøÀ dÀ d$À drÀ dxÀ dÉÀ eÀ ehÀ e·À fÀ fÀ fcÀ fkÀ flÀ f¶À f¼À gÀ gZÀ g`À g±À gÚÀ gàÀ h1À h7À h—À hÀ h­À h³À hõÀ i=À iYÀ i£À iºÀ iÆÀ iÇÀ jÀ jÀ j[À jÀ j‡À jÓÀ k À kOÀ kUÀ k¦À kòÀ lÀ lÀ lnÀ l½À mÀ mÀ mcÀ m…À m‹À méÀ mïÀ mÿÀ nÀ nUÀ nfÀ n®À nÊÀ oÀ o+À oNÀ oOÀ o˜À oÇÀ oÍÀ pÀ plÀ p½À pÜÀ pâÀ q.À q{À qªÀ q°À rÀ rÀ r%À r+À rdÀ r«À rûÀ s&À s1À s2À s€À sŸÀ s¥À sîÀ sÿÀ tÀ tcÀ tmÀ tnÀ t½À tÜÀ tâÀ u+À u<À uBÀ u¡À u¬À u­À uèÀ uîÀ v:À v‡À v¶À v¼À wÀ w,À w-À w€À w†À wÒÀ xÀ xNÀ xTÀ xµÀ xÂÀ xÃÀ yÀ y6À y<À yŒÀ yÕÀ z#À zPÀ zVÀ z¢À zïÀ {À {$À {…À {‹À {›À {¡À {ÚÀ |!À |pÀ |œÀ |©À |ªÀ |øÀ }À }À }XÀ }^À }¿À }ÅÀ }ÕÀ }ÛÀ ~À ~!À ~"À ~kÀ ~qÀ ~ÀÀ ~×À ~İÀ &À 7À =À uÀ {À İÀ ëÀ ìÀ €8À €FÀ €LÀ €›À €²À €¸À À À À PÀ VÀ ·À ÄÀ ÅÀ ‚À ‚,À ‚2À ‚À ‚ĞÀ ‚ÖÀ ƒ"À ƒoÀ ƒ·À ƒ½À „À „0À „6À „–À „¿À „ÀÀ …À …*À …0À …yÀ …À …ÈÀ †À †>À †DÀ †ŸÀ †¥À †µÀ †»À ‡À ‡4À ‡ƒÀ ‡´À ‡»À ‡¼À ˆÀ ˆ&À ˆ,À ˆuÀ ˆÅÀ ˆòÀ ˆøÀ ‰ZÀ ‰`À ‰pÀ ‰vÀ ‰¸À ŠÀ ŠÀ Š+À Š,À Š}À Š–À ŠœÀ ŠåÀ ŠëÀ ‹4À ‹„À ‹¹À ‹¿À ŒÀ Œ"À Œ2À Œ8À ŒnÀ Œ¼À 
À À À eÀ ~À „À ÍÀ À JÀ PÀ ²À ¸À ÈÀ ÎÀ À 3À ~À —À ¥À §À ¨À  À ;À ?À œÀ ãÀ çÀ ‘<À ‘À ‘æÀ ’:À ’>À ’ŒÀ ’ÇÀ ’ËÀ “$À “(À “uÀ “½À “ÜÀ “àÀ “îÀ “òÀ ”=À ”vÀ ”ŒÀ ”©À ”ÄÀ ”ãÀ •À •À •2À •ˆÀ •°À •±À •õÀ •ûÀ –AÀ –†À –À –À –ÇÀ –ÍÀ —À —>À —EÀ —FÀ —À —¸À —¾À ˜	À ˜VÀ ˜ŸÀ ˜êÀ ˜ğÀ ™ À ™0À ™6À ™…À ™¹À ™ÎÀ ™ØÀ ™ÙÀ š)À š6À š<À šŠÀ šÇÀ šÍÀ šôÀ šúÀ ›LÀ ›œÀ ›çÀ ›íÀ œÀ œ"À œ$À œ%À œIÀ œMÀ œ[À œ_À œ”À œ×À À $À dÀ jÀ »À À %À sÀ ¥À ­À ®À éÀ ïÀ Ÿ9À Ÿ‰À ŸùÀ ŸÿÀ  OÀ  tÀ  }À  ~À  ÁÀ ¡À ¡+À ¡1À ¡€À ¡ñÀ ¡÷À ¢GÀ ¢lÀ ¢rÀ ¢ÀÀ ¢àÀ ¢êÀ ¢ìÀ ¢íÀ £À £À £hÀ £¬À £°À £¾À £ÂÀ ¤À ¤À ¤UÀ ¤’À ¤¤À ¤ÚÀ ¤àÀ ¥IÀ ¥OÀ ¥—À ¥çÀ ¥óÀ ¥ùÀ ¦	À ¦À ¦]À ¦nÀ ¦¿À ¦øÀ §À §À §7À §=À §¤À §ªÀ §òÀ ¨BÀ ¨NÀ ¨TÀ ¨dÀ ¨jÀ ¨¸À ¨ÉÀ ¨ÒÀ ¨ÓÀ ©!À ©SÀ ©YÀ ©ÀÀ ©ÆÀ ªÀ ª^À ªjÀ ªpÀ ª€À ª†À ªÔÀ ªåÀ ªîÀ ªğÀ ªñÀ «+À «/À «FÀ «‚À «—À «âÀ «ğÀ «ñÀ ¬7À ¬}À ¬¤À ¬¬À ¬­À ¬ñÀ ­7À ­~À ­¼À ­ÆÀ ­ÈÀ ­ÉÀ ­øÀ ®À ®À ® À ®kÀ ®¼À ®ÂÀ ¯À ¯$À ¯qÀ ¯ÊÀ °À °8À °@À °AÀ °mÀ °sÀ °ÌÀ °ıÀ ±À ±CÀ ±IÀ ±¡À ±üÀ ²À ²À ²À ²tÀ ²˜À ²¤À ²¥À ²ÄÀ ²ÊÀ ³À ³À ³oÀ ³uÀ ³¼À ³ÂÀ ´À ´6À ´À ´“À ´£À ´©À ´ñÀ µ<À µmÀ µÊÀ µ×À µØÀ ¶$À ¶*À ¶}À ¶ÏÀ ¶øÀ ¶şÀ ·PÀ ·À ·ïÀ ¸AÀ ¸GÀ ¸—À ¸çÀ ¹5À ¹…À ¹ËÀ ¹ÑÀ ¹áÀ ¹çÀ º5À ºOÀ ºQÀ ºRÀ º”À º˜À ºŞÀ ºıÀ »À »YÀ »oÀ »zÀ »{À »ÂÀ »ÈÀ ¼À ¼QÀ ¼WÀ ¼¥À ¼õÀ ½=À ½YÀ ½©À ½úÀ ¾À ¾kÀ ¾”À ¾˜À ¾™À ¾ÈÀ ¾ÍÀ ¿À ¿cÀ ¿²À À À ÀOÀ ÀTÀ À¤À ÀõÀ ÁÀ ÁÀ ÁSÀ ÁTÀ ÁuÀ Á‘À ÁÅÀ ÁÆÀ ÁòÀ ÂÀ ÂEÀ ÂoÀ Â˜À ÂÂÀ ÂìÀ ÃÀ Ã:À ÃeÀ ÃÀ Ã¹À ÃêÀ ÄÀ ÄCÀ ÄwÀ Ä§À ÄÓÀ ÄÔÀ ÅÀ ÅRÀ Å’À ÅĞÀ ÆÀ ÆPÀ ÆÀ ÆÄÀ ÇÀ ÇDÀ Ç„À ÇĞÀ ÈÀ ÈVÀ È¨À ÈòÀ É4À É5À ÉvÀ É¸À É¹À ÉıÀ ÊÀ Ê:À ÊUÀ ÊVÀ Ê„À ÊÇÀ ÊËÀ ÊÌÀ ÊòÀ ËÀ ËHÀ ËœÀ ËÀ ËãÀ ËñÀ Ë÷À ÌÀ Ì(À ÌoÀ ÌsÀ Ì“À ÌãÀ ÍÀ Í4À ÍxÀ Í|À Í}À ÍµÀ ÍåÀ ÍæÀ ÎÀ Î%À ÎEÀ ÎKÀ Î[À ÎaÀ Î§À ÎØÀ Ï À Ï&À ÏnÀ ÏƒÀ Ï—À ÏäÀ Ğ5À Ğ„À ĞÀ ĞãÀ ÑÀ ÑXÀ ÑoÀ Ñ…À Ñ—À Ñ­À ÑÁÀ ÑâÀ ÑæÀ ÑçÀ ÒÀ ÒEÀ ÒŠÀ ÒÎÀ ÓÀ ÓfÀ ÓÀ Ó…À Ó†À Ó¾À ÓÿÀ Ô À ÔLÀ ÔRÀ Ô”À ÔåÀ Õ6À ÕWÀ Õ]À ÕªÀ ÕËÀ ÕÑÀ ÕøÀ ÕşÀ ÖÀ ÖÀ ÖcÀ Ö—À ÖáÀ Ö÷À ×À ×`À ×›À ×ŸÀ ×ÂÀ ×üÀ Ø>À ØBÀ ØCÀ Ø‡À ØÀ ØµÀ ØÑÀ Ù#À Ù'À ÙJÀ ÙoÀ Ù­À Ù±À Ù²À ÙìÀ Ú;À ÚxÀ Ú~À Ú»À ÚÖÀ ÛÀ ÛÀ Û@À ÛbÀ Û¨À Û¬À Û­À ÛîÀ ÜÀ Ü$À ÜVÀ ÜrÀ ÜÄÀ ÜÈÀ ÜëÀ İÀ İRÀ İVÀ İWÀ İ˜À İÀ İïÀ Ş:À Ş@À ŞzÀ Ş€À ŞÀ Ş¤À ßÀ ßÀ ßzÀ ß€À ßçÀ ßíÀ à9À àŠÀ à–À àœÀ à¬À à²À áÀ á-À ávÀ áµÀ áÓÀ â'À â+À âPÀ âuÀ â¸À â¼À â½À âõÀ ã,À ã-À ãxÀ ãÆÀ äÀ ä^À ä¬À ä²À ä÷À äıÀ åKÀ åoÀ åuÀ åŞÀ åäÀ æMÀ æSÀ æ¼À æÂÀ çÀ ç_À çkÀ çqÀ çÀ ç‡À çÑÀ çìÀ è5À èUÀ èÀ è¢À èÉÀ éÀ éRÀ éVÀ éWÀ é§À éåÀ éëÀ êÀ ê.À êrÀ ê“À ê¨À êÉÀ êéÀ ëDÀ ë‹À ë–À ëœÀ ë­À ë±À ë×À ëğÀ ìBÀ ìŠÀ ìÒÀ ìßÀ í,À í^À í°À î	À îZÀ î`À îdÀ îeÀ î·À ïÀ ïWÀ ï]À ï…À ïÒÀ ïöÀ ğPÀ ğTÀ ğÀ ğ¤À ğêÀ ğîÀ ğïÀ ñ)À ñ/À ñeÀ ñkÀ ñ{À ñÀ ñ½À ñõÀ ò'À òoÀ ò†À ò¶À òºÀ òØÀ òèÀ òöÀ ó%À ó\À óeÀ óxÀ ó‚À ó’À ó·À óáÀ ôAÀ ôKÀ ôSÀ ôfÀ ôpÀ ô¨À ô¬À ô­À ôôÀ õÀ õÀ õ1À õ7À õˆÀ õ©À ö À ö"À ö&À öNÀ ö”À ö´À öÒÀ ÷ À ÷À ÷À ÷[À ÷aÀ ÷eÀ ÷fÀ ÷¡À ÷§À ÷îÀ øÀ øÀ øÀ øIÀ øcÀ øuÀ øÀ øßÀ øêÀ øòÀ øüÀ ùÀ ùÀ ùÀ ùSÀ ùtÀ ùËÀ ùíÀ ùñÀ úÀ ú2À úPÀ ú~À ú†À ú“À úÔÀ û*À ûUÀ û™À û¡À û§À û«À û¬À ûëÀ ûñÀ ü=À ü‡À ü¸À üÒÀ ıÀ ıÀ ı>À ıˆÀ ıŒÀ ıÀ ı™À ı¯À ıèÀ şÀ şÀ ş=À şXÀ ştÀ şÀ ş»À şÛÀ ÿÀ ÿ&À ÿIÀ ÿQÀ ÿzÀ ÿŸÀ ÿ§À ÿÓÀ À eÀ oÀ ~À ¤À ¬À ÄÀ ÊÀ âÀÀ+À1ÀaÀ‰À¡À§ÀØÀÀÀ"ÀAÀ~À–ÀœÀºÀõÀÀÀBÀƒÀ›À¡À»ÀîÀÀÀ+ÀhÀ€À†ÀÀ×ÀİÀôÀÀÀÀÀdÀhÀ«ÀõÀ@ÀrÀvÀ©À­ÀåÀ÷ÀÀÀfÀ’À˜ÀËÀÓÀ ÀnÀ¦ÀßÀïÀ	À	À	dÀ	±À	üÀ
À
7À
DÀ
FÀ
GÀ
wÀ
À
©À
¹À
ÛÀ
ëÀ
ÀÀÀ À!ÀLÀ^ÀjÀˆÀ”ÀºÀÆÀéÀöÀ0À4À6À7ÀyÀ‘ÀßÀ,ÀtÀ¾ÀÕÀìÀòÀPÀ[À\À|À‚ÀÛÀîÀïÀÀÀbÀÀ®À¯ÀÕÀÛÀ'ÀTÀZÀoÀuÀƒÀ¡ÀÁÀÇÀÀ-ÀƒÀÅÀæÀ ÀÀ4ÀNÀYÀaÀkÀÀ‚À”ÀšÀêÀ8À„ÀÑÀÀ ÀqÀ}ÀƒÀ“À™ÀøÀ=ÀDÀFÀGÀ†À™ÀçÀ7ÀjÀvÀwÀÆÀÀHÀTÀUÀ¥ÀìÀ;ÀvÀ…À‡ÀˆÀ´ÀíÀîÀ$À(ÀhÀlÀºÀÒÀÖÀ%ÀtÀ»ÀÀQÀ_ÀcÀ¯ÀşÀEÀIÀWÀ[ÀÉÀÀ>ÀÀ›ÀÍÀİÀÀÀ"ÀAÀ[À_À`ÀÀÀ´ÀµÀóÀùÀDÀ†À§ÀÎÀÏÀ À À _À ¢À ÃÀ ëÀ ìÀ!À!À!LÀ!_À!`À!¢À!¶À!·À!ÑÀ"À"OÀ"UÀ"¦À"ÁÀ"ÇÀ#À#]À#¬À#ÌÀ#ßÀ#úÀ$'À$SÀ$iÀ$ À$µÀ$ØÀ$ğÀ$öÀ$úÀ$ûÀ%?À%EÀ%“À%©À%ÄÀ%ØÀ%èÀ&À&À&!À&À&“À&”À&ÉÀ&ÏÀ'À'+À'1À'vÀ'ÅÀ(À(À(_À(xÀ(ÈÀ)À)aÀ)­À*À*/À*]À*aÀ*bÀ*À*¤À*ğÀ+?À+kÀ+qÀ+ÀÀ,À,AÀ,À,ºÀ,ØÀ-À-*À-8À-XÀ-fÀ-À-À-ëÀ-ñÀ-õÀ-öÀ.GÀ.iÀ.oÀ.¯À.åÀ/À/À/gÀ/zÀ/„À/—À/›À/œÀ/ÍÀ/ÓÀ0"À0qÀ0ÂÀ1À1ZÀ1¨À1ôÀ2À2À2fÀ2À2•À2İÀ3.À3DÀ3JÀ3€À3†À3”À3¯À3ÏÀ3çÀ3íÀ4%À4dÀ4ƒÀ4ÍÀ4ŞÀ4ğÀ5À5`À5®À5ÔÀ6
À6À66À6>À6DÀ6fÀ6šÀ6åÀ7À7SÀ7—À7ÔÀ7íÀ7óÀ8/À8_À8eÀ8‚À8œÀ8¢À8ÄÀ8âÀ8ıÀ9À9À9'À9JÀ9PÀ9kÀ9qÀ9”À9ÍÀ9×À9İÀ:À:À:À: À:eÀ:³À:×À:éÀ:şÀ;À;AÀ;’À;àÀ<"À<+À<1À<PÀ<{À<À<€À<ÌÀ=À=À=eÀ=¯À=ÿÀ>NÀ>˜À>åÀ?À?À?+À?UÀ?WÀ?XÀ?rÀ?§À?ğÀ@À@À@^À@€À@œÀ@ªÀ@«À@úÀAÀAÀAeÀA€ÀAÀAÖÀBÀBlÀBœÀBÓÀBäÀCÀCÀCÀC!ÀC%ÀC&ÀCbÀC¸ÀDÀDÀD,ÀD?ÀDWÀDcÀD{ÀDÈÀDàÀE*ÀEbÀEiÀEÀEÀE“ÀE”ÀEßÀFÀFFÀFbÀFcÀFŒÀFÀFÓÀFòÀFóÀFÿÀG/ÀG1ÀG2ÀGLÀGmÀG¡ÀG£ÀG¤ÀGÖÀHÀHÀHGÀHKÀH‡ÀH¡ÀH¥ÀHïÀI8ÀI†ÀIÌÀJÀJ@ÀJDÀJ}ÀJÀJÀJ™ÀJÓÀKÀK2ÀKÀKÊÀKçÀL3ÀLRÀLsÀLyÀLÀL…ÀL›ÀLŸÀL«ÀL¸ÀLòÀM3ÀMsÀM²ÀMşÀNÀNgÀN¯ÀNĞÀNÖÀNŞÀNğÀO:ÀOVÀO\ÀOšÀO¶ÀOôÀOõÀP$ÀP*ÀPwÀP’ÀP“ÀP¼ÀPÂÀQ
ÀQÀQ\ÀQqÀQsÀQtÀQ”ÀQ˜ÀQàÀQúÀQşÀR6ÀRSÀRjÀRÀR¦ÀR§ÀRÖÀRÜÀSÀS5ÀSPÀSQÀSyÀSÀSÃÀSÉÀTÀT ÀTaÀT‘ÀTµÀT¶ÀUÀU)ÀU/ÀUzÀUŸÀU±ÀU³ÀU´ÀV ÀVÀVNÀViÀVnÀV§ÀVÅÀVÙÀVÚÀVôÀVõÀWÀW<ÀW=ÀW‘ÀW±ÀW²ÀWÑÀWÒÀWŞÀX(ÀX)ÀX‚ÀX§ÀX¨ÀX´ÀXßÀY'ÀYÀYªÀYÍÀZ.ÀZ8ÀZqÀZ€ÀZ¨ÀZäÀ[&À[2À[:À[BÀ[[À[yÀ[À[œÀ[ À[¡À[İÀ\.À\~À\À\‹À\ÍÀ\èÀ\éÀ\õÀ]VÀ]XÀ]YÀ]|À]€À]ÏÀ^À^mÀ^À^”À^æÀ_4À_OÀ_À_´À`À`KÀ`—À`çÀ`úÀ`şÀaIÀa“ÀaãÀb2Àb~ÀbÏÀcÀcfÀc¢Àc¦ÀcğÀd:ÀdŠÀdÆÀdÊÀeÀe#ÀeHÀe\ÀepÀe…Àe£Àe®ÀeúÀf$Àf0ÀfNÀfnÀf’Àf—Àf™ÀfšÀf½ÀfÁÀgÀg`Àg®ÀgÑÀgÕÀh)ÀhwÀh°Àh´ÀiÀiVÀibÀifÀi±ÀiûÀjKÀjšÀjæÀk7Àk†ÀkÎÀl
ÀlÀlXÀl¢ÀlòÀm.Àm2ÀmÀm‹ÀmÀm´Àm¸ÀnÀnSÀnÀnÆÀnõÀoÀo%Ào:ÀoXÀo]Ào…Ào‘ÀoĞÀoíÀp1ÀpYÀpcÀpªÀpÔÀpŞÀpæÀq.Àq5Àq:Àq<Àq=Àq`ÀqdÀq¯Àq³Àr ÀrOÀrÀr’ÀrÛÀs*Às@ÀsDÀs’ÀsßÀt+ÀtlÀt»ÀuÀu[Àu«ÀuâÀuæÀv0ÀvzÀv®Àv²ÀvÿÀwÀwÀw4Àw8ÀwˆÀwÓÀxÀxFÀxsÀxÀx¹ÀxÄÀxîÀy:ÀyBÀyÀyÜÀzÀzEÀzjÀz‘Àz˜Àz¦Àz¼ÀzÀÀzÂÀzÃÀ{À{5À{7À{8À{‡À{°À{´À{ÂÀ{ÆÀ|À|1À|mÀ|ƒÀ|šÀ|À|À|ãÀ|çÀ|õÀ|ùÀ}EÀ}ƒÀ}«À}ÃÀ}ïÀ}õÀ~DÀ~\À~À~»À~éÀ~êÀÀÀmÀ½À€À€XÀ€ƒÀ€‰À€¿À€ÓÀ€ÔÀÀ	ÀYÀ¨ÀõÀ‚CÀ‚mÀ‚sÀ‚©À‚¾À‚¿À‚ËÀƒÀƒ	Àƒ
ÀƒSÀƒWÀƒ¦ÀƒôÀ„;À„…À„²À„´À„µÀ…À…LÀ…†À…£À…¥À…¦À…ãÀ…çÀ†5À†€À†˜À†œÀ†èÀ‡9À‡xÀ‡|À‡ÇÀˆÀˆaÀˆ°ÀˆüÀ‰MÀ‰œÀ‰äÀŠ ÀŠ$ÀŠnÀŠ¸À‹À‹DÀ‹`À‹tÀ‹À‹À‹¥À‹ÈÀ‹ÙÀ‹íÀŒÀŒ ÀŒ%ÀŒBÀŒvÀŒzÀŒ˜ÀŒÎÀŒÒÀŒÓÀŒûÀ À^ÀnÀ„ÀœÀ¸ÀÕÀŞÀßÀüÀBÀlÀvÀ¿ÀëÀõÀıÀşÀÀ*ÀNÀtÀ~ÀœÀàÀûÀÀ"ÀHÀdÀ„À…À±À½ÀÃÀÅÀÆÀ‘À‘#À‘'À‘^À‘rÀ‘¼À‘ÂÀ’À’bÀ’±À’ÜÀ’âÀ“À“%À“&À“hÀ“nÀ“¿À”À”À”OÀ”ZÀ”\À”]À”À”…À”“À”—À”æÀ•À•!À•UÀ•[À•©À•ôÀ–5À–;À–KÀ–QÀ– À–ºÀ–ÈÀ—À—=À—CÀ—‘À—ßÀ—ùÀ—ÿÀ˜À˜FÀ˜SÀ˜À˜¤À˜òÀ™=À™rÀ™{À™ÆÀ™ÿÀšÀšSÀš§Àš­Àš½ÀšúÀ›À›5À›;À›‰À›ÔÀœÀœÀœ+Àœ1ÀœzÀœ“Àœ¨ÀœªÀœ«ÀœüÀÀiÀŒÀ’ÀâÀ+À|ÀÅÀßÀåÀŸ4ÀŸ€ÀŸºÀŸÀÀ À 0À BÀ DÀ EÀ À çÀ¡À¡À¡À¡*À¡rÀ¡À¡À¡À¡ÂÀ¡ÆÀ¢À¢À¢RÀ¢‘À¢¥À¢©À¢ïÀ£À£À£]À£ À£ÈÀ£ÌÀ¤À¤IÀ¤_À¤ÌÀ¤ğÀ¥À¥À¥9À¥?À¥ŒÀ¥ÛÀ¥şÀ¦2À¦bÀ¦yÀ¦}À¦~À¦¼À¦ÂÀ§À§$À§HÀ§IÀ§~À§¡À§¢À§êÀ¨À¨À¨_À¨lÀ¨À¨À¨×À©	À©6À©7À©zÀ©ºÀ©ÉÀ©ÏÀª@ÀªµÀªûÀªüÀ«?À«†À«ËÀ«ØÀ¬&À¬'À¬lÀ¬³À¬ÂÀ¬ÈÀ­5À­¦À­øÀ­ùÀ®>À®…À®ÊÀ®ßÀ¯9À¯:À¯€À¯ÄÀ°	À°PÀ°uÀ°{À°èÀ±YÀ±ŸÀ± À±æÀ²*À²oÀ²¶À²üÀ³$À³rÀ³sÀ³¶À³ØÀ³ŞÀ´!À´EÀ´KÀ´’À´ÒÀµÀµ]Àµ¤ÀµèÀ¶À¶À¶aÀ¶—À¶èÀ¶éÀ·8À·}À·ƒÀ·ÒÀ¸À¸_À¸†À¸ŒÀ¸ÑÀ¹ À¹lÀ¹rÀ¹•À¹¶À¹ÑÀ¹ìÀºÀºÀºÀº]Àº¢Àº¨ÀºÜÀºâÀ»1À»À»ÂÀ¼À¼À¼UÀ¼£À¼ğÀ½À½"À½<À½]À½xÀ½“À½®À½´À½µÀ½üÀ¾À¾.À¾/À¾qÀ¾ŸÀ¾¥À¾÷À¿EÀ¿`À¿aÀ¿©À¿æÀÀ%ÀÀfÀÀ¬ÀÀğÀÁ4ÀÁ@ÀÁFÀÁ²ÀÂ"ÀÂ(ÀÂ˜ÀÃÀÃLÀÃMÀÃŸÀÃ­ÀÃ³ÀÄÀÄ'ÀÄ-ÀÄtÀÄ¨ÀÄ©ÀÄëÀÅ.ÀÅ>ÀÅ\ÀÅ]ÀÅ£ÀÅ©ÀÅöÀÆDÀÆoÀÆ±ÀÆ²ÀÆøÀÇ7ÀÇtÀÇzÀÇÇÀÈÀÈCÀÈŒÀÈÀÈÒÀÉÀÉ#ÀÉ$ÀÉiÀÉ­ÀÉÈÀÉØÀÉÙÀÊ)ÀÊvÀÊ•ÀÊ›ÀÊãÀÊéÀË.ÀËMÀËNÀËÀË½ÀËÚÀËÛÀÌÀÌKÀÌrÀÌsÀÌ¨ÀÌ®ÀÌşÀÍKÀÍ–ÀÍÕÀÍÛÀÎ,ÀÎ{ÀÎÍÀÏÀÏdÀÏ²ÀÏÀÀĞÀĞÀĞÀĞfÀĞyÀĞÀĞÏÀÑÀÑWÀÑ ÀÑÌÀÒÀÒ0ÀÒ6ÀÒ­ÀÒ±ÀÒ²ÀÓÀÓ2ÀÓ8ÀÓ„ÀÓÌÀÔÀÔjÀÔ´ÀÔìÀÔòÀÕ=ÀÕŠÀÕÓÀÖÀÖÀÖ]ÀÖªÀÖúÀ×=À×ŠÀ××ÀØ&ÀØvÀØÅÀØËÀÙÀÙhÀÙœÀÙ¢ÀÙóÀÚ>ÀÚxÀÚzÀÚ{ÀÚÅÀÚíÀÛÀÛÀÛ`ÀÛ¥ÀÛ¸ÀÛ¹ÀÛòÀÜÀÜÀÜZÀÜ€ÀÜÀÜÀÜÑÀÜİÀİÀİÀİsÀİ’Àİ“ÀİíÀŞÀŞÀŞ&ÀŞ„ÀŞ°ÀŞ±ÀŞ½Àß#ÀßYÀßZÀßfÀßÄÀßğÀßñÀßıÀàcÀà™ÀàšÀà¦ÀáÀánÀáoÀá{ÀáüÀâ'ÀâZÀâ[ÀâgÀâæÀãAÀãBÀãNÀãÕÀä8Àä9ÀäEÀä¼ÀåÀåÀåÀå—ÀåîÀåïÀåûÀæMÀæmÀæÌÀæĞÀæÑÀçTÀçÚÀçÛÀççÀè
Àè+ÀèFÀèaÀè|ÀèƒÀè§ÀèËÀé%Àé)Àé*Àé°Àê=Àê>ÀêJÀêeÀêÀê Àê»ÀêÖÀêñÀêøÀë!ÀëEÀë±ÀëµÀë¶ÀìDÀìiÀìÀì•Àì«ÀìÁÀìØÀìíÀíÀíÀíÀí-ÀíMÀí‰ÀíÀíÀíıÀîMÀîNÀîZÀîvÀî–ÀîÒÀîÖÀî×ÀïFÀï–Àï—Àï£ÀïäÀğÀğWÀğ[Àğ\ÀğÚÀñOÀñPÀñ\Àñ‘ÀñÃÀñÇÀñÈÀòÀòWÀòXÀòdÀòƒÀò¥ÀòÉÀòÍÀòÎÀóÀóFÀóGÀóSÀó–ÀóºÀóÕÀóıÀôKÀôXÀô“Àô™ÀôÀôÀôşÀõ@ÀõAÀõ³ÀöÀöÀö ÀöjÀöÀö©ÀöÑÀ÷%À÷2À÷tÀ÷zÀ÷~À÷À÷æÀø/Àø0Àø¨ÀùÀùÀùÀùhÀùÀù‚ÀùÀùÛÀùôÀùõÀúÀú!ÀúDÀúnÀúrÀúsÀúÓÀûÀûÀûÀû-ÀûQÀûÀû§Àû¸Àû¼Àû½ÀüÀüPÀüQÀü]Àü…Àü«ÀüÙÀüøÀı	ÀıÀıÀıaÀı Àı¡Àı­ÀıÂÀıíÀş+Àş/Àş0ÀşuÀşšÀş›ÀşüÀÿFÀÿGÀÿSÀÿÀÿ»Àÿ¿ÀÿÀÀÿÌÀÿëÀÿíÀÿîÀ 0À 4À BÀ  À °À áÀ çÀÀ:À;À€À†ÀÛÀÀDÀŒÀÀ‘À°À¶À	ÀMÀfÀgÀ”ÀšÀëÀ=ÀYÀpÀqÀ¡À§À÷ÀFÀbÀhÀ¶ÀÀTÀ¢À³ÀøÀ1À3À4À|À€ÀÑÀÀcÀgÀ­À±ÀıÀ	LÀ	jÀ	nÀ	¸À
À
)À
iÀ
˜À
îÀ
ïÀÀÀ$ÀVÀXÀYÀ¨ÀÂÀıÀ(À)ÀDÀgÀhÀtÀÀÂÀãÀûÀ^ÀºÀ.À7À=ÀWÀ[À\ÀhÀ|À£ÀÓÀæÀìÀÀÀÀÀÀ\À`À¨ÀóÀAÀeÀiÀ·ÀÀRÀ¢ÀğÀşÀÀ/ÀmÀ¯ÀâÀãÀÀÀhÀ²ÀûÀÀÀ8À>ÀŒÀÒÀ"ÀAÀXÀYÀ„ÀŠÀÚÀ!ÀoÀ¾À÷ÀıÀKÀ›ÀêÀ#À=À>À]À^À®ÀÕÀÛÀ*ÀwÀÀ•ÀÊÀĞÀÀHÀ‰ÀÀÀ×ÀİÀÀcÀ±ÀÀÀÀÀ‡À‰ÀŠÀÅÀúÀÀ#À$ÀyÀ»À¼ÀàÀVÀxÀ|À}ÀŞÀÀÀPÀ€ÀÎÀ À LÀ hÀ {À ˆÀ À ÄÀ éÀ òÀ øÀ üÀ ıÀ!XÀ!À!ŸÀ!ŞÀ"À"{À"©À"ìÀ"ıÀ#À#À#rÀ#àÀ#áÀ$À${À$ŸÀ$£À$¤À%À%/À%0À%[À%`À%µÀ%ßÀ%÷À&#À&3À&PÀ&VÀ&gÀ&kÀ&lÀ&ÆÀ&ìÀ&íÀ'9À'?À'€À' À'¢À'£À'ØÀ(À(%À(]À(^À(«À(îÀ(øÀ(ùÀ)GÀ)“À)ÁÀ)ÊÀ)ËÀ*À*iÀ*¬À*µÀ*¶À+À+À+À+À+ À+mÀ+½À+ÏÀ+ÓÀ,$À,7À,‚À,ˆÀ,¼À,ÂÀ-À-À-hÀ-¶À.À.À.À.lÀ.rÀ.˜À.À.®À.´À/À/À/+À/<À/AÀ/BÀ/\À/sÀ/tÀ/ºÀ0À0/À0eÀ0fÀ0rÀ0•À0´À0ÖÀ0ùÀ0ıÀ0şÀ1
À1=À1>À1JÀ1›À1À1À1¿À1üÀ1şÀ1ÿÀ2:À2]À2iÀ2¯À2±À2²À2åÀ3
À3)À35À3sÀ3ŠÀ3³À3ÚÀ4À4+À4PÀ4TÀ4VÀ4WÀ4À4¡À4ÍÀ4ÎÀ4ëÀ4ìÀ4øÀ56À5MÀ5eÀ5ˆÀ5ªÀ5ÌÀ5ãÀ6À6*À6LÀ6cÀ6‡À6©À6ÌÀ6äÀ7À7À7À7À7bÀ7²À7şÀ8À8À8+À8@À8VÀ8iÀ8qÀ8…À8ãÀ9BÀ9À9ÂÀ9ÊÀ9ÏÀ9àÀ:À:)À:rÀ:°À:ÊÀ;À;"À;sÀ;yÀ;¼À;úÀ<À<SÀ<nÀ<¾À<ÄÀ<ØÀ<òÀ=À=-À=_À=…À=·À=ÚÀ=õÀ=ıÀ>À><À>ZÀ>À>ÃÀ>õÀ?À?JÀ?RÀ?qÀ?À?¬À?ŞÀ@À@À@BÀ@tÀ@|À@€À@‚À@ƒÀ@ÔÀA#ÀAqÀA½ÀAîÀAòÀB;ÀBHÀBsÀBÀÀCÀCUÀC[ÀC¬ÀCúÀD'ÀDbÀDzÀDšÀD²ÀDÎÀDÏÀEÀE`ÀEuÀE{ÀEÈÀEğÀEöÀF)ÀF\ÀFÀFÂÀFõÀFûÀGJÀG–ÀGœÀGªÀGêÀHÀHÀH/ÀHFÀHPÀHZÀH`ÀHrÀHxÀH™ÀHŸÀH­ÀHëÀIÀI#ÀI?ÀI[ÀIeÀIoÀIuÀIüÀJÀJÀJMÀJpÀJ“ÀJ¶ÀJÙÀJãÀJíÀJóÀK|ÀK‚ÀKÀKÑÀK÷ÀLÀLCÀLiÀLsÀL}ÀL­ÀLÄÀLßÀLùÀMÀMÀMdÀMtÀMœÀM³ÀMÎÀMæÀNÀNÀN^ÀNyÀN¡ÀN¸ÀNÓÀNëÀOÀOÀO,ÀOKÀOjÀO}ÀO~ÀO®ÀOãÀP'ÀPpÀP¹ÀPºÀPÒÀPŞÀQ+ÀQ,ÀQUÀQjÀQÀQµÀQÌÀQÖÀQşÀRÀREÀRcÀRzÀR„ÀRÏÀRùÀSÀSRÀSvÀS«ÀSºÀSüÀTÀTÀTÀTÀT6ÀTbÀTvÀT|ÀTœÀT¼ÀTóÀUÀU@ÀUDÀUEÀUQÀUfÀUÀUóÀU÷ÀUøÀVÀV%ÀV:ÀVQÀVŠÀV£ÀVÒÀVöÀW(ÀWLÀW~ÀWÀW²ÀW¸ÀW¼ÀW½ÀWÉÀWßÀWôÀXÀXDÀX]ÀXŒÀX°ÀXâÀYÀY8ÀYGÀYãÀYéÀYíÀYïÀYğÀZ.ÀZ2ÀZ‚ÀZÍÀ[À[5À[pÀ[’À[ÊÀ[ŞÀ\À\#À\$À\HÀ\‚À\–À\ÏÀ\ÓÀ]À]GÀ][À]yÀ]}À]~À]­À]òÀ^À^$À^(À^)À^wÀ^À^ºÀ^»À^ûÀ_À_À_À_¶À_·À`
À`;À`<À` À`ÊÀ`ËÀa/ÀaYÀa[Àa\ÀaÀa“Àa¡Àa¥ÀaôÀbAÀbÀb¸ÀcÀc/ÀcLÀcÀcËÀcÌÀdÀdwÀdĞÀdÔÀdÕÀe"ÀehÀe·ÀeúÀeşÀeÿÀfCÀf•ÀfãÀg%Àg)Àg*ÀgnÀgtÀgÂÀhÀh>ÀhÀh­ÀhëÀhñÀiSÀiWÀiXÀi¢Ài¨Ài÷Àj.ÀjSÀj¯Àj÷ÀjûÀjüÀkMÀkšÀkÁÀkÂÀlÀlCÀlcÀleÀlfÀl˜ÀlãÀläÀlşÀm#Àm$ÀmEÀm‰Àm•ÀmÌÀmÍÀmÙÀnÀnÀn)ÀnmÀnnÀnzÀnÀnÉÀnİÀnãÀo
Ào:ÀolÀopÀoqÀo}ÀoÅÀoÇÀoÈÀp ÀpdÀpeÀp|Àp“Àp®Àp¯ÀpÃÀqÀqÀqHÀqIÀqdÀq|Àq§ÀqÔÀrÀr0Àr6Àr:Àr;ÀrGÀr‘Àr’ÀrÀréÀrêÀröÀsÀsEÀsYÀs_ÀsŒÀs®ÀsĞÀs÷ÀsûÀsüÀtÀt;Àt=Àt>ÀtpÀt¸Àt¹ÀtÑÀtéÀtêÀu.Àu:ÀuqÀurÀu~Àu¾Àu¿ÀuËÀvÀvÀvÀv<ÀvhÀv|Àv‚Àv©ÀvÍÀvòÀvöÀv÷ÀwÀw8Àw:Àw;ÀwlÀw³Àw´ÀwÌÀwäÀwåÀx(Àx4ÀxkÀxlÀxxÀx·Àx¸ÀxÄÀyÀyÀyÀy4Ày`ÀytÀyzÀy ÀyÄÀyéÀyíÀyîÀyúÀz/Àz1Àz2ÀzeÀz¶Àz·ÀzØÀzùÀzúÀ{À{ZÀ{fÀ{À{À{ªÀ|À|À|!À|wÀ|xÀ|„À|§À|ÓÀ|çÀ|íÀ}À}AÀ}nÀ}rÀ}sÀ}À}¼À}¾À}¿À}şÀ~À~RÀ~¥À~éÀ$À`À•À®ÀÂÀ€À€
À€À€XÀ€À€ÏÀ€èÀ€üÀ-À1À2ÀvÀÈÀ÷À‚À‚$À‚TÀ‚XÀ‚YÀ‚À‚£À‚ñÀƒ;ÀƒlÀƒ…Àƒ©ÀƒçÀƒíÀ„À„;À„?À„@À„rÀ„¥À„¾À„ÒÀ…À…<À…@À…AÀ…tÀ…¨À…ÁÀ…ÕÀ†+À†À†ºÀ†¾À†¿À†ÿÀ‡À‡ À‡À‡ÕÀ‡ÖÀˆ?Àˆ|Àˆ}ÀˆåÀ‰!À‰"À‰|À‰ÁÀ‰ÂÀŠ!ÀŠ^ÀŠ_ÀŠÏÀ‹"À‹#À‹qÀ‹—À‹´À‹¶À‹·À‹ıÀŒ2ÀŒgÀŒ±ÀŒÍÀŒéÀŒ÷ÀŒøÀÀÀAÀGÀ˜À³ÀËÀÛÀüÀÀÀ.À2À3ÀƒÀ¦À¬ÀùÀCÀŒÀÖÀÜÀ!À4ÀDÀ’À¯ÀÂÀÌÀĞÀÒÀÓÀ‘(À‘AÀ‘EÀ‘’À‘àÀ’-À’}À’À’ÖÀ“*À“ƒÀ“ÛÀ”.À”WÀ”[À”µÀ”ÚÀ”ŞÀ”ìÀ”ğÀ•4À•~À•ÎÀ•øÀ–BÀ–ŠÀ–±À–şÀ—LÀ—fÀ—¡À—±À˜À˜À˜]À˜£À˜©À™À™!À™'À™ŠÀ™íÀšOÀšXÀšYÀšªÀš°À›À›fÀ›’À›˜À›òÀœOÀœUÀœ»À!À†À’À“ÀæÀìÀDÀœÀòÀŸÀŸÀŸmÀŸÃÀŸØÀŸŞÀ BÀ ¦À¡	À¡À¡À¡TÀ¡ZÀ¡´À¢À¢À¢%À¢~À¢À¢¤À£À£jÀ£ÌÀ£ÕÀ£×À£ØÀ¤À¤7À¤qÀ¤šÀ¤´À¤÷À¥À¥5À¥TÀ¥sÀ¥wÀ¥ˆÀ¥ŠÀ¥‹À¥ŒÀ¥½À¥åÀ¦À¦@À¦aÀ¦eÀ¦vÀ¦xÀ¦yÀ¦­À¦ÕÀ§À§8À§VÀ§yÀ§À§ÀÀ§ßÀ§şÀ¨À¨À¨À¨À¨SÀ¨uÀ¨—À¨ÄÀ¨İÀ¨öÀ©À©(À©9À©;À©<À©„À©ˆÀ©ÚÀ©íÀ©ñÀ©ÿÀªÀªyÀª}Àª¢Àª×ÀªİÀ«,À«}À«ÇÀ¬À¬gÀ¬¸À­À­*À­0À­À­µÀ­»À®À®À®åÀ¯KÀ¯QÀ¯œÀ¯âÀ¯ıÀ°À°PÀ°£À°ãÀ°öÀ±À±À±0À±NÀ±vÀ±À±µÀ±ØÀ²À²'À²TÀ²˜À²ÛÀ³CÀ³WÀ³²À³¶À³·À´À´"À´(À´wÀ´ÈÀµÀµaÀµ²À¶À¶SÀ¶uÀ¶{À¶ÉÀ¶ÿÀ·À·hÀ·ËÀ¸/À¸•À¸›À¸ìÀ¹2À¹MÀ¹SÀ¹ À¹óÀº3Àº9Àº…ÀºÓÀ»À»kÀ»ºÀ»ßÀ»òÀ¼À¼À¼2À¼PÀ¼xÀ¼’À¼¥À¼ÂÀ¼éÀ½%À½8À½eÀ½ÍÀ¾À¾À¾vÀ¾ÒÀ¿À¿,À¿–À¿£ÀÀÀÀ"ÀÀ®ÀÀ´ÀÀ¸ÀÀ¹ÀÁ	ÀÁ'ÀÁ-ÀÁxÀÁÆÀÂÀÂÀÂVÀÂ§ÀÂñÀÃ@ÀÃ‘ÀÃâÀÄ2ÀÄTÀÄZÀÄªÀÄëÀÄñÀÅSÀÅµÀÆÀÆ}ÀÆƒÀÆÒÀÇ"ÀÇEÀÇKÀÇ˜ÀÇëÀÈ+ÀÈ=ÀÈPÀÈjÀÈˆÀÈ°ÀÈÍÀÈğÀÉ
ÀÉ1ÀÉWÀÉ“ÀÉ¦ÀÉÓÀÊÀÊ~ÀÊ’ÀËÀËÀËÀËIÀËiÀËjÀËÙÀÌ^ÀÌ_ÀÌŞÀÌûÀÍÀÍ'ÀÍ<ÀÍVÀÍuÀÍ‰ÀÍ¦ÀÍ§ÀÎGÀÎeÀÎzÀÎÀÎ©ÀÎ¼ÀÎÏÀÎçÀÏÀÏ ÀÏ4ÀÏQÀÏRÀÏØÀÏôÀĞ
ÀĞ ÀĞ:ÀĞYÀĞmÀĞ†ÀĞÀĞ¹ÀĞºÀĞİÀÑÀÑ1ÀÑQÀÑ©ÀÑ±ÀÑ¾ÀÑîÀÒJÀÒRÀÒXÀÒ\ÀÒ^ÀÒ_ÀÒÀÒÅÀÒëÀÒñÀÓ-ÀÓ|ÀÓÂÀÓôÀÓúÀÔJÀÔ™ÀÔ§ÀÔ­ÀÔôÀÕ:ÀÕgÀÕmÀÕ³ÀÖÀÖPÀÖmÀÖ‰ÀÖ×ÀÖùÀ× À×"À×2À×RÀ×À×–À×ªÀØÀØ6ÀØTÀØZÀØ^ÀØ_ÀØkÀØ~ÀØ“ÀØ£ÀØ§ÀØ¨ÀØèÀÙÀÙ	ÀÙ…ÀÙõÀÙöÀÚAÀÚfÀÚ®ÀÚÊÀÚÌÀÚÍÀÛÀÛ,ÀÛ0ÀÛZÀÛªÀÛèÀÜÀÜ4ÀÜHÀÜ|ÀÜ™ÀÜ¸ÀÜ¾ÀÜÎÀÜëÀÜşÀİÀİÀİÀİ#Àİ$ÀİiÀİoÀİ¸ÀİıÀŞJÀŞ`ÀŞÀŞãÀß,ÀßvÀß£ÀßëÀà-ÀàHÀà}ÀàƒÀàµÀáÀá0ÀáFÀáNÀáRÀáSÀáŒÀáßÀâ,ÀâzÀâËÀâàÀãÀãAÀãBÀãwÀãÂÀäÀä<Àä|Àä—Àä¥Àä«Àä¬ÀäèÀåÀå6Àå<Àå@ÀåAÀå]Àå|Àå}Àå™Àå³Àå´ÀåøÀæÀæÀæuÀæ¨Àæ©ÀæİÀç1Àç3Àç4ÀçgÀçkÀç ÀçèÀè8Àè†Àè¬Àè°ÀèıÀéJÀé˜ÀéáÀêÀêEÀê®ÀêÊÀêÙÀêûÀëÀëÀë#Àë$Àë@ÀëAÀëÀë­Àë®ÀëâÀëèÀì6Àì„ÀìÏÀíÀímÀí—ÀíÀíäÀíêÀíøÀîÀî6ÀîUÀîpÀîzÀî€ÀîÎÀîØÀîŞÀîìÀï=ÀïhÀï™ÀïÊÀïĞÀğÀğNÀğ™ÀğäÀñ/Àñ5Àñ\Àñ†ÀñÀñ˜ÀñÀñëÀò@ÀòQÀòWÀò¡ÀòÌÀó!Àó=ÀóAÀóBÀóxÀó~ÀóÖÀôÀôÀôlÀôÀô¾ÀõÀõ=ÀõAÀõBÀõ„ÀõŠÀõÙÀö%Àö`ÀölÀöÀö”Àö¶ÀöÆÀöÊÀöËÀ÷0À÷–À÷—ÀøÀø?Àø@ÀøœÀøÁÀøÂÀùÀù1Àù3Àù4Àù…Àù‰Àù¬ÀùéÀùûÀúCÀúPÀúQÀúŸÀú°Àú±ÀûÀûÀûÀûhÀû¦ÀûçÀûöÀûøÀûùÀü1Àü5Àü„ÀüÊÀıÀıaÀı±Àı×ÀıÛÀş(ÀşvÀşÅÀşÕÀşÙÀÿ%ÀÿtÀÿÃÀ À ]À ­À üÀIÀdÀhÀµÀÿÀLÀnÀrÀÁÀÀSÀ¤ÀõÀEÀhÀŸÀæÀìÀ:À‡ÀÕÀ ÀOÀUÀ¢ÀËÀÑÀ"ÀpÀ¿ÀüÀÀ ÀoÀ¾ÀÄÀ	À	?À	EÀ	•À	æÀ
7À
ƒÀ
ÑÀÀgÀwÀ}ÀËÀõÀûÀ9À?À‹ÀÜÀ-ÀyÀ À¬ÀÁÀßÀøÀÀ6À=À|ÀÇÀÍÀ$À{ÀÀ‘À®ÀğÀ$ÀEÀ“ÀÜÀ)À8ÀDÀNÀVÀiÀsÀ¹À	À6ÀDÀxÀ™À§ÀŞÀÀÀÀ‚ÀÄÀÊÀÎÀÏÀ ÀOÀUÀ£ÀğÀ>À‰À¸À¾ÀÀUÀ¡ÀğÀÀ	ÀZÀ©ÀğÀAÀ’ÀáÀÀÀmÀ¼ÀÀVÀÀ•ÀåÀ6À‡À×À!ÀmÀ¾ÀëÀñÀ?ÀÀŞÀÀÀPÀ`ÀuÀ’À©ÀÎÀçÀîÀÀƒÀ‰ÀÌÀ À À tÀ ËÀ ÑÀ áÀ şÀ!@À!xÀ!™À!çÀ"5À"‚À"‘À"À"§À"¯À"ÂÀ"ÌÀ# À#bÀ#hÀ#lÀ#mÀ#ÏÀ$À$)À$]À$›À$ËÀ$şÀ$ÿÀ%OÀ%rÀ%…À%À%­À%ÅÀ%ØÀ%âÀ%òÀ%öÀ%÷À&BÀ&gÀ&¬À&ÈÀ&ÉÀ&ãÀ'-À'3À'À'—À'²À'ÆÀ'ÖÀ'òÀ(À(À(€À(„À(†À(‡À(ÕÀ(ÙÀ)À)YÀ)jÀ)ŒÀ)’À)àÀ**À*cÀ*iÀ*¶À+À+À+%À+&À+`À+fÀ+¬À+²À+ôÀ,
À,À,À,JÀ,PÀ,’À,¨À,³À,µÀ,¶À- À-À-À-/À-=À-uÀ-ƒÀ-„À-½À-ÊÀ-ÌÀ-ÍÀ.À.À.MÀ.‘À.ÒÀ.ÖÀ/À/oÀ/¸À/ÕÀ/ÙÀ0)À0rÀ0§À0«À0øÀ17À1;À1aÀ1eÀ1°À2 À2NÀ2À2çÀ3À3À3iÀ3°À3ÈÀ4À4)À4/À4xÀ4ÀÀ5À5_À5¬À5ïÀ5õÀ6<À6RÀ6¢À6£À6ëÀ6ñÀ7À7#À73À79À7ŠÀ7¿À7ÎÀ7ÏÀ8 À8qÀ8ÀÀ9	À9À9À9jÀ9»À:	À:QÀ:ŸÀ:éÀ:ïÀ;<À;BÀ;fÀ;lÀ;ºÀ<À<VÀ<¦À<ËÀ<ÑÀ=À=hÀ=¹À>À>UÀ>¥À>íÀ?À? À?jÀ?ƒÀ?‰À?—À?ÄÀ?ìÀ@À@CÀ@lÀ@£À@ÜÀ@öÀAÀAÀA"ÀA(ÀAwÀAÅÀBÀB1ÀB7ÀBEÀBrÀBµÀBİÀBôÀC4ÀCkÀC¤ÀC¾ÀCÆÀCĞÀCÖÀD'ÀDmÀD·ÀD½ÀDËÀDøÀEÀEcÀEœÀE¶ÀEÍÀF.ÀFgÀFÀF‰ÀF“ÀF™ÀFäÀG-ÀG~ÀG¶ÀG¼ÀGàÀGæÀH%ÀH+ÀHyÀHÇÀIÀIcÀI²ÀJ ÀJKÀJ–ÀJçÀK8ÀKSÀKYÀKiÀKoÀK¿ÀKáÀL)ÀL?ÀLlÀLmÀL­ÀLÌÀLÒÀMÀMÀM`ÀM¤ÀM¶ÀM·ÀNÀN`ÀN²ÀN¸ÀN÷ÀNıÀOKÀO›ÀO½ÀOßÀOàÀP#ÀPhÀP¯ÀPäÀPêÀQÀQ%ÀQ&ÀQvÀQÆÀQîÀQïÀR>ÀRˆÀR™ÀRŸÀRåÀR÷ÀSÀSÀStÀS“ÀS”ÀSåÀT1ÀT€ÀT©ÀTÌÀTÍÀUÀUXÀUÀU€ÀUÓÀV)ÀVEÀVKÀVÀVëÀW;ÀWhÀW†ÀW‡ÀWÕÀWìÀWòÀXHÀXNÀX’ÀX˜ÀXêÀY2ÀY[ÀYaÀY«ÀY¿ÀZÀZÀZiÀZˆÀZÀZåÀZëÀ[/À[5À[‡À[ÏÀ\À\YÀ\ZÀ\¨À\¼À\ÂÀ]À]À]bÀ]hÀ]ºÀ^À^+À^bÀ^cÀ^´À_À_YÀ_jÀ_pÀ_ÄÀ`À`iÀ`¸ÀaÀaZÀa­ÀaüÀbMÀbiÀboÀb§ÀbùÀcMÀcœÀcŞÀcäÀd2ÀdYÀd_ÀdmÀdÀd­ÀdæÀe#ÀeBÀe|Àe¸ÀeÇÀeÏÀeÙÀeßÀf0Àf|Àf×Àg+Àg;ÀgAÀg‡ÀgÔÀhÀhÀh^Àh­ÀhùÀiÀi&ÀiCÀiDÀi•ÀiçÀj:Àj@ÀjÀjâÀk2Àk‚ÀkÔÀl(Àl{ÀlˆÀlÀlÃÀlæÀlçÀm*ÀmvÀm“ÀmÇÀmÈÀnÀn_ÀneÀn³Àn¹Ào$Ào“ÀoÇÀoÈÀo÷ÀoıÀpBÀp]Àp|Àp}ÀpÍÀqÀqÀqyÀqèÀrÀrÀrcÀr¥Àr«ÀsÀs‡Às³Às´ÀtÀtTÀtzÀt€ÀtÅÀtÿÀu ÀuMÀuÀuÁÀuÇÀv2Àv¡ÀvÊÀvËÀwÀwhÀw·ÀwÚÀwàÀxMÀx¾Àx÷ÀxøÀy4Ày:ÀyzÀyÇÀzÀzeÀz¶À{À{2À{8À{§À|À| À|xÀ|ÖÀ|×À}À}À}[À}¤À}ĞÀ}ùÀ}úÀ~HÀ~ŸÀ~ÚÀ~ÛÀ*ÀvÀ|ÀËÀäÀêÀ€6À€À€’À€ÖÀ€×ÀÀ$ÀrÀÀÀ‚À‚ZÀ‚À‚£À‚ñÀƒ>ÀƒŒÀƒÓÀƒäÀ„+À„,À„sÀ„ŒÀ„±À„²À„şÀ…À…À…_À…lÀ…rÀ…¾À†À†IÀ†OÀ†À†êÀ†ğÀ‡AÀ‡À‡ÛÀ‡áÀˆ+ÀˆwÀˆÄÀˆşÀˆÿÀ‰DÀ‰JÀ‰‘À‰—À‰İÀŠ'ÀŠ-ÀŠ=ÀŠCÀŠ“ÀŠ¬ÀŠöÀŠ÷À‹<À‹BÀ‹’À‹ßÀ‹åÀŒ+ÀŒuÀŒ{ÀŒ‹ÀŒ‘ÀŒßÀŒıÀIÀJÀ”ÀšÀæÀ÷ÀıÀFÀ—À®À´ÀıÀKÀ—ÀßÀ/ÀzÀÅÀ‘À‘aÀ‘«À‘åÀ‘ëÀ’À’À’(À’yÀ’ÅÀ’ìÀ“>À“ˆÀ“‰À“ÍÀ“ÓÀ”$À”}À”ĞÀ•$À•\À•bÀ•²À–À–RÀ–¤À–ôÀ—HÀ—”À—šÀ—ëÀ˜;À˜À˜çÀ™À™kÀ™¹À™ıÀšÀšVÀš¥ÀšğÀ›>À›“À›™À›íÀœ>Àœ‡ÀœÀœŞÀœùÀœÿÀÀ"ÀKÀ^ÀuÀ}ÀƒÀ±ÀçÀíÀFÀdÀ…À‹ÀÀÌÀíÀŸ$ÀŸXÀŸ‚ÀŸ¡ÀŸ½ÀŸúÀ À 6À |À ªÀ ØÀ éÀ şÀ¡2À¡uÀ¡œÀ¡¦À¡¬À¡»À¡ÃÀ¡ÍÀ¡ÓÀ¢,À¢2À¢@À¢UÀ¢™À¢¬À¢ÃÀ¢ÖÀ¢ïÀ¢÷À¢ıÀ£+À£aÀ£gÀ£ÀÀ£ŞÀ£ÿÀ¤À¤À¤FÀ¤gÀ¤À¤ÒÀ¤üÀ¥'À¥CÀ¥€À¥À¥¼À¦À¦0À¦^À¦oÀ¦„À¦¸À¦ûÀ§À§EÀ§yÀ§¥À§¯À§µÀ§ÄÀ§ÌÀ§ÖÀ§ÜÀ¨%À¨pÀ¨£À¨©À¨¹À¨¿À©À©$À©BÀ©qÀ©”À©ºÀ©áÀªÀª!Àª"ÀªfÀªlÀª½À«À«iÀ«½À¬À¬aÀ¬˜À¬À¬îÀ­6À­<À­À­ÍÀ­øÀ­şÀ®LÀ®–À®œÀ®èÀ¯5À¯…À¯‹À¯æÀ¯÷À¯ıÀ°À° À°IÀ°\À°sÀ°{À°À°¯À°åÀ°ëÀ±DÀ±bÀ±ƒÀ±‰À±›À±ÊÀ²À²iÀ²ºÀ²ÖÀ³À³eÀ³À³ÈÀ³şÀ´'À´NÀ´~À´¦À´¬ÀµÀµ`ÀµºÀµüÀ¶(À¶TÀ¶“À¶ÒÀ¶ŞÀ¶ÿÀ·]À·gÀ·mÀ·|À·„À·À·”À·íÀ·óÀ¸À¸À¸ZÀ¸mÀ¸„À¸—À¸°À¸¸À¸¾À¸ìÀ¹"À¹(À¹À¹ŸÀ¹ÀÀ¹ÆÀ¹ØÀºÀºWÀº¦Àº÷À»À»XÀ»¢À»àÀ¼À¼CÀ¼yÀ¼¢À¼ÉÀ¼ùÀ½!À½'À½‚À½ÙÀ¾4À¾‘À¾ÜÀ¿"À¿KÀ¿eÀ¿ À¿¼À¿ØÀÀÀÀHÀÀtÀÀƒÀÀºÀÀñÀÁ&ÀÁ[ÀÁaÀÁ»ÀÂÀÂmÀÂ´ÀÂãÀÂïÀÃÀÃ~ÀÃˆÀÃÀÃÀÃ¥ÀÃ¯ÀÃµÀÃÅÀÃËÀÄÀÄ-ÀÄNÀÄ}ÀÄ¤ÀÄËÀÄõÀÅÀÅ;ÀÅ<ÀÅ‰ÀÅÀÅßÀÅôÀÅúÀÆ ÀÆwÀÆyÀÆzÀÆÈÀÇ	ÀÇ)ÀÇ†ÀÇŒÀÇÀÀÇßÀÇşÀÈZÀÈ^ÀÈ_ÀÈÉÀÉ>ÀÉ?ÀÉ›ÀÉ÷ÀÊ<ÀÊaÀÊbÀÊnÀÊ¼ÀÊÔÀÊÕÀÊøÀËÀË,ÀËUÀË~ÀË§ÀËĞÀËÙÀËßÀËğÀËôÀËõÀÌÀÌ/ÀÌIÀÌ…ÀÌ’ÀÌ¶ÀÍÀÍ!ÀÍ%ÀÍ&ÀÍˆÀÍâÀÍãÀÎXÀÎÛÀÎÜÀÎèÀÏ9ÀÏTÀÏUÀÏaÀÏÀÀÏëÀÏìÀÏøÀĞOÀĞnÀĞoÀĞ{ÀĞŞÀÑÀÑÀÑÀÑ[ÀÑ\ÀÑ»ÀÑéÀÑêÀÑöÀÒNÀÒvÀÒwÀÒƒÀÒáÀÓÀÓÀÓÀÓBÀÓbÀÓ ÀÓ¦ÀÓ¿ÀÓÃÀÓÄÀÔÀÔBÀÔCÀÔOÀÔnÀÔŸÀÔ»ÀÔÏÀÔÓÀÔÔÀÕ$ÀÕXÀÕYÀÕeÀÕÁÀÕáÀÕûÀÖHÀÖ–ÀÖØÀ×0À×4À×5À×´ÀØ#ÀØ$ÀØ0ÀØkÀØÀØ¿ÀØÃÀØÄÀÙÀÙXÀÙYÀÙeÀÙÀÙÎÀÙÒÀÙÓÀÚ,ÀÚkÀÚlÀÚxÀÚ–ÀÚÅÀÚæÀÛ,ÀÛ0ÀÛ1ÀÛ‡ÀÛÀÀÛÁÀÛÍÀÛñÀÜ ÀÜGÀÜÀÜ‘ÀÜ’ÀÜîÀİ-Àİ.Àİ:ÀİoÀİÀİ¡Àİ¢ÀŞÀŞ:ÀŞ;ÀŞGÀŞ|ÀŞœÀŞ¼ÀßÀßÀß	Àß}ÀßõÀßöÀàÀà"ÀàOÀàSÀàTÀà©ÀàöÀà÷ÀáÀá-ÀáMÀágÀá¥ÀâÀâÀâÀâÀâ€ÀãÀãÀãÀã<Àã^Àã Àã¤Àã¥ÀäÀäbÀäcÀäoÀäªÀäÌÀäîÀåFÀåJÀåKÀå±Àæ%Àæ&Àæ2Àæ\Àæ|Àæ–ÀæÔÀç0Àç6Àç:Àç;Àç¯Àè1Àè2Àè>ÀèxÀè—ÀèÙÀèİÀèŞÀéLÀé½Àé¾ÀéÊÀê)ÀêIÀêÅÀêÉÀêÊÀëSÀëmÀë€Àë’Àë¦Àë»ÀëÔÀëíÀìÀì&ÀìAÀìBÀìNÀìxÀì¹Àì½Àì¾Àí!ÀíÀí€ÀíŒÀíÈÀíêÀîÀîÀî©Àî÷ÀîıÀïÀïÀïÀğ	Àğ
ÀğÀğ[Àğ}ÀğœÀğ»ÀğòÀñ%ÀñWÀñ‹ÀñÀÀñóÀò%ÀòYÀòÀòÇÀòıÀóBÀó[Àó©Àó¯Àó³Àó´ÀôeÀôˆÀôœÀô²ÀôÇÀôŞÀôöÀõÀõ!Àõ8ÀõPÀõsÀõÀõ¬Àõ­Àõ¹ÀöÀö#ÀöEÀödÀö›ÀöÑÀ÷À÷=À÷uÀ÷¨À÷ÚÀøÀøCÀø|Àø²Àø÷ÀùÀù^ÀùdÀùhÀùiÀúÀú=ÀúQÀújÀú‚ÀúœÀú·ÀúÍÀúâÀúùÀûÀû4ÀûNÀûmÀûnÀûzÀû ÀûÄÀûñÀûõÀûöÀüLÀü‚ÀüƒÀüÀüÊÀıÀıBÀıfÀı‘ÀıÉÀıÍÀıÎÀıÚÀş%Àş~Àş‚ÀşƒÀşÀşÜÀşşÀÿIÀÿOÀÿ–ÀÿšÀÿ›À  À qÀ rÀ ~À ÉÀ îÀ9À=À>À¬ÀÀÀ+ÀIÀxÀ›ÀÁÀèÀ	À)ÀKÀÀÀ·ÀáÀ,À2ÀÀçÀíÀîÀ5ÀtÀuÀŸÀ¿ÀäÀ	À.ÀdÀ†À¨ÀŞÀÀHÀ|À¢ÀÇÀîÀÀÀÀ†ÀÇÀÿÀ	 À	&À	…À	ËÀ	ÒÀ	ÓÀ	ìÀ
:À
@À
DÀ
EÀ
QÀ
rÀ
¡À
ÈÀ
ïÀÀ=À`À‘À’ÀºÀçÀ5À;ÀYÀ·À½ÀùÀrÀxÀ°À±À×À,ÀvÀ}À~À—ÀåÀëÀïÀğÀ„À£ÀÆÀàÀşÀÀ3ÀLÀeÀzÀ˜À™À¥ÀıÀPÀTÀUÀÀÀ&À'À3ÀuÀwÀxÀ¦ÀåÀæÀ.À2ÀfÀjÀ±ÀóÀ5ÀNÀÀ“ÀŞÀ ÀAÀjÀkÀ¬À²ÀıÀ@ÀaÀ‹ÀŒÀ¶À¼ÀÀZÀ£ÀÓÀÔÀÀÀSÀ¢ÀñÀ:À@ÀÀŞÀÀÀaÀªÀÃÀÉÀÀ-ÀYÀZÀªÀÍÀßÀàÀ&À,ÀzÀÀªÀ«ÀôÀúÀKÀ}ÀÀŸÀ ÀğÀ:ÀVÀ\À’À¨À©ÀµÀæÀşÀ#ÀWÀ]ÀsÀÃÀàÀúÀ À JÀ TÀ ^À eÀ iÀ jÀ ÈÀ!À!À!*À!WÀ!oÀ!”À!ÈÀ!ÎÀ!ÏÀ!ôÀ"À"RÀ"VÀ"WÀ"·À"ıÀ"şÀ#
À#À#5À#EÀ#]À#pÀ#zÀ#À#­À#±À#²À#ıÀ$"À$fÀ$‚À$ƒÀ$À$À$ªÀ$ÅÀ$ÙÀ$éÀ%À%À%"À%’À%–À%—À%£À&À&*À&+À&7À&YÀ&[À&\À&£À&§À&ìÀ'1À'5À'[À'_À'ªÀ'÷À(?À(À(×À)"À)RÀ)VÀ)¡À)èÀ*	À*JÀ*‘À*­À*ãÀ*äÀ+À+%À+iÀ+°À+çÀ,,À,hÀ,€À,À,°À,¶À-À-QÀ-–À-°À-²À-³À.À.BÀ.CÀ.‡À.§À.¨À.´À.ßÀ.àÀ.ìÀ/À/"À/fÀ/lÀ/£À/¿À/ŞÀ/òÀ0EÀ0ŒÀ0±À0ÅÀ0ÉÀ0ÊÀ1#À1]À1^À1xÀ1yÀ1…À1ÈÀ1ÊÀ1ËÀ1àÀ1äÀ2 À2/À2IÀ2OÀ2šÀ2åÀ2ÿÀ3À3FÀ3LÀ3›À3´À3ÅÀ3óÀ4À4-À4‚À4ƒÀ4³À4×À5À5,À5SÀ5zÀ5¤À5¥À5ÕÀ5ÛÀ6-À6PÀ6eÀ6fÀ6¥À6«À6ùÀ7EÀ7‡À7À7ŸÀ7ñÀ8À8À8?À8EÀ8xÀ8~À8«À9À9TÀ9ˆÀ9ŒÀ9À9ÉÀ9ÏÀ:À:>À:?À:ŒÀ:’À:ÏÀ;À;EÀ;KÀ;À;ØÀ<'À<IÀ<]À<pÀ<†À<ÉÀ<ÍÀ<ÎÀ= À=.À=NÀ=aÀ=uÀ=”À=»À=ÂÀ=ÆÀ=ÇÀ=÷À=ıÀ>FÀ>‹À>¯À>µÀ>ÛÀ?(À?rÀ?½À@	À@WÀ@§À@ôÀA8ÀA>ÀAÀA­ÀAÂÀAúÀBÀB&ÀB;ÀBJÀBkÀBsÀB€ÀB—ÀB²ÀBÁÀBØÀCÀCBÀC„ÀCÀC—ÀCÀC¡ÀC¢ÀCÛÀCáÀD)ÀD/ÀDRÀD ÀDÂÀDÕÀDÛÀDñÀEÀE3ÀEnÀEÀEÍÀEÓÀF
ÀF1ÀF7ÀFnÀFÀF•ÀF¨ÀF¬ÀF­ÀF¹ÀFÜÀFşÀGÀGÀG2ÀGRÀGtÀGŸÀG£ÀG¤ÀG°ÀGîÀGïÀH;ÀHÀH©ÀHãÀHşÀIÀIÀIÀI\ÀI’ÀI“ÀI­ÀIúÀJ,ÀJaÀJbÀJ›ÀJâÀJãÀKÀKGÀKHÀKÀK¬ÀK­ÀKüÀL6ÀL\ÀLbÀLcÀL{ÀLÀL€ÀLŒÀLÏÀLÑÀLÒÀMÀMÀMlÀM‚ÀMÀÀMãÀMäÀN2ÀNGÀNˆÀNÍÀNÿÀO,ÀOJÀONÀOOÀO‰ÀOÀOÈÀPÀPKÀP”ÀPŞÀQÀQSÀQÀQ¿ÀQûÀRÀR0ÀR\ÀRdÀRÀR•ÀR™ÀRšÀRËÀRÑÀS
ÀSGÀS‚ÀS³ÀSèÀTÀTÀTWÀT_ÀTˆÀTÀT”ÀT•ÀTéÀU-ÀU.ÀU‹ÀUØÀUÙÀV5ÀVÀV‚ÀV¶ÀVÓÀVâÀVãÀWÀWÀW,ÀW2ÀWƒÀWÀW¶ÀWÆÀWçÀWúÀXÀXÀXÀXÀXnÀX‘ÀX—ÀXäÀY.ÀY{ÀYÈÀZÀZ4ÀZGÀZWÀZvÀZ“ÀZ¦ÀZ°ÀZÀÀZÄÀZÅÀ[À[5À[À[À[ŸÀ[ À[ëÀ[ïÀ\>À\VÀ\wÀ\°À\¶À]À]XÀ]rÀ]xÀ]ÆÀ^À^ZÀ^—À^¶À^ÔÀ^ìÀ_À_À_>À_aÀ_bÀ_­À_ğÀ`:À`lÀ`¤À`ÄÀ`ÈÀ`ÉÀ`óÀ`ùÀa4ÀaEÀaFÀaqÀawÀa²ÀaÄÀaÅÀa÷ÀaıÀb4ÀbMÀbNÀbÀbÁÀbÇÀcÀc7ÀcIÀcJÀc˜Àc´ÀcºÀdÀdRÀdcÀdiÀd·ÀdßÀe(Àe*Àe+Àe‹Àe©ÀeªÀeãÀeéÀf9Àf‹Àf¥Àf«ÀfùÀgLÀgÀgÊÀgèÀhÀhÀh7ÀhJÀhpÀhwÀh‹Àh¡ÀhæÀhşÀiLÀiPÀiQÀi³ÀjÀjÀjpÀjşÀjÿÀkÀkÀkhÀk„Àk…Àk‘Àk¼Àk½ÀkÍÀkÎÀl(ÀlEÀlFÀlRÀl€ÀlÀl˜Àl™ÀlúÀmÀmÀm+ÀmnÀmoÀm{ÀmÇÀmâÀmãÀmïÀn?ÀnrÀnŒÀn’ÀnÇÀnâÀnèÀnéÀo Ào;ÀoXÀo–ÀoÕÀpÀpIÀpOÀppÀp’Àp“Àp½ÀpøÀq
ÀqÀqÀqzÀqĞÀqÑÀqİÀrfÀrhÀriÀrÀrÎÀrÏÀsÀsUÀsVÀsÀs’ÀsÜÀséÀt,Àt-ÀtnÀtŠÀtßÀtàÀu/ÀuDÀuGÀu”Àu±Àu´Àv ÀvÀvÀvÀv#ÀvWÀvZÀv•ÀvÒÀv×ÀvÚÀvùÀw)Àw.Àw5Àw8ÀwÀwãÀxÀxÀxhÀxœÀxÒÀyÀy]ÀyšÀy°ÀyÜÀyñÀzÀz2ÀzAÀzÀz‰Àz–Àz³Àz¹Àz¿ÀzÑÀzèÀ{À{À{#À{%À{&À{iÀ{¯À{åÀ|,À|pÀ|­À|ÃÀ|şÀ}À}0À}=À}QÀ}‡À}–À}ßÀ}çÀ}íÀ}óÀ~À~À~8À~<À~WÀ~YÀ~ZÀ~©À~÷À~ûÀKÀ›ÀĞÀ€À€PÀ€QÀ€†À€À€ŸÀ€ñÀÀÀÀ/À‰À¢ÀºÀ‚À‚*À‚0À‚NÀ‚RÀ‚T       0‡İ·Î‚†/// An immutable 32 bit color value in ARGB format.
///
/// Consider the light teal of the Flutter logo. It is fully opaque, with a red
/// channel value of 0x42 (66), a green channel value of 0xA5 (165), and a blue
/// channel value of 0xF5 (245). In the common "hash syntax" for color values,
/// it would be described as `#42A5F5`.
///
/// Here are some ways it could be constructed:
///
/// ```dart
/// Color c1 = const Color(0xFF42A5F5);
/// Color c2 = const Color.fromARGB(0xFF, 0x42, 0xA5, 0xF5);
/// Color c3 = const Color.fromARGB(255, 66, 165, 245);
/// Color c4 = const Color.fromRGBO(66, 165, 245, 1.0);
/// ```
///
/// If you are having a problem with `Color` wherein it seems your color is just
/// not painting, check to make sure you are specifying the full 8 hexadecimal
/// digits. If you only specify six, then the leading two digits are assumed to
/// be zero, which means fully-transparent:
///
/// ```dart
/// Color c1 = const Color(0xFFFFFF); // fully transparent white (invisible)
/// Color c2 = const Color(0xFFFFFFFF); // fully opaque white (visible)
/// ```
///
/// [Color]'s color components are stored as floating-point values. Care should
/// be taken if one does not want the literal equality provided by `operator==`.
/// To test equality inside of Flutter tests consider using `package:test`'s
/// `isSameColorAs`.
///
/// See also:
///
///  * [Colors](https://api.flutter.dev/flutter/material/Colors-class.html),
///    which defines the colors found in the Material Design specification.
///  * [`isSameColorAs`](https://api.flutter.dev/flutter/flutter_test/isSameColorAs.html),
///    a Matcher to handle floating-point deltas when checking [Color] equality. Œƒ ‘5‘:‚‚/// Construct an sRGB color from the lower 32 bits of an [int].
///
/// The bits are interpreted as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value.
///
/// In other words, if AA is the alpha value in hex, RR the red value in hex,
/// GG the green value in hex, and BB the blue value in hex, a color can be
/// expressed as `const Color(0xAARRGGBB)`.
///
/// For example, to get a fully opaque orange, you would use `const
/// Color(0xFFFF9000)` (`FF` for the alpha, `FF` for the red, `90` for the
/// green, and `00` for the blue).‘;	‘@  ‘N‘R‘S‘]‘§‘q‘k‘t‘~‘x‘‘‹‘…‘‘‘‘˜‘¢‘£‘­î’°’±’µ€í/// Construct a color with normalized color components.
///
/// Normalized color components allows arbitrary bit depths for color
/// components to be be supported. The values will be normalized relative to
/// the [ColorSpace] argument.’¾’Ï  ’Û’ì  ’ö“  ““$  “/!“5  “A“K“L“]“[“_“p“n“r“““ƒ“”“’“–“Ÿ‚(•l•m•u©/// Construct an sRGB color from the lower 8 bits of four integers.
///
/// * `a` is the alpha value, with 0 being transparent and 255 being fully
///   opaque.
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromRGBO], which takes the alpha value as a floating point
/// value.•v•{  •}•‚  •„•‰  •‹•  •š••Ÿ•©•Å•ª•­•°•³•¶•À•Á•Ë€·•Ö•×•á •é	•î  •ô•ù  •ı	–  ––  ––  –1–5–6–@–€–N–S–Z–o–`–m–g–a–i–q–v–†‚b˜~˜˜‡Ô/// Create an sRGB color from red, green, blue, and opacity, similar to
/// `rgba()` in CSS.
///
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
/// * `opacity` is alpha channel of this color as a double, with 0.0 being
///   transparent and 1.0 being fully opaque.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromARGB], which takes the opacity as an integer value.˜ˆ˜  ˜˜”  ˜–˜›  ˜˜¥  ˜µ˜¹˜º˜Ä˜æ˜Å˜È˜Ë˜Î˜×˜á˜â˜ì€»˜÷˜ø™ ™™  ™
™  ™™  ™™   ™(™.  ™C™A™E™X™V™e™Z™c™]™[™_™g™v™t™ƒ™x™™{™y™}™…™”™’™¡™–™Ÿ™™™—™›™£™«€®šX€—/// The alpha channel of this color.
///
/// A value of 0.0 means this color is fully transparent. A value of 1.0 means
/// this color is fully opaque. š^3š"/// The red channel of this color. š–5šÊ$/// The green channel of this color. šĞ4›#/// The blue channel of this color. ›	@›?"/// The color space of this color. › ÇœÜ€ë/// A 32 bit value representing this color.
///
/// The bits are assigned as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value.  œœœœ§œĞœ¨k€õ<€§/// The alpha channel of this color in an 8 bit value.
///
/// A value of 0 means this color is fully transparent. A value of 255 means
/// this color is fully opaque.  &0'd€èŸ4€£/// The alpha channel of this color as a double.
///
/// A value of 0.0 means this color is fully transparent. A value of 1.0 means
/// this color is fully opaque.  ŸŸŸŸ%ŸŸPzŸ¨4/// The red channel of this color in an 8 bit value.  Ÿ‡ŸˆŸ’ŸœŸ“ŸÎ} (6/// The green channel of this color in an 8 bit value.        O{ ¨5/// The blue channel of this color in an 8 bit value.   ‡ ˆ ’ œ “¾œD¾°   ¾œ¾›NN›Y  ›f›n    Îƒ ¡€¾/// Returns a new color that matches this color with the passed in components
/// changed.
///
/// Changes to color components will be applied before applying changes to the
/// color space. ¡°¡¹  ¡Å¡Î  ¡Ø¡á  ¡í¡ö  ¢¢   ¤r	¥5€´/// Returns a new color that matches this color with the alpha channel
/// replaced with `a` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ¥?¥D   ¥‘¦€Æ/// Returns a new color that matches this color with the alpha channel
/// replaced with the given `opacity` (which ranges from 0.0 to 1.0).
///
/// Out of range values will have unexpected effects. ¦œ¦¤  ¦N¦O¦Y¦†¦Z§§Õ€²/// Returns a new color that matches this color with the red channel replaced
/// with `r` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. §İ§â   ¨	¨â€´/// Returns a new color that matches this color with the green channel
/// replaced with `g` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ¨ì¨ñ   ©,©î€³/// Returns a new color that matches this color with the blue channel replaced
/// with `b` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ©÷©ü   ªv€Åª„  ªª¥   «?‚`¬M€ú/// Returns a brightness value between 0 for darkest and 1 for lightest.
///
/// Represents the relative luminance of the color. This value is computationally
/// expensive to calculate.
///
/// See <https://en.wikipedia.org/wiki/Relative_luminance>.   ­£‡æ²¥„Ç/// Linearly interpolate between two colors.
///
/// This is intended to be fast but as a result may be ugly. Consider
/// [HSVColor] or writing custom logic for interpolating colors.
///
/// If either color is null, this function linearly interpolates from a
/// transparent instance of the other color. This is usually preferable to
/// interpolating from [material.Colors.transparent] (`const
/// Color(0x00000000)`), which is specifically transparent _black_.
///
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]). Each channel
/// will be clamped to the range 0 to 255.
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController]. ²ª²²  ²´²¼  ²¾²Æ   µ†À·¡ö/// Combine the foreground color as a transparent color over top
/// of a background color, and return the resulting combined color.
///
/// This uses standard alpha blending ("SRC over DST") rules to produce a
/// blended color from two colors. This can be used as a performance
/// enhancement when trying to avoid needless alpha blending compositing
/// operations for two things that are solid colors with the same shape, but
/// overlay each other: instead, just paint one with the combined color. ·¬·³  ·¾·Å   ¼Q€í¼Úw/// Returns an alpha value representative of the provided [opacity] value.
///
/// The [opacity] value may not be null. ¼î¼ö   ½BV½\  ½_½g  ½B½C¾ä€Å¾÷   ¾ä¾å À ºRÀ JÅÀ »	€ª/// A description of the style to use when drawing on a [Canvas].
///
/// Most APIs on [Canvas] take a [Paint] object to describe the style
/// to use for that operation. À »f À »qÀ »vY/// Constructs an empty [Paint] object with all fields initialized to
/// their defaults.  À »}ƒÀ ½DÀ ½EÀ ½I±/// Constructs a new [Paint] object with the same fields as [other].
///
/// Any changes made to the object returned will not affect [other], and
/// changes to [other] will not affect the object returned.
///
/// Backends (for example web versus native) may have different performance
/// characteristics. If the code is performance-sensitive, consider profiling
/// and falling back to reusing a single [Paint] object if necessary.À ½JÀ ½Q   ,À ÁwLÀ Á¢ 	À ÁwÀ ÁxÀ Á~À ÁÀ ÁÀ ÁªÀ Á²À ÁÂÀ Á³À Áô'À Â À ÂÀ Â$À Â0 À ÂBÀ ÂG&À ÂX À ÂlÀ Âq%À Â‚ À Â•À Âš&À Â« À Â¿À ÂÄ&À ÂÕ À ÂéÀ Âî%À Âÿ À ÃÀ Ã!À Ã( À Ã7À Ã<'À ÃM À ÃbÀ Ãg%À Ãx À Ã‹À Ã'À Ã¡ À ÃµÀ Ã»-À ÃÌ À ÃæÀ Ãì*À Ãı À ÄÀ Ä'À Ä+ À Ä?À ÄE0À ÄV À ÄsÀ Äy,À ÄŠ À Ä£À Ä©(À Äº À ÄÏÀ ÄÖ>À Äç À ÅÀ ÄıÀ ÅÀ Å8À Å) À ÅLÀ Å<À ÅOÀ ÅT<À Åe À ÅŒÀ ÅzÀ ÅÀ Å”:À Å¥ À ÅÊÀ Å¹À ÅÍÀ ÅÒ<À Åã À Æ
À ÅøÀ ÆÀ Æ<À Æ# À ÆJÀ Æ8À ÆMÀ ÆR:À Æc À ÆˆÀ ÆwÀ Æ‹À Æ2À Æ¡ À Æ¾À Æ±À ÆÁÀ ÆÆ>À Æ× À Ç À ÆíÀ ÇÀ Ç:À Ç À Ç>À Ç-À ÇAÀ ÇF<À ÇW À Ç~À ÇlÀ ÇÀ Ç†HÀ Ç— À ÇÊÀ Ç²À ÇÍÀ ÇÒBÀ Çã À ÈÀ ÇûÀ ÈÀ È<À È) À ÈPÀ È>À ÈSÀ ÈXNÀ Èi À È¢À È‡À È¥À ÈªFÀ È» À ÈìÀ ÈÕÀ ÈïÀ Èô>À É À É.À ÉÀ É1À Éx%À É‰ À É›À Ê 3À ÊK À Ê À Ê!À Ê'À Ê8À Ê(À ÊÎ"À Êß À ÊïÀ Êô'À Ë À ËÀ Ë'À Ë0 À ËEÀ ËJ"À Ë[ À ËkÀ Í·,À ÍÈ À ÍÙÀ ÓÀ=À ÓÑ À ÓæÀ ÓïÀ ÓğÀ Ó÷À ÓøÀ â÷3À ã À ã'À ËŸ€ÓÀ Ìi/// Whether to apply anti-aliasing to lines and images drawn on the
/// canvas.
///
/// Defaults to true.   À ÌuÀ Ìy  À Ì…
À Ì‹   À ÍèƒıÀ Ï„/// The color to use when stroking or filling a shape.
///
/// Defaults to opaque black.
///
/// See also:
///
///  * [style], which controls whether to stroke or fill (or both).
///  * [colorFilter], which overrides [color].
///  * [shader], which overrides [color] with more elaborate effects.
///
/// This color is not used when compositing. To colorize a layer, use
/// [colorFilter].   À Ñé›À Ñí  À ÑóÀ Ñú   À ÔƒœÀ ×‚Ò/// A blend mode to apply when a shape is drawn or a layer is composited.
///
/// The source colors are from the shape being drawn (e.g. from
/// [Canvas.drawPath]) or layer being composited (the graphics that were drawn
/// between the [Canvas.saveLayer] and [Canvas.restore] calls), after applying
/// the [colorFilter], if any.
///
/// The destination colors are from the background onto which the shape or
/// layer is being composited.
///
/// Defaults to [BlendMode.srcOver].
///
/// See also:
///
///  * [Canvas.saveLayer], which uses its [Paint]'s [blendMode] to composite
///    the layer when [Canvas.restore] is called.
///  * [BlendMode], which discusses the user of [Canvas.saveLayer] with
///    [blendMode].   À ×¡€ À ×¥  À ×¯À ×º   À ØE€áÀ ØÉk/// Whether to paint inside shapes, the edges of shapes, or both.
///
/// Defaults to [PaintingStyle.fill].   À Ù)€‡À Ù-  À Ù3À ÙB   À Ù´iÀ ÚÈ€ş/// How wide to make edges drawn when [style] is set to
/// [PaintingStyle.stroke]. The width is given in logical pixels measured in
/// the direction orthogonal to the direction of the path.
///
/// Defaults to 0.0, which correspond to a hairline width.   À Û €‹À Û$  À Û0À Û8   À Û¯À Üf€ /// The kind of finish to place on the end of lines drawn when
/// [style] is set to [PaintingStyle.stroke].
///
/// Defaults to [StrokeCap.butt], i.e. no caps.   À ÜÊ€‹À ÜÎ  À ÜØÀ Üã   À İY„ÑÀ áÆ„+/// The kind of finish to place on the joins between segments.
///
/// This applies to paths drawn when [style] is set to [PaintingStyle.stroke],
/// It does not apply to points drawn as lines with [Canvas.drawPoints].
///
/// Defaults to [StrokeJoin.miter], i.e. sharp corners.
///
/// Some examples of joins:
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeMiterLimit] to control when miters are replaced by bevels when
///    this is set to [StrokeJoin.miter].
///  * [strokeCap] to control what is drawn at the ends of the stroke.
///  * [StrokeJoin] for the definitive list of stroke joins.   À â-€À â1  À â<À âH   À ã/…rÀ èB„Ó/// The limit for miters to be drawn on segments when the join is set to
/// [StrokeJoin.miter] and the [style] is set to [PaintingStyle.stroke]. If
/// this limit is exceeded, then a [StrokeJoin.bevel] join will be drawn
/// instead. This may cause some 'popping' of the corners of a path if the
/// angle between line segments is animated, as seen in the diagrams below.
///
/// This limit is expressed as a limit on the length of the miter.
///
/// Defaults to 4.0.  Using zero as a limit will cause a [StrokeJoin.bevel]
/// join to be used all the time.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_0_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_6_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeJoin] to control the kind of finish to place on the joins
///    between segments.
///  * [strokeCap] to control what is drawn at the ends of the stroke.   À è¤€±À è¨  À è¹À èÁ   À éY‚WÀ ê!€¯/// A mask filter (for example, a blur) to apply to a shape after it has been
/// drawn but before it has been composited into the image.
///
/// See [MaskFilter] for details.   À ë³‚°À ë·  À ëÂÀ ëÏ   À îgìÀ ïæ/// Controls the performance vs quality trade-off to use when sampling bitmaps,
/// as with an [ImageShader], or when drawing images, as with [Canvas.drawImage],
/// [Canvas.drawImageRect], [Canvas.drawImageNine] or [Canvas.drawAtlas].
///
/// Defaults to [FilterQuality.none].   À ğV€—À ğZ  À ğhÀ ğw   À ğñÈÀ ò}k/// The shader to use when stroking or filling a shape.
///
/// When this is null, the [color] is used instead.
///
/// See also:
///
///  * [Gradient], a shader that paints a color gradient.
///  * [ImageShader], a shader that tiles an [Image].
///  * [colorFilter], which overrides [shader].
///  * [color], which is used if [shader] and [colorFilter] are null.   À ò¼ïÀ òÀ  À òÇÀ òĞ   À ô¯vÀ õ›€Î/// A color filter to apply when a shape is drawn or when a layer is
/// composited.
///
/// See [ColorFilter] for details.
///
/// When a shape is being drawn, [colorFilter] overrides [color] and [shader].   À ö(<À ö,  À ö8À öF   À ÷h‚ˆÀ ùfÈ/// The [ImageFilter] to use when drawing raster images.
///
/// For example, to blur an image using [Canvas.drawImage], apply an
/// [ImageFilter.blur]:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.drawImage(
///     _image,
///     ui.Offset.zero,
///     Paint()..imageFilter = ui.ImageFilter.blur(sigmaX: 0.5, sigmaY: 0.5),
///   );
/// }
/// ```
///
/// See also:
///
///  * [MaskFilter], which is used for drawing geometry.   À ùó·À ù÷  À úÀ ú   À û®nÀ üÃ/// Whether the colors of the image are inverted when drawn.
///
/// Inverting the colors of an image applies a new color filter that will
/// be composed with any user provided color filters. This is primarily
/// used for implementing smart invert on iOS.   À ılÀ ı#  À ı0
À ı6   À ÊXrÀ Êf    À ı‡†À ı¢   À ıÀ ı Àî¦hÀ“„/// Opaque handle to raw decoded image data (pixels).
///
/// To obtain an [Image] object, use the [ImageDescriptor] API.
///
/// To draw an [Image], use one of the methods on the [Canvas] class, such as
/// [Canvas.drawImage].
///
/// A class or method that receives an image object must call [dispose] on the
/// handle when it is no longer needed. To create a shareable reference to the
/// underlying image, call [clone]. The method or object that receives
/// the new instance will then be responsible for disposing it, and the
/// underlying image itself will be disposed when all outstanding handles are
/// disposed.
///
/// If `dart:ui` passes an `Image` object and the recipient wishes to share
/// that handle with other callers, [clone] must be called _before_ [dispose].
/// A handle that has been disposed cannot create new handles anymore.
///
/// See also:
///
///  * [Image](https://api.flutter.dev/flutter/widgets/Image-class.html), the class in the [widgets] library.
///  * [ImageDescriptor], which allows reading information about the image and
///    creating a codec to decode it.
///  * [instantiateImageCodec], a utility method that wraps [ImageDescriptor]. À€ÁÀ¢À£À¤ À¥À«  À²
À¸  À¾ÀÄ   Àƒ/À¬ ÀƒÀ„ÀŠÀ›À‹À·ÀÄ€ç/// A callback that is invoked to report an image creation.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onCreate] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀÑÀ à€é/// A callback that is invoked to report the image disposal.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onDispose] directly because [MemoryAllocations]
/// allows multiple callbacks. À îÀ ú  À!
SÀ!XA/// The number of image pixels along the image's horizontal axis. À!bRÀ!®?/// The number of image pixels along the image's vertical axis. À!¹À!¾ À!ÊÀ$ı•À%´€¥/// Whether this reference to the underlying image is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   À*dƒÀ,ËÌ/// The color space that is used by the [Image]'s colors.
///
/// This value is a consequence of how the [Image] has been created.  For
/// example, loading a PNG that is in the Display P3 color space will result
/// in a [ColorSpace.extendedSRGB] image.
///
/// On rendering backends that don't support wide gamut colors (anything but
/// iOS impeller), wide gamut images will still report [ColorSpace.sRGB] if
/// rendering wide gamut colors isn't supported.   À!Óƒ&À#Óæ/// Release this handle's claim on the underlying Image. This handle is no
/// longer usable after this method is called.
///
/// Once all outstanding handles have been disposed, the underlying image will
/// be disposed as well.
///
/// In debug mode, [debugGetOpenHandleStackTraces] will return a list of
/// [StackTrace] objects from all open handles' creation points. This is
/// useful when trying to determine what parts of the program are keeping an
/// image resident in memory.   À&–ƒÊÀ)ÁÍ/// Converts the [Image] object into a byte array.
///
/// The [format] argument specifies the format in which the bytes will be
/// returned.
///
/// Using [ImageByteFormat.rawRgba] on an image in the color space
/// [ColorSpace.extendedSRGB] will result in the gamut being squished to fit
/// into the sRGB gamut, resulting in the loss of wide-gamut colors.
///
/// Returns a future that completes with the binary image data or an error
/// if encoding fails. À)Í0À)Ş  À)æÀ)õÀ)öÀ-ø¢À.Ã€°/// If asserts are enabled, returns the [StackTrace]s of each open handle from
/// [clone], in creation order.
///
/// If asserts are disabled, this method always returns null.   À/ŒàÀ:ßŠ¢/// Creates a disposable handle to this image.
///
/// Holders of an [Image] must dispose of the image when they no longer need
/// to access it or draw it. However, once the underlying image is disposed,
/// it is no longer possible to use it. If a holder of an image needs to share
/// access to that image with another object or method, [clone] creates a
/// duplicate handle. The underlying image will only be disposed once all
/// outstanding handles are disposed. This allows for safe sharing of image
/// references while still disposing of the underlying resources when all
/// consumers are finished.
///
/// It is safe to pass an [Image] handle to another object or method if the
/// current holder no longer needs it.
///
/// To check whether two [Image] references are referring to the same
/// underlying image memory, use [isCloneOf] rather than the equality operator
/// or [identical].
///
/// The following example demonstrates valid usage.
///
/// ```dart
/// import 'dart:async';
/// import 'dart:typed_data';
/// import 'dart:ui';
///
/// Future<Image> _loadImage(int width, int height) {
///   final Completer<Image> completer = Completer<Image>();
///   decodeImageFromPixels(
///     Uint8List.fromList(List<int>.filled(width * height * 4, 0xFF)),
///     width,
///     height,
///     PixelFormat.rgba8888,
///     // Don't worry about disposing or cloning this image - responsibility
///     // is transferred to the caller, and that is safe since this method
///     // will not touch it again.
///     (Image image) => completer.complete(image),
///   );
///   return completer.future;
/// }
///
/// Future<void> main() async {
///   final Image image = await _loadImage(5, 5);
///   // Make sure to clone the image, because MyHolder might dispose it
///   // and we need to access it again.
///   final MyImageHolder holder = MyImageHolder(image.clone());
///   final MyImageHolder holder2 = MyImageHolder(image.clone());
///   // Now we dispose it because we won't need it again.
///   image.dispose();
///
///   final PictureRecorder recorder = PictureRecorder();
///   final Canvas canvas = Canvas(recorder);
///
///   holder.draw(canvas);
///   holder.dispose();
///
///   canvas.translate(50, 50);
///   holder2.draw(canvas);
///   holder2.dispose();
/// }
///
/// class MyImageHolder {
///   MyImageHolder(this.image);
///
///   final Image image;
///
///   void draw(Canvas canvas) {
///     canvas.drawImage(image, Offset.zero, Paint());
///   }
///
///   void dispose() => image.dispose();
/// }
/// ```
///
/// The returned object behaves identically to this image. Calling
/// [dispose] on it will only dispose the underlying native resources if it
/// is the last remaining handle.   À<‚‚›À>ì‚R/// Returns true if `other` is a [clone] of this and thus shares the same
/// underlying image memory, even if this or `other` is [dispose]d.
///
/// This method may return false for two images that were decoded from the
/// same underlying asset, if they are not sharing the same memory. For
/// example, if the same file is decoded using [instantiateImageCodec] twice,
/// or the same bytes are decoded using [decodeImageFromPixels] twice, there
/// will be two distinct [Image]s that render the same but do not share
/// underlying memory, and so will not be treated as clones of each other. À>öÀ>ı   À?!3À?4   À?!À?" À?X‡ØÀ?}  À@‚'À@¤À@¥À@¦  À@‚À@ƒÀ@‰À@šÀ@ŠÀDÀD ÀD%ÀFe%ÀFv ÀFˆÀF‰ÀFÀF‡ÀF‚À@­fÀA   À@­À@®À@´À@ÒÀ@»À@µÀ@ÃÀ@ÑÀ@ÄÀ@ËÀ@ĞÀ@ÌÀ@ÓÀ@øÀ@ÚÀ@ÔÀ@ÜÀ@òÀ@ìÀ@ôÀAhÀAx   ÀAÀAÀAÀA<ÀA%ÀAÀA-ÀA;ÀA.ÀA5ÀA:ÀA6ÀA=ÀAcÀADÀA>ÀAFÀA]ÀAWÀA_ÀFbÀFæ   ÀFÀFÀF–ÀF´ÀFÀF—ÀF¥ÀF³ÀF¦ÀF­ÀF²ÀF®ÀFµÀFÑÀF¼ÀF¶ÀF¾ÀAƒ¡ÀA•  ÀA¡0ÀA²  ÀAºÀAÉÀAÊÀC(€èÀCË9/// Returns an error message on failure, null on success. ÀC×
ÀCÜ  ÀCã+ÀD  ÀCdÀCeÀCkÀC™ÀCsÀClÀC{ÀC˜ÀC|ÀCƒÀCˆÀC„ÀC‹ÀC’ÀCšÀC¶ÀC¡ÀC›ÀC£ÀD.dÀD3    ÀE–€ËÀFVk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  ÀFÀFÀFÀF*ÀFÀFÀFÀF)ÀFÀF#ÀF(ÀF$ÀF+ÀFDÀF2ÀF,ÀF4ÀFõ9ÀG   ÀFõÀFöÀ?XÀ?YÀ?_À?pÀ?`ÀH‰_ÀNä†Ê/// Information for a single frame of an animation.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].
///
/// The recipient of an instance of this class is responsible for calling
/// [Image.dispose] on [image]. To share the image with other interested
/// parties, use [Image.clone]. If the [FrameInfo] object itself is passed to
/// another method or object, that method or object must assume it is
/// responsible for disposing the image when done, and the passer must not
/// access the [image] after that point.
///
/// For example, the following code sample is incorrect:
///
/// ```dart
/// /// BAD
/// Future<void> nextFrameRoutine(ui.Codec codec) async {
///   final ui.FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo);
///   // ERROR - _cacheImage is now responsible for disposing the image, and
///   // the image may not be available any more for this drawing routine.
///   _drawImage(frameInfo);
///   // ERROR again - the previous methods might or might not have created
///   // handles to the image.
///   frameInfo.image.dispose();
/// }
/// ```
///
/// Correct usage is:
///
/// ```dart
/// /// GOOD
/// Future<void> nextFrameRoutine(ui.Codec codec) async {
///   final ui.FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo.image.clone(), frameInfo.duration);
///   _drawImage(frameInfo.image.clone(), frameInfo.duration);
///   // This method is done with its handle, and has passed handles to its
///   // clients already.
///   // The image will live until those clients dispose of their handles, and
///   // this one must not be disposed since it will not be used again.
///   frameInfo.image.dispose();
/// }
/// ``` ÀNòÀOÁÀOÂÀOÃ€»/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].ÀOÅÀOÔ  ÀOİÀOì   ÀO÷€™ÀPˆ{/// The duration this frame should be shown.
///
/// A zero duration indicates that the frame should be shown indefinitely. ÀP•€ÚÀQj€¾/// The [Image] object for this frame.
///
/// This object must be disposed by the recipient of this frame info.
///
/// To share this image with other interested parties, use [Image.clone].    ÀQt„>ÀRb€Ş/// A handle to an image codec.
///
/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [Codec] interface, see
/// [instantiateImageCodec].   ÀRl9ÀRš#/// Number of frames in this image.   ÀR©€¦ÀS?€…/// Number of times to repeat the animation.
///
/// * 0 when the animation should be played once.
/// * -1 for infinity repetitions.   ÀSSaÀT¥//// Fetches the next animation frame.
///
/// Wraps back to the first frame after returning the last frame.
///
/// The returned future can complete with an error if the decoding has failed.
///
/// The caller of this method is responsible for disposing the
/// [FrameInfo.image] on the returned object.   ÀT¸€øÀU¦€Ş/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).    ÀU´‡£ÀU¿  ÀVÇÀVÓÀVÔÀVÕ   ÀVÜÀVá  ÀW´ÀW¹  ÀV÷DÀW   ÀV÷ÀVøÀW?qÀW¤   ÀW?ÀW@ÀWFÀWdÀWMÀWGÀWUÀWcÀWVÀW]ÀWbÀW^ÀWeÀWÀWlÀWfÀWnÀW‰ÀWƒÀW‹ÀWÔSÀWè   ÀWÔÀWÕÀX+{ÀX•   ÀX+ÀX,ÀX2ÀXPÀX9ÀX3ÀXAÀXOÀXBÀXIÀXNÀXJÀXQÀX€ÀXXÀXRÀXZÀXzÀXtÀX|ÀXª‚õÀXÈ   ÀXªÀX«À[£€ÚÀ\A9/// Returns an error message on failure, null on success. À\O,À\t  À[ßÀ[àÀ[æÀ\À[îÀ[çÀ[öÀ\À[÷À[şÀ\À[ÿÀ\À\À\,À\À\À\À\fÀ\İ   À\À\‚À\À\À\”À\±À\šÀ\•À\¢À\°À\£À\ªÀ\¯À\«À\²À\ËÀ\¹À\³À\»À\ëjÀ\ş   À\ëÀ\ì À|†jÀ}±/// A specification of the size to which an image should be decoded.
///
/// See also:
///
///  * [TargetImageSizeCallback], a callback that returns instances of this
///    class when consulted by image decoding methods such as
///    [instantiateImageCodecWithSize]. À}Å# À~dÀ~s€/// Creates a new instance of this class.
///
/// The `width` and `height` may both be null, but if they're non-null, they
/// must be positive.À~u
À~{  À~À~‡  À~—À~À~¸À~¬À~¤À~À~§À~µÀ~¯À~·À~ÃÀ~ÉÀ~æÀ~ÙÀ~ÑÀ~ÊÀ~ÔÀ~ãÀ~ÜÀ~åÀ~ìåÀ€ÌÂ/// The width into which to load the image.
///
/// If this is non-null, the image will be decoded into the specified width.
/// If this is null and [height] is also null, the image will be decoded into
/// its intrinsic size. If this is null and [height] is non-null, the image
/// will be decoded into a width that maintains its intrinsic aspect ratio
/// while respecting the [height] value.
///
/// If this value is non-null, it must be positive. À€ÖæÀ‚¶Â/// The height into which to load the image.
///
/// If this is non-null, the image will be decoded into the specified height.
/// If this is null and [width] is also null, the image will be decoded into
/// its intrinsic size. If this is null and [width] is non-null, the image
/// will be decoded into a height that maintains its intrinsic aspect ratio
/// while respecting the [width] value.
///
/// If this value is non-null, it must be positive.  À‚ÁEÀ‚Ô   À‚ÁÀ‚Â Àœ«ƒ˜ÀP/// A handle for the framework to hold and retain an engine layer across frames.    Àƒ&À 7‚ø/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// EngineLayers indirectly retain platform specific graphics resources. Some
/// of these resources, such as images, may be memory intensive. It is
/// important to dispose of EngineLayer objects that will no longer be used as
/// soon as possible to avoid retaining these resources until the next
/// garbage collection.
///
/// Once this EngineLayer is disposed, it is no longer eligible for use as a
/// retained layer, and must not be passed as an `oldLayer` to any of the
/// [SceneBuilder] methods which accept that parameter.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).    À EIÀ P  À Ÿ}À¡À¡À¡a/// This class is created by the engine, and should not be instantiated
/// or extended directly.    À¡ lÀ¡‚   À¡ À¡!À¡,À¡-À¡3À¡PÀ¡9À¡4À¡AÀ¡OÀ¡BÀ¡IÀ¡NÀ¡JÀ¡QÀ¡pÀ¡XÀ¡RÀ¡Z À¡¸éÀ¤X‚¸/// A complex, one-dimensional subset of a plane.
///
/// A path consists of a number of sub-paths, and a _current point_.
///
/// Sub-paths consist of segments of various types, such as lines,
/// arcs, or beziers. Sub-paths can be open or closed, and can
/// self-intersect.
///
/// Closed sub-paths enclose a (possibly discontiguous) region of the
/// plane based on the current [fillType].
///
/// The _current point_ is initially at the origin. After each
/// operation adding a segment to a sub-path, the current point is
/// updated to the end of that segment.
///
/// Paths can be drawn on canvases using [Canvas.drawPath], and can
/// used to create clip regions using [Canvas.clipPath]. À¤ò À¤úÀ¤ş   À¥iÀ¥éÀ¥êÀ¥î€Á/// Creates a copy of another [Path].
///
/// This copy is fast and does not require additional memory unless either
/// the `source` path or the path returned by this constructor are modified.À¥ïÀ¥õ    À¦€€£À§€‚/// Determines how the interior of this path is calculated.
///
/// Defaults to the non-zero winding rule, [PathFillType.nonZero].   À§&!À§*  À§3À§A   À§KUÀ§…2/// Starts a new sub-path at the given coordinate. À§ŒÀ§”  À§–À§   À§¤rÀ§ñE/// Starts a new sub-path at the given offset from the current point. À¨ 	À¨  À¨	À¨   À¨tÀ¨sO/// Adds a straight line segment from the current point to the given
/// point. À¨zÀ¨‚  À¨„À¨Œ   À¨’€£À©t/// Adds a straight line segment from the current point to the point
/// at the given offset from the current point. À©	À©'  À©*	À©2   À©9ÁÀª¼q/// Adds a quadratic bezier segment that curves from the current
/// point to the given point (x2,y2), using the control point
/// (x1,y1).
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_quadratic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_quadratic_to_dark.png#gh-dark-mode-only) ÀªÎ	ÀªÖ  ÀªÙ	Àªá  Àªä	Àªì  Àªï	Àª÷   Àªş'À«ß€Ó/// Adds a quadratic bezier segment that curves from the current
/// point to the point at the offset (x2,y2) from the current point,
/// using the control point at the offset (x1,y1) from the current
/// point. À«ù	À¬  À¬	À¬  À¬	À¬  À¬	À¬"   À¬)ÎÀ­­r/// Adds a cubic bezier segment that curves from the current point
/// to the given point (x3,y3), using the control points (x1,y1) and
/// (x2,y2).
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_cubic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_cubic_to_dark.png#gh-dark-mode-only) À­µ	À­½  À­À	À­È  À­Ë	À­Ó  À­Ö	À­Ş  À­á	À­é  À­ì	À­ô   À­û=À®æ€İ/// Adds a cubic bezier segment that curves from the current point
/// to the point at the offset (x3,y3) from the current point, using
/// the control points at the offsets (x1,y1) and (x2,y2) from the
/// current point. À®ö	À®ş  À¯	À¯	  À¯	À¯  À¯	À¯  À¯"	À¯*  À¯-	À¯5   À¯<‚bÀ±`‚/// Adds a bezier segment that curves from the current point to the
/// given point (x2,y2), using the control points (x1,y1) and the
/// weight w. If the weight is greater than 1, then the curve is a
/// hyperbola; if the weight equals 1, it's a parabola; and if it is
/// less than 1, it is an ellipse.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_conic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_conic_to_dark.png#gh-dark-mode-only) À±h	À±p  À±s	À±{  À±~	À±†  À±‰	À±‘  À±”À±œ   À±¢ÏÀ³+w/// Adds a bezier segment that curves from the current point to the
/// point at the offset (x2,y2) from the current point, using the
/// control point at the offset (x1,y1) from the current point and
/// the weight w. If the weight is greater than 1, then the curve is
/// a hyperbola; if the weight equals 1, it's a parabola; and if it
/// is less than 1, it is an ellipse. À³;	À³C  À³F	À³N  À³Q	À³Y  À³\	À³d  À³gÀ³o   À³uƒrÀ¶ƒ/// If the `forceMoveTo` argument is false, adds a straight line
/// segment and an arc segment.
///
/// If the `forceMoveTo` argument is true, starts a new sub-path
/// consisting of an arc segment.
///
/// In either case, the arc segment consists of the arc that follows
/// the edge of the oval bounded by the given rectangle, from
/// startAngle radians around the oval up to startAngle + sweepAngle
/// radians around the oval, with zero radians being the point on
/// the right hand side of the oval that crosses the horizontal line
/// that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval.
///
/// The line segment added if `forceMoveTo` is false starts at the
/// current point and ends at the start of the arc. À¶¤	À¶ª  À¶¯À¶·  À¶ÂÀ¶Ê  À¶ÕÀ¶Û   À¶ëƒ!À¹y‚p/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEnd`. The curves follow a path in a direction determined by
/// `clockwise` and `largeArc` in such a way that the sweep angle
/// is always less than 360 degrees.
///
/// A simple line is appended if either radii are zero or the last
/// point in the path is `arcEnd`. The radii are scaled to fit the last path
/// point if both are greater than zero but too small to describe an arc.
/// À¹„À¹Œ  À¹™À¹¡  À¹ºÀ¹Â  À¹ÕÀ¹Û  À¹ğÀ¹ö  À¹©À¹¯À¹°À¹ÌÀ¹åÀºÀºƒ£À½‚Ü/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The last path point is described by (px, py).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEndDelta.dx + px` and `arcEndDelta.dy + py`. The curves follow a
/// path in a direction determined by `clockwise` and `largeArc`
/// in such a way that the sweep angle is always less than 360 degrees.
///
/// A simple line is appended if either radii are zero, or, both
/// `arcEndDelta.dx` and `arcEndDelta.dy` are zero. The radii are scaled to
/// fit the last path point if both are greater than zero but too small to
/// describe an arc. À½&À½.  À½@À½H  À½aÀ½i  À½|À½‚  À½—À½  À½PÀ½VÀ½WÀ½sÀ½ŒÀ½¨À½·vÀ¾Y/// Adds a new sub-path that consists of four lines that outline the
/// given rectangle. À¾"	À¾(   À¾1.À¿L/// Adds a new sub-path that consists of a curve that forms the
/// ellipse that fills the given rectangle.
///
/// To add a circle, pass an appropriate rectangle as `oval`. [Rect.fromCircle]
/// can be used to easily describe the circle's center [Offset] and radius. À¿T	À¿Z   À¿cƒèÀÃƒ/// Adds a new sub-path with one arc segment that consists of the arc
/// that follows the edge of the oval bounded by the given
/// rectangle, from startAngle radians around the oval up to
/// startAngle + sweepAngle radians around the oval, with zero
/// radians being the point on the right hand side of the oval that
/// crosses the horizontal line that intersects the center of the
/// rectangle and with positive angles going clockwise around the
/// oval.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_dark.png#gh-dark-mode-only)
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_ccw.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_ccw_dark.png#gh-dark-mode-only) ÀÃ	ÀÃ   ÀÃ%ÀÃ-  ÀÃ8ÀÃ@   ÀÃOXÀÄ{/// Adds a new sub-path with a sequence of line segments that connect the given
/// points.
///
/// If `close` is true, a final line segment will be added that connects the
/// last point to the first point.
///
/// The `points` argument is interpreted as offsets from the origin. ÀÄ†ÀÄ”  ÀÄ›
ÀÄ¡   ÀÄ«€°ÀÅE€/// Adds a new sub-path that consists of the straight lines and
/// curves needed to form the rounded rectangle described by the
/// argument. ÀÅNÀÅU   ÀÅ_QÀÆv/// Adds the sub-paths of `path`, offset by `offset`, to this path.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given offset. The matrix is a 4x4
/// matrix stored in column major order. ÀÆ~	ÀÆ„  ÀÆ‰ÀÆ‘  ÀÆ™ÀÆ§   ÀÆ´×ÀÈJ‚/// Adds the sub-paths of `path`, offset by `offset`, to this path.
/// The current sub-path is extended with the first sub-path
/// of `path`, connecting them with a lineTo if necessary.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given `offset`.  The matrix is a 4x4
/// matrix stored in column major order. ÀÈY	ÀÈ_  ÀÈdÀÈl  ÀÈtÀÈ‚   ÀÈ€“ÀÉ€/// Closes the last sub-path, as if a straight line had been drawn
/// from the current point to the first point of the sub-path.   ÀÉ&€±ÀÉÏ€/// Clears the [Path] object of all sub-paths, returning it to the
/// same state it had when it was created. The _current point_ is
/// reset to the origin.   ÀÉÛqÀË5F/// Tests to see if the given point is within the path. (That is, whether the
/// point would be in the visible portion of the path if the path was used
/// with [Canvas.clipPath].)
///
/// The `point` argument is interpreted as an offset from the origin.
///
/// Returns true if the point is in the path, and false otherwise. ÀË>ÀËF   ÀËP€‰ÀËÄj/// Returns a copy of the path with all the segments of every
/// sub-path translated by the given offset. ÀËÊÀËÒ   ÀËİ€”ÀÌRk/// Returns a copy of the path with all the segments of every
/// sub-path transformed by the given matrix. ÀÌ\ÀÌi   ÀÌuƒ£ÀĞƒ0/// Computes the bounding rectangle for this path.
///
/// A path containing only axis-aligned points on the same straight line will
/// have no area, and therefore `Rect.isEmpty` will return true for such a
/// path. Consider checking `rect.width + rect.height > 0.0` instead, or
/// using the [computeMetrics] API to check the path length.
///
/// For many more elaborate paths, the bounds may be inaccurate.  For example,
/// when a path contains a circle, the points used to compute the bounds are
/// the circle's implied control points, which form a square around the circle;
/// if the circle has a transformation applied using [transform] then that
/// square is rotated, and the (axis-aligned, non-rotated) bounding box
/// therefore ends up grossly overestimating the actual area covered by the
/// circle.   ÀĞ‚”ÀÑe0/// Combines the two paths according to the manner specified by the given
/// `operation`.
///
/// The resulting path will be constructed from non-overlapping contours. The
/// curve order is reduced where possible so that cubics may be turned into
/// quadratics, and quadratics maybe turned into lines. ÀÑmÀÑ|  ÀÑ†
ÀÑŒ  ÀÑ’
ÀÑ˜   ÀÒ´‡ÃÀÚL‡M/// Creates a [PathMetrics] object for this path, which can describe various
/// properties about the contours of the path.
///
/// A [Path] is made up of zero or more contours. A contour is made up of
/// connected curves and segments, created via methods like [lineTo],
/// [cubicTo], [arcTo], [quadraticBezierTo], their relative counterparts, as
/// well as the add* methods such as [addRect]. Creating a new [Path] starts
/// a new contour once it has any drawing instructions, and another new
/// contour is started for each [moveTo] instruction.
///
/// A [PathMetric] object describes properties of an individual contour,
/// such as its length, whether it is closed, what the tangent vector of a
/// particular offset along the path is. It also provides a method for
/// creating sub-paths: [PathMetric.extractPath].
///
/// Calculating [PathMetric] objects is not trivial. The [PathMetrics] object
/// returned by this method is a lazy [Iterable], meaning it only performs
/// calculations when the iterator is moved to the next [PathMetric]. Callers
/// that wish to memoize this iterable can easily do so by using
/// [Iterable.toList] on the result of this method. In particular, callers
/// looking for information about how many contours are in the path should
/// either store the result of `path.computeMetrics().length`, or should use
/// `path.computeMetrics().toList()` so they can repeatedly check the length,
/// since calling `Iterable.length` causes traversal of the entire iterable.
///
/// In particular, callers should be aware that [PathMetrics.length] is the
/// number of contours, **not the length of the path**. To get the length of
/// a contour in a path, use [PathMetric.length].
///
/// If `forceClosed` is set to true, the contours of the path will be measured
/// as if they had been closed, even if they were not explicitly closed. ÀÚ\ÀÚb  ÀÚo ÀÚ{¥qÀÚ†  ÀÚÇI ÀÚïÀÚú%/// Create a new empty [Path] object.  ÀÛ€£ÀÛ²ÀÛ³ÀÛ´€/// Avoids creating a new native backing for the path for methods that will
/// create it later, such as [Path.from], [shift] and [transform].   ÀÜƒMÀÜ    ÀÜƒÀÜ„ÀÜÓJÀÜã  ÀÜìÀÜú  ÀÜÓÀÜÔ1ÀÛ»VÀÜ   ÀÛ»ÀÛ¼ÀÛÂÀÛØÀÛÈÀÛÃÀÛĞÀÛ×ÀÛÑÀÛÙÀÛğÀÛàÀÛÚÀÛâÀÜjÀÜj  ÀÜqÀÜw  ÀÜÀÜÀÜÀÜAÀÜ"ÀÜÀÜ*ÀÜ@ÀÜ+ÀÜ2ÀÜ7ÀÜ3ÀÜ:ÀÜBÀÜXÀÜIÀÜCÀÜKÀİ!pÀİ‚   Àİ!Àİ"Àİ(ÀİFÀİ/Àİ)Àİ7ÀİEÀİ8Àİ?ÀİDÀİ@ÀİGÀİqÀİNÀİHÀİPÀİkÀİeÀİmÀİ•€ƒÀİı  ÀŞ
ÀŞ  Àİ•Àİ–ÀİœÀİÀÀİ¢ÀİÀİªÀİ¿Àİ«Àİ²Àİ·Àİ³ÀİºÀİÁÀİëÀİÈÀİÂÀİÊÀİåÀİßÀİçÀŞ€“ÀŞ”  ÀŞ›ÀŞ£  ÀŞ¥ÀŞ­  ÀŞÀŞÀŞ(ÀŞ)ÀŞ/ÀŞ\ÀŞ5ÀŞ0ÀŞ=ÀŞ[ÀŞ>ÀŞEÀŞJÀŞFÀŞMÀŞUÀŞ]ÀŞ‚ÀŞdÀŞ^ÀŞfÀŞ|ÀŞvÀŞ~ÀŞ³€¥Àß3  ÀßB	ÀßJ  ÀßM	ÀßU  ÀŞ³ÀŞ´ÀŞ¿ÀŞÀÀŞÆÀŞóÀŞÌÀŞÇÀŞÔÀŞòÀŞÕÀŞÜÀŞáÀŞİÀŞäÀŞìÀŞôÀß!ÀŞûÀŞõÀŞıÀßÀßÀßÀß\€“ÀßÔ  ÀßÛÀßã  ÀßåÀßí  Àß\Àß]ÀßhÀßiÀßoÀßœÀßuÀßpÀß}Àß›Àß~Àß…ÀßŠÀß†ÀßÀß•ÀßÀßÂÀß¤ÀßÀß¦Àß¼Àß¶Àß¾Àßó€¥Ààs  Àà‚	ÀàŠ  Àà	Àà•  ÀßóÀßôÀßÿÀà ÀàÀà3ÀàÀàÀàÀà2ÀàÀàÀà!ÀàÀà$Àà,Àà4ÀàaÀà;Àà5Àà=Àà[ÀàUÀà]Ààœ€ÑÀá/  ÀáA	ÀáI  ÀáL	ÀáT  ÀáW	Àá_  Àáb	Àáj  ÀàœÀàÀà¨Àà©Àà¯ÀàìÀàµÀà°Àà½ÀàëÀà¾ÀàÅÀàÊÀàÆÀàÍÀàÕÀàİÀàåÀàíÀáÀàôÀàîÀàöÀáÀáÀáÀáq€èÀâ  Àâ-	Àâ5  Àâ8	Àâ@  ÀâC	ÀâK  ÀâN	ÀâV  ÀáqÀárÀá}Àá~Àá„ÀáÁÀáŠÀá…Àá’ÀáÀÀá“ÀášÀáŸÀá›Àá¢ÀáªÀá²ÀáºÀáÂÀáúÀáÉÀáÃÀáËÀáôÀáîÀáöÀâ]€ãÀâö  Àâş	Àã  Àã		Àã  Àã	Àã  Àã	Àã'  Àã*	Àã2  Àã5	Àã=  Àâ]Àâ^ÀâiÀâjÀâpÀâ½ÀâvÀâqÀâ~Àâ¼ÀâÀâ†Àâ‹Àâ‡ÀâÀâ–ÀâÀâ¦Àâ®Àâ¶Àâ¾ÀâäÀâÅÀâ¿ÀâÇÀâŞÀâØÀâàÀãD€óÀãå  Àãõ	Àãı  Àä 	Àä  Àä	Àä  Àä	Àä  Àä!	Àä)  Àä,	Àä4  ÀãDÀãEÀãPÀãQÀãWÀã¤Àã]ÀãXÀãeÀã£ÀãfÀãmÀãrÀãnÀãuÀã}Àã…ÀãÀã•ÀãÀã¥ÀãÓÀã¬Àã¦Àã®ÀãÍÀãÇÀãÏÀä;€ÏÀäÌ  ÀäÔ	ÀäÜ  Àäß	Àäç  Àäê	Àäò  Àäõ	Àäı  Àå Àå  Àä;Àä<ÀäGÀäHÀäNÀä“ÀäTÀäOÀä\Àä’Àä]ÀädÀäiÀäeÀälÀätÀä|Àä„ÀäŒÀä”ÀäºÀä›Àä•ÀäÀä´Àä®Àä¶Àå€ßÀå§  Àå·	Àå¿  ÀåÂ	ÀåÊ  ÀåÍ	ÀåÕ  ÀåØ	Àåà  ÀåãÀåë  ÀåÀåÀåÀåÀå!ÀåfÀå'Àå"Àå/ÀåeÀå0Àå7Àå<Àå8Àå?ÀåGÀåOÀåWÀå_ÀågÀå•ÀånÀåhÀåpÀåÀå‰Àå‘Àåñ€ŞÀæ  Àæ	Àæ  ÀæÀæ  Àæ&Àæ.  Àæ9Àæ?  ÀåñÀåòÀæÓÀçd  ÀçkÀçs  Àçx
Àç€  Àç„ÀçŒ  Àç’Àçš  Àç¡Àç©  Àç´Àç¼  ÀçÇÀçÍ  ÀæÓÀæÔÀæÚÀç-ÀæàÀæÛÀæèÀç,ÀæéÀæğÀæõÀæñÀæøÀç ÀçÀçÀçÀç Àç(Àç.ÀçRÀç5Àç/Àç7ÀçLÀçFÀçNÀçİKÀçî  ÀçùÀè  ÀèÀè  Àè/Àè7  ÀèJÀèP  ÀèeÀèk  ÀçİÀçŞÀèÀè$Àè%ÀèAÀèZÀèvÀé,ÀéÀ  ÀéÌÀéÔ  ÀéÜÀéä  ÀéìÀéô  ÀéüÀê  ÀêÀê  ÀêÀê#  Àê,Àê2  Àé,Àé-Àé3Àé„Àé9Àé4ÀéAÀéƒÀéBÀéIÀéNÀéJÀéQÀéYÀéaÀéiÀéqÀéyÀéÀé…Àé®ÀéŒÀé†ÀéÀé¨Àé¢ÀéªÀê@tÀêQ  ÀêiÀêq  ÀêƒÀê‹  Àê¤Àê¬  Àê¿ÀêÅ  ÀêÚÀêà  Àê@ÀêAÀê“Àê™ÀêšÀê¶ÀêÏÀêëÀë¸KÀìT  ÀìoÀìw  Àì…Àì  Àì›Àì£  Àì±Àì¹  ÀìÇÀìÏ  ÀìŞÀìä  ÀìóÀìù  Àë¸Àë¹Àë¿ÀìÀëÅÀëÀÀëÍÀìÀëÎÀëÕÀëÚÀëÖÀëİÀëåÀëíÀëõÀëıÀìÀìÀìÀìBÀìÀìÀìÀì<Àì6Àì>Àí€…Àí  Àí 	Àí&  ÀíÀíÀí€¼Àî  ÀîÀî  Àî#
Àî+  Àî/Àî7  Àî=ÀîE  ÀíÀí‘Àí—ÀíÔÀíÀí˜Àí¥ÀíÓÀí¦Àí­Àí²Àí®ÀíµÀí½ÀíÅÀíÍÀíÕÀíûÀíÜÀíÖÀíŞÀíõÀíïÀí÷ÀîP€…Àîa  Àîi	Àîo  ÀîPÀîQÀîÙ€¼ÀïV  Àï_Àïg  Àïl
Àït  ÀïxÀï€  Àï†Àï  ÀîÙÀîÚÀîàÀïÀîæÀîáÀîîÀïÀîïÀîöÀîûÀî÷ÀîşÀïÀïÀïÀïÀïDÀï%ÀïÀï'Àï>Àï8Àï@Àï™€ÁÀïª  Àï±	Àï·  Àï¼ÀïÄ  ÀïÏÀï×  Àï™ÀïšÀğ^€ğÀğê  ÀğòÀğú  Àğÿ
Àñ  ÀñÀñ  ÀñÀñ!  Àñ(Àñ0  Àñ;ÀñC  Àğ^Àğ_ÀğeÀğ²ÀğkÀğfÀğsÀğ±ÀğtÀğ{Àğ€Àğ|ÀğƒÀğ‹Àğ“Àğ›Àğ£Àğ«Àğ³ÀğØÀğºÀğ´Àğ¼ÀğÒÀğÌÀğÔÀñRtÀñc  ÀñnÀñ|  Àñƒ
Àñ‰  ÀñRÀñSÀñÊ€ŒÀò*  Àò6ÀòC  ÀòJ
ÀòP  ÀñÊÀñËÀñÑÀñüÀñ×ÀñÒÀñßÀñûÀñàÀñçÀñìÀñèÀñïÀñ÷ÀñıÀòÀòÀñşÀòÀòZrÀòk  ÀòtÀò{  ÀòZÀò[ÀòĞuÀó(  Àó2Àó?  ÀòĞÀòÑÀò×ÀòüÀòİÀòØÀòåÀòûÀòæÀòíÀòòÀòîÀòõÀòıÀóÀóÀòşÀóÀóISÀóZ  Àób	Àóh  ÀómÀóu  Àó}Àó‹  ÀóIÀóJÀô €ŸÀõ  ÀõÀõ$  Àõ)	Àõ1  Àõ4	Àõ<  Àô Àô¡Àô§ÀôãÀô­Àô¨ÀôµÀôâÀô¶Àô½ÀôÂÀô¾ÀôÅÀôÌÀôÑÀôÍÀôÔÀôÜÀôäÀôüÀôëÀôåÀôíÀõC€ÏÀõÃ  ÀõÖÀõã  Àõè	Àõğ  Àõó	Àõû  ÀõşÀö  ÀõCÀõDÀõJÀõÀõPÀõKÀõXÀõÀõYÀõ`ÀõeÀõaÀõhÀõoÀõtÀõpÀõwÀõÀõ‡ÀõÀõ±Àõ–ÀõÀõ˜ÀögÀö'  Àö6	Àö<  ÀöAÀöI  ÀöQÀö_  ÀöÀöÀ÷€­À÷ö  ÀøÀø  Àø	Àø   Àø#	Àø+  À÷À÷‚À÷ˆÀ÷ÄÀ÷À÷‰À÷–À÷ÃÀ÷—À÷À÷£À÷ŸÀ÷¦À÷­À÷²À÷®À÷µÀ÷½À÷ÅÀ÷äÀ÷ÌÀ÷ÆÀ÷ÎÀø2€ÛÀø¸  ÀøÑÀøŞ  Àøã	Àøë  Àøî	Àøö  ÀøùÀù  Àø2Àø3Àø9Àø}Àø?Àø:ÀøGÀø|ÀøHÀøOÀøTÀøPÀøWÀø^ÀøcÀø_ÀøfÀønÀøvÀø~Àø¦Àø…ÀøÀø‡ÀùoÀùx   ÀùÀùÀùÀùÀù$ÀùAÀù*Àù%Àù2Àù@Àù3Àù:Àù?Àù;ÀùBÀùfÀùIÀùCÀùKÀù`ÀùZÀùbÀù„oÀùë   Àù„Àù…ÀùÀù‘Àù—Àù´ÀùÀù˜Àù¥Àù³Àù¦Àù­Àù²Àù®ÀùµÀùÙÀù¼Àù¶Àù¾ÀùÓÀùÍÀùÕÀù÷zÀú  ÀúÀú  Àù÷ÀùøÀúu€ŒÀúã  ÀúíÀúõ  Àú÷Àúÿ  ÀúuÀúvÀú|Àú©Àú‚Àú}ÀúŠÀú¨Àú‹Àú’Àú—Àú“ÀúšÀú¢ÀúªÀúÑÀú±Àú«Àú³ÀúËÀúÅÀúÍÀû€¶Àû  ÀûÀû$  ÀûÀûÀû¿€Àü$  Àü+Àü1  Àü9	ÀüA  ÀüD	ÀüL  Àû¿ÀûÀÀûÆÀûûÀûÌÀûÇÀûÔÀûúÀûÕÀûÜÀûáÀûİÀûäÀûìÀûôÀûüÀüÀüÀûıÀüÀüS€¹Àüd  ÀünÀü{  ÀüSÀüTÀı€Àıq  Àı|Àı‚  ÀıŠÀı—  ÀıÀıÀıÀıDÀıÀıÀı%ÀıCÀı&Àı-Àı2Àı.Àı5Àı=ÀıEÀı_ÀıLÀıFÀıNÀı£€‹Àı´   Àı£Àı¤Àş2gÀşŒ   Àş2Àş3Àş9ÀşXÀşAÀş:ÀşIÀşWÀşJÀşQÀşVÀşRÀşYÀşsÀş`ÀşZÀşbÀş€¨Àÿ  ÀÿÀÿ  Àÿ#Àÿ0  Àÿ6Àÿ;  ÀşÀşÀş¤ÀşæÀşªÀş¥Àş²ÀşåÀş³ÀşºÀş¿Àş»ÀşÂÀşÉÀşÎÀşÊÀşÑÀşØÀşİÀşÙÀşàÀşçÀşúÀşîÀşèÀşğÀÿIuÀÿa  ÀÿqÀÿw  ÀÿIÀÿJÀÿ„ÀÿÂ(ÀÿÕ   ÀÿÂÀÿÃ Àÿî‡DÀ ¦€±/// The geometric description of a tangent: the angle at a point.
///
/// See also:
///  * [PathMetric.getTangentForOffset], which returns the tangent of an offset along a path. À ²€‡ ÀÀV/// Creates a [Tangent] with the given values.
///
/// The arguments must not be null.ÀÀ#  À,À2   À=RÀÀÀ"€Ã/// Creates a [Tangent] based on the angle rather than the vector.
///
/// The [vector] is computed to be the unit vector at the given angle, interpreted
/// as clockwise radians from the x axis.À#À+  À4À<   À“€ÑÀ\€³/// Position of the tangent.
///
/// When used with [PathMetric.getTangentForOffset], this represents the precise
/// position that the given offset along the path corresponds to. ÀiÀh€ç/// The vector of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the vector of the
/// curve that is at the given offset along the path (i.e. the direction of the
/// curve at [position]). Às‚½À‚+/// The direction of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the angle of the
/// curve that is the given offset along the path (i.e. the direction of the
/// curve at [position]).
///
/// This value is in radians, with 0.0 meaning pointing along the x axis in
/// the positive x-axis direction, positive numbers pointing downward toward
/// the negative y-axis, i.e. in a clockwise direction, and negative numbers
/// pointing upward toward the positive y-axis, i.e. in a counter-clockwise
/// direction.     À4„#À
/‚ô/// An iterable collection of [PathMetric] objects describing a [Path].
///
/// A [PathMetrics] object is created by using the [Path.computeMetrics] method,
/// and represents the path as it stood at the time of the call. Subsequent
/// modifications of the path do not affect the [PathMetrics] object.
///
/// Each path metric corresponds to a segment, or contour, of a path.
///
/// For example, a path consisting of a [Path.lineTo], a [Path.moveTo], and
/// another [Path.lineTo] will contain two contours and thus be represented by
/// two [PathMetric] objects.
///
/// This iterable does not memoize. Callers who need to traverse the list
/// multiple times, or who need to randomly access elements of the list, should
/// use [toList] on this object. À
k€‚À
vÀ
wÀ
x À
y	À
  À
„À
Š  À
¦À
œÀ
¨À
ºÀ
»À
¼À
ëÀ
½À
ÉÀ
êÀ
ÏÀ
ÊÀ
ÒÀ
ßÀ
ñ$À  À;À?   ÀÀ  ÀYƒÂÀÈh/// Used by [PathMetrics] to track iteration from one segment of a path to the
/// next for measurement. Àÿ(ÀÀÀ ÀÀ   À+À7  ÀFÀY  ÀjğÀ…   ÀjÀkÀ^€»Ào   À^À_ ÀkÀ‚à/// Utilities for measuring a [Path] and extracting sub-paths.
///
/// Iterate over the object returned by [Path.computeMetrics] to obtain
/// [PathMetric] objects. Callers that want to randomly access elements or
/// iterate multiple times should use `path.computeMetrics().toList()`, since
/// [PathMetrics] does not memoize.
///
/// Once created, the metrics are only valid for the path as it was specified
/// when [Path.computeMetrics] was called. If additional contours are added or
/// any contours are updated, the metrics need to be recomputed. Previously
/// created metrics will still refer to a snapshot of the path at the time they
/// were computed, rather than to the actual metrics for the new mutations to
/// the path. À€ÎÀÀÀ À À&  À<À5À>ÀFÀGÀMÀjÀNÀVÀWÀ|ÀsÀ~À†À‡ÀÀ¬ÀÀ˜À™ÀÂÀµÀÄÀÌÀÍÀå+À
/// Return the total length of the current contour.
///
/// The length may be calculated from an approximation of the geometry
/// originally added. For this reason, it is not recommended to rely on
/// this property for mathematically correct lengths of common shapes. ÀAÀN!/// Whether the contour is closed.
///
/// Returns true if the contour ends with a call to [Path.close] (which may
/// have been implied when using methods like [Path.addRect]) or if
/// `forceClosed` was specified as true in the call to [Path.computeMetrics].
/// Returns false otherwise. À[‚àÀ/‚±/// The zero-based index of the contour.
///
/// [Path] objects are made up of zero or more contours. The first contour is
/// created once a drawing command (e.g. [Path.lineTo]) is issued. A
/// [Path.moveTo] command after a drawing command may create a new contour,
/// although it may not if optimizations are applied that determine the move
/// command did not actually result in moving the pen.
///
/// This property is only valid with reference to its original iterator and
/// the contours of the path at the time the path's metrics were computed. If
/// additional contours were added or existing contours updated, this metric
/// will be invalid for the current state of the path. À@ÀS   À`‚,À!£/// Computes the position of the current contour at the given offset, and the
/// angle of the path at that point.
///
/// For example, calling this method with a distance of 1.41 for a line from
/// 0.0,0.0 to 2.0,2.0 would give a point 1.0,1.0 and the angle 45 degrees
/// (but in radians).
///
/// Returns null if the contour has zero [length].
///
/// The distance is clamped to the [length] of the current contour. À5À=   ÀÀj€Ì/// Given a start and end distance, return the intervening segment(s).
///
/// `start` and `end` are clamped to legal values (0..[length])
/// Begin the segment with a moveTo if `startWithMoveTo` is true. ÀvÀ~  À„
ÀŒ  À‘À—  À¨ÀqÀ(   ÀÀ ÀŠ‹À•  ÀÇ[ ÀÇÀÓ ÀÔÀá  ÀæÀì   À&ï€¯À'†€Œ/// The index of the current contour in the list of contours in the path.
///
/// [nextContour] will increment this to the zero based index.À'œÀ' À&€”À‰  À–À£  À¨À®  À&À'À-ÀXÀ3À.À;ÀWÀ<ÀDÀKÀPÀLÀSÀYÀwÀ`ÀZÀbÀ¾€½ÀÅ  ÀÌÀÑ   À€‹Àğ  ÀøÀı  ÀÀ€À†À¬ÀÀ‡À–À«À—ÀÀ£ÀŸÀ¦À­ÀÜÀ´À®À¶ÀÖÀĞÀØÀíÀ  À+À0  À=ÀE   À ÿ€À!o  À!zÀ!  À!ŒÀ!”  À ÿÀ! À!À!4À!À!À!À!3À!À!À!#À!À!&À!-À!5À!VÀ!<À!6À!>À!¡_À!¦  À!²À!·  À!ÄÀ!Ì  À!Ò
À!Ú  À!åÀ!ë  À!üÀ#€ÛÀ#‚  À#À#•  À#À#¢  À#¯À#·  À#½
À#Å  À#ÉÀ#Ï  À#À#À#À#MÀ#À#À#À#LÀ#À#!À#&À#"À#)À#1À#8À#@À#HÀ#NÀ#pÀ#UÀ#OÀ#WÀ#ã€¿À#è  À#ñÀ#ö   À$¦€ˆÀ%  À%À%!  À$¦À$§À$­À$ÑÀ$³À$®À$»À$ĞÀ$¼À$ÃÀ$ÈÀ$ÄÀ$ËÀ$ÒÀ% À$ÙÀ$ÓÀ$ÛÀ$úÀ$ôÀ$üÀ%á€‰À%æ    À&n}À&Ö   À&nÀ&oÀ&uÀ&’À&{À&vÀ&ƒÀ&‘À&„À&‹À&À&ŒÀ&“À&ÄÀ&šÀ&”À&œÀ&¾À&¸À&À À+ †|À,*/// A mask filter to apply to shapes as they are painted. A mask filter is a
/// function that takes a bitmap of color pixels, and returns another bitmap of
/// color pixels.
///
/// Instances of this class are used with [Paint.maskFilter] on [Paint] objects. À,9ƒÀ/À/À/‚¥/// Creates a mask filter that takes the shape being drawn and blurs it.
///
/// This is commonly used to approximate shadows.
///
/// The `style` argument controls the kind of effect to draw; see [BlurStyle].
///
/// The `sigma` argument controls the size of the effect. It is the standard
/// deviation of the Gaussian blur to apply. The value must be greater than
/// zero. The sigma corresponds to very roughly half the radius of the effect
/// in pixels.
///
/// A blur is an expensive operation and should therefore be used sparingly.
///
/// The arguments must not be null.
///
/// See also:
///
///  * [Canvas.drawShadow], which is a more efficient way to draw shadows.À/À/$  À//À/5   À/DÀ/T  À/^À/k  À0À0 À0$À01À0B À0NÀ1 <À1   À1 À1À0h€”À0‚  À0…À0  À0hÀ0iÀ1@ZÀ1S   À1@À1A À1_À1­     À1Á:À1Ç  À1ÑÀ1Ø  À1ŞÀ1ê    À1ÿ€±À2  À2<  À2BÀ2Y     À2_OÀ2q  À2{À2‚  À2ˆÀ2”  À2_À2` À2²£À2¸  À2ç" À2íÀ2ü À2ı
À3   À3À3"   À3+(À3=  À3GÀ3N  À3TÀ3`  À3+À3, À4W‚¹À4]  À4’: À4©À4¾/// Row-major.À4¿À4Å   À4ĞÀ4ã   À4î‚ À5   À5
À5  À5À5#  À4îÀ4ï À@ƒ™kÀBNÄ/// A description of a color filter to apply when drawing a shape or compositing
/// a layer with a particular [Paint]. A color filter is a function that takes
/// two colors, and outputs one color. When applied during compositing, it is
/// independently applied to each pixel of the layer being drawn before the
/// entire layer is merged with the destination.
///
/// Instances of this class are used with [Paint.colorFilter] on [Paint]
/// objects. ÀBu‚XÀD:ÀD;ÀD?¥/// Creates a color filter that applies the blend mode given as the second
/// argument. The source color is the one given as the first argument, and the
/// destination color is the one from the layer being composited.
///
/// The output of this filter is then composited into the background according
/// to the [Paint.blendMode], using the output of this filter as the source
/// and the background as the destination.ÀD@ÀDG  ÀDMÀDX  ÀDqÀDjÀDsÀDÀD‚ÀDÀDªÀD¢ÀD¬ÀDÀÀDºÀDÂÀDÑˆEÀLÀL‘ÀL—‡7/// Construct a color filter from a 4x5 row-major matrix. The matrix is
/// interpreted as a 5x5 matrix, where the fifth row is the identity
/// configuration.
///
/// Every pixel's color value, represented as an `[R, G, B, A]`, is matrix
/// multiplied to create a new color:
///
///     | R' |   | a00 a01 a02 a03 a04 |   | R |
///     | G' |   | a10 a11 a12 a13 a14 |   | G |
///     | B' | = | a20 a21 a22 a23 a24 | * | B |
///     | A' |   | a30 a31 a32 a33 a34 |   | A |
///     | 1  |   |  0   0   0   0   1  |   | 1 |
///
/// The matrix is in row-major order and the translation column is specified
/// in unnormalized, 0...255, space. For example, the identity matrix is:
///
/// ```dart
/// const ColorFilter identity = ColorFilter.matrix(<double>[
///   1, 0, 0, 0, 0,
///   0, 1, 0, 0, 0,
///   0, 0, 1, 0, 0,
///   0, 0, 0, 1, 0,
/// ]);
/// ```
///
/// ## Examples
///
/// An inversion color matrix:
///
/// ```dart
/// const ColorFilter invert = ColorFilter.matrix(<double>[
///   -1,  0,  0, 0, 255,
///    0, -1,  0, 0, 255,
///    0,  0, -1, 0, 255,
///    0,  0,  0, 1,   0,
/// ]);
/// ```
///
/// A sepia-toned color matrix (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#sepiaEquivalent)):
///
/// ```dart
/// const ColorFilter sepia = ColorFilter.matrix(<double>[
///   0.393, 0.769, 0.189, 0, 0,
///   0.349, 0.686, 0.168, 0, 0,
///   0.272, 0.534, 0.131, 0, 0,
///   0,     0,     0,     1, 0,
/// ]);
/// ```
///
/// A greyscale color filter (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#grayscaleEquivalent)):
///
/// ```dart
/// const ColorFilter greyscale = ColorFilter.matrix(<double>[
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0,      0,      0,      1, 0,
/// ]);
/// ```ÀL˜ÀL¦  ÀL¼ÀLµÀL¾ÀL×ÀLÌÀLÙÀLïÀLçÀLñÀMÀMÀM	ÀM€ôÀM‡ÀMˆÀM™W/// Construct a color filter that applies the sRGB gamma curve to the RGB
/// channels. ÀM«ÀM¤ÀM­ÀMÆÀM»ÀMÈÀMŞÀMÖÀMàÀMôÀMîÀMöÀNÀNŒÀNÀNd/// Creates a color filter that applies the inverse of the sRGB gamma curve
/// to the RGB channels. ÀN°ÀN©ÀN²ÀNËÀNÀÀNÍÀNãÀNÛÀNåÀNùÀNóÀNûÀOÀO$  ÀO.ÀO?  ÀOMÀOa  ÀOlÀOv  ÀO°ÀOÁ ÀOÎÀOå!ÀOö ÀPÀP),ÀP: ÀPTÀPr,ÀPƒ ÀPÀUG€¯ÀU[   ÀUGÀUHÀUúÁÀV   ÀUúÀUûÀPÔVÀPí   ÀPÔÀPÕÀQ.‚×ÀQ<    ÀT	:ÀT#  ÀT&ÀT.  ÀT	ÀT
ÀW¿‚-ÀWÒ   ÀW¿ÀWÀ ÀYğ‡jÀ[@D/// A [ColorFilter] that is backed by a native DlColorFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ColorFilter, because we want ColorFilter to be const constructible and
/// efficiently comparable, so that widgets can check for ColorFilter equality to
/// avoid repainting. À[r€°À[~À[À[ƒ À[„À[Š  
À[˜À[À[ÆÀ[­À[ŸÀ[¦À[§À[°À[»À[¼À\&€¬À\2À\3À\9 À\:À\@  
À\NÀ\TÀ\~À\cÀ\UÀ\\À\]À\fÀ\qÀ\rÀ\Õ€§À\áÀ\âÀ\ó À\ôÀ\ú  
À]À]À]CÀ]À]À]À]À] À]+À],À]€€§À]ŒÀ]À] À]ŸÀ]¥  
À]³À]¹À]îÀ]ÈÀ]ºÀ]ÁÀ]ÂÀ]ËÀ]ÖÀ]×À^+€À^±o/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  À^½]À_   À^½À^¾À^ÄÀ^ÚÀ^ÊÀ^ÅÀ^ÒÀ^ÙÀ^ÓÀ^ÛÀ^ùÀ^âÀ^ÜÀ^äÀ_€—À_‘  À_›	À_   À_¦À_«  À_À_À_%À_PÀ_+À_&À_3À_OÀ_4À_;À_@À_<À_CÀ_JÀ_QÀ_À_XÀ_RÀ_ZÀ_yÀ_sÀ_{À_¹€À`  À`&À`3  À_¹À_ºÀ_ÀÀ_åÀ_ÆÀ_ÁÀ_ÎÀ_äÀ_ÏÀ_ÖÀ_ÛÀ_×À_ŞÀ_æÀ`À_íÀ_çÀ_ïÀ`>€‹À`°   À`>À`?À`EÀ`bÀ`KÀ`FÀ`SÀ`aÀ`TÀ`[À``À`\À`cÀ`À`jÀ`dÀ`lÀ`˜À`’À`šÀ`Í€‹Àa?   À`ÍÀ`ÎÀ`ÔÀ`ñÀ`ÚÀ`ÕÀ`âÀ`ğÀ`ãÀ`êÀ`ïÀ`ëÀ`òÀa-À`ùÀ`óÀ`ûÀa'Àa!Àa) Àa\‹Àc>Ò/// A filter operation to apply to a raster image.
///
/// See also:
///
///  * [BackdropFilter], a widget that applies [ImageFilter] to its rendering.
///  * [ImageFiltered], a widget that applies [ImageFilter] to its children.
///  * [SceneBuilder.pushBackdropFilter], which is the low-level API for using
///    this class as a backdrop filter.
///  * [SceneBuilder.pushImageFilter], which is the low-level API for using
///    this class as a child layer filter. Àc Àc«Àc¬Àc­   ÀcÎÀdÀdÀd"9/// Creates an image filter that applies a Gaussian blur.Àd%Àd-  Àd:ÀdB  ÀdO"ÀdY  Àd5ÀdJÀdcÀdkÀdlÀd×&Àe}Àe~Àe„€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.Àe‡Àe  ÀeÀe¥  Àe˜Àe®Àf'ÀfªÀf«Àf°€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.Àf³Àf»  ÀfÉÀfÑ  ÀfÄÀfÚÀg,‚*Àh!Àh"Àh(€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.Àh)Àh6  ÀhU2Àhd  ÀhsÀh€ÀhÀiZ ÀjhÀjiÀjp€ğ/// Composes the `inner` filter with `outer`, to combine their effects.
///
/// Creates a single [ImageFilter] that when applied, has the same effect as
/// subsequently applying `inner` and `outer`, i.e.,
/// result = outer(inner(source)).ÀjsÀj‰  ÀjÀj¥    ÀlEÀlP    Àkœ$Àk©     Àlfƒ`Àll  ÀlšH ÀlšÀl¬ Àl¯Àl¾  ÀlÃÀlÒ   ÀlæÀlø  Àm !Àm  ÀmG@Àm_ ÀmnÀmzÀm{ÀmÀm†Àm‚ÀmÏLÀmæ   ÀmÏÀmĞÀosQÀo‡   ÀosÀotÀm‹@Àm¤   Àm‹ÀmŒÀnMÀn2   ÀnÀn Ànp€ÿÀnŠ  ÀnÀn•  ÀnpÀnq ÀoÈ„tÀoÎ  Àpa ÀpÀp ÀpÀp,  Àp3ÀpB  ÀpIÀpX   ÀpgÀpt  Àp~Àp‹  Àp•Àp¤  ÀpÅ>Àpİ ÀpìÀpøÀpùÀpıÀqÀpşÀqK€îÀqV    Àr=SÀrT   Àr=Àr>Àsş<Àt   ÀsşÀsÿÀq@Àq    ÀqÀqÀr”TÀr§   Àr”Àr•ÀrìÀs  Às	Às  ÀrìÀrí Àt>‚ûÀtD  ÀtrE ÀtrÀt„ Àt‡Àt–  ÀtÀt­   Àt»ÀtÈ  ÀtÓÀtà  Àtì@Àu ÀuÀuÀu Àu&Àu+Àu'ÀutIÀu‹   ÀutÀuuÀvù>Àw   ÀvùÀvúÀu0@ÀuI   Àu0Àu1ÀuÁJÀuÔ   ÀuÁÀuÂÀv€æÀv)  Àv,Àv4  ÀvÀv Àw;‚õÀwA  ÀwnD ÀwnÀw Àw‚Àw‘  Àw™Àw¨   Àw¶ÀwÃ  ÀwÎÀwÛ  Àwç?Àwÿ ÀxÀxÀxÀx Àx%Àx!ÀxnHÀx…   ÀxnÀxoÀyğ>Àz   ÀyğÀyñÀx*@ÀxC   Àx*Àx+ÀxºIÀxÍ   ÀxºÀx»Ày€åÀy!  Ày$Ày,  ÀyÀy Àz2ƒ‹Àz8  ÀzgN ÀzgÀzz Àz}ÀzŒ  Àz˜Àz§   Àz¹ÀzË  ÀzÚÀzì  À{BÀ{. À{=À{IÀ{JÀ{RÀ{WÀ{SÀ{ sÀ{·   À{ À{¡À}uFÀ}‰   À}uÀ}vÀ{\@À{u   À{\À{]À|_À|*   À|À|À|z€÷À|”  À|—À|Ÿ  À|zÀ|{ À}¿öÀ~ô)/// An [ImageFilter] that is backed by a native DlImageFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ImageFilter, because we want ImageFilter to be efficiently comparable, so that
/// widgets can check for ImageFilter equality to avoid repainting. À&€ãÀnÀoÀs9/// Creates an image filter that applies a Gaussian blur.ÀtÀ  À£À›À¥À€#À€¬À€­À€³€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.À€´À€È  À€İÀ€ÕÀ€ßÀ4#ÀÖÀ×ÀÜ€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.ÀİÀğ  À‚ÀıÀ‚À‚[ãÀƒIÀƒJÀƒP€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.ÀƒQÀƒe  ÀƒzÀƒrÀƒ|À„B€ıÀ„€À„À„//// Converts a color filter to an image filter.À„‘À„  À„³À„«À„µÀ…CzÀ…‚À…ƒÀ…‹0/// Composes `_innerFilter` with `_outerFilter`.À…ŒÀ…¡  À…¶À…®À…¸À‹%€À‹«o/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  À†Á]À‡   À†ÁÀ†ÂÀ†ÈÀ†ŞÀ†ÎÀ†ÉÀ†ÖÀ†İÀ†×À†ßÀ†ıÀ†æÀ†àÀ†èÀ‡"€²À‡  À‡¨À‡°  À‡·À‡¿  À‡ÆÀ‡Ë  À‡"À‡#À‡)À‡]À‡/À‡*À‡7À‡\À‡8À‡?À‡DÀ‡@À‡GÀ‡OÀ‡WÀ‡^À‡ŒÀ‡eÀ‡_À‡gÀ‡†À‡€À‡ˆÀ‡Ø€£ÀˆO  Àˆ[Àˆc  ÀˆkÀˆs  À‡ØÀ‡ÙÀ‡ßÀˆÀ‡åÀ‡àÀ‡íÀˆÀ‡îÀ‡õÀ‡úÀ‡öÀ‡ıÀˆÀˆÀˆ=ÀˆÀˆÀˆÀˆ7Àˆ1Àˆ9Àˆ€¡Àˆõ  À‰ À‰  À‰À‰  ÀˆÀˆ€Àˆ†Àˆ³ÀˆŒÀˆ‡Àˆ”Àˆ²Àˆ•ÀˆœÀˆ¡ÀˆÀˆ¤Àˆ¬Àˆ´ÀˆãÀˆ»ÀˆµÀˆ½ÀˆİÀˆ×ÀˆßÀ‰$€œÀ‰Œ  À‰˜À‰¥  À‰­À‰²  À‰$À‰%À‰+À‰WÀ‰1À‰,À‰9À‰VÀ‰:À‰AÀ‰FÀ‰BÀ‰IÀ‰QÀ‰XÀ‰zÀ‰_À‰YÀ‰aÀ‰Ä€™ÀŠ1  ÀŠBÀŠQ  À‰ÄÀ‰ÅÀ‰ËÀ‰÷À‰ÑÀ‰ÌÀ‰ÙÀ‰öÀ‰ÚÀ‰áÀ‰æÀ‰âÀ‰éÀ‰ğÀ‰õÀ‰ñÀ‰øÀŠÀ‰ÿÀ‰ùÀŠÀŠa€ÀÀŠß  ÀŠíÀŠû  À‹À‹  ÀŠaÀŠbÀŠhÀŠ£ÀŠnÀŠiÀŠvÀŠ¢ÀŠwÀŠ~ÀŠƒÀŠÀŠ†ÀŠÀŠ’ÀŠÀŠ•ÀŠœÀŠ¡ÀŠÀŠ¤ÀŠÍÀŠ«ÀŠ¥ÀŠ­ À‹·…ÀŒ=z/// Base class for objects such as [Gradient] and [ImageShader] which
/// correspond to shaders as used by [Paint.shader]. ÀŒi€ÀŒñÀŒòÀŒóa/// This class is created by the engine, and should not be instantiated
/// or extended directly. ÀŒÏÀŒĞÀŒÖÀŒçÀŒ×ÀŒúÀŒÿ ÀÀÀ£y/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   À5‚šÀ(Û/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, a [Picture] that has not been disposed that
/// refers to an [ImageShader] may keep its underlying resources alive.
///
/// Classes that override this method must call `super.dispose()`.    À©<©!Àªˆ@/// A shader (as used by [Paint.shader]) that renders a color gradient.
///
/// There are several types of gradients, represented by the various constructors
/// on this class.
///
/// See also:
///
///  * [Gradient](https://api.flutter.dev/flutter/painting/Gradient-class.html), the class in the [painting] library.
/// Àª¤‰À°íÀ°îÀ°ô†/// Creates a linear gradient from `from` to `to`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before `from` and after `to` is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
///
/// If `from`, `to`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.À°úÀ±  À±	À±  À±À±'  À±4À±C  À±R"À±\  À±zÀ±ˆ  !À±fÀ±nÀ±oÀ±—À±À±²À±À±¬À±±À±­À±¼À±ÂÀ±ÕÀ±ÃÀ±ÑÀ±ÔÀ±ÒÀ±ßÀ±åÀ²À±öÀ±îÀ±æÀ±ñÀ±ùÀ²À²À²	À²À² À²!À²"À²#À³¹ŒşÀ»éÀ»êÀ»ğ‡ã/// Creates a radial gradient centered at `center` that ends at `radius`
/// distance from the center.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before and after the radius is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
///
/// If `center`, `radius`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.
///
/// If `focal` is provided and not equal to `center` and `focalRadius` is
/// provided and not equal to 0.0, the generated shader will be a two point
/// conical radial gradient, with `focal` being the center of the focal
/// circle and `focalRadius` being the radius of that circle. If `focal` is
/// provided and not equal to `center`, at least one of the two offsets must
/// not be equal to [Offset.zero].À»öÀ»ş  À¼	À¼  À¼À¼)  À¼6À¼E  À¼T"À¼^  À¼|À¼Š  À¼–À¼Ÿ  À¼©À¼±  À¼hÀ¼pÀ¼qÀ¼¾À¼ÉÀ¼ÏÀ¼æÀ¼ĞÀ¼ŞÀ¼åÀ¼ßÀ¼ğÀ¼öÀ½"À½À¼ÿÀ¼÷À½À½
À½À½!À½À½,À½1À½2À½3À½4ÀÀ»ŠOÀÈ5ÀÈ6ÀÈ;‡3/// Creates a sweep gradient centered at `center` that starts at `startAngle`
/// and ends at `endAngle`.
///
/// `startAngle` and `endAngle` should be provided in radians, with zero
/// radians being the horizontal line to the right of the `center` and with
/// positive angles going clockwise around the `center`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before `startAngle` and after `endAngle` is described by the
/// `tileMode` argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png)
///
/// If `center`, `colors`, `tileMode`, `startAngle`, or `endAngle` are null,
/// or if `colors` or `colorStops` contain null values, this constructor will
/// throw a [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.ÀÈAÀÈI  ÀÈTÀÈa  ÀÈnÀÈ}  ÀÈŒ"ÀÈ–  ÀÈ´ÀÈ¼  ÀÈÑÀÈÙ  ÀÈôÀÉ  &ÀÈ ÀÈ¨ÀÈ©ÀÈÈÀÈëÀÈãÀÈçÀÈèÀÈíÀÉÀÉÀÉ.ÀÉÀÉ&ÀÉ-ÀÉ'ÀÉ8ÀÉ>ÀÉTÀÉJÀÉ?ÀÉLÀÉ^ÀÉdÀÉÀÉuÀÉmÀÉeÀÉpÀÉxÀÉ‡ÀÉÀÉˆÀÉšÀÉŸÀÉ ÀÉ¡ÀÉ¢  ÀËZÀËY   ÀËÀËÀËÀË+ÀËÀËÀË#ÀË*ÀË$ÀË,ÀËGÀË3ÀË-ÀË5ÀËl€ñÀËé  ÀËõÀÌ  ÀÌÀÌ  ÀÌ ÀÌ.  ÀÌ9ÀÌ>  ÀÌGÀÌU  ÀËlÀËmÀËsÀË·ÀËyÀËtÀËÀË¶ÀË‚ÀË‰ÀËÀËŠÀË‘ÀË™ÀË¡ÀË©ÀË°ÀË¸ÀË×ÀË¿ÀË¹ÀËÁÀÌaDÀÌî  ÀÍÀÍ	  ÀÍÀÍ  ÀÍ-ÀÍ5  ÀÍBÀÍO  ÀÍ\ÀÍj  ÀÍ{ÀÍ€  ÀÍÀÍ  ÀÌaÀÌbÀÌhÀÌ¼ÀÌnÀÌiÀÌvÀÌ»ÀÌwÀÌ~ÀÌƒÀÌÀÌ†ÀÌÀÌ–ÀÌÀÌ¦ÀÌ®ÀÌµÀÌ½ÀÌÜÀÌÄÀÌ¾ÀÌÆÀÍ©§ÀÎW  
ÀÎkÀÎs  ÀÎ€ÀÎˆ  ÀÎ•ÀÎ  ÀÎ¯ÀÎ·  ÀÎÂÀÎÊ  ÀÎÕÀÎİ  ÀÎíÀÎú  ÀÏÀÏ  ÀÏ&ÀÏ+  ÀÏ:ÀÏH  ÀÍ©ÀÍªÀÍ°ÀÎÀÍ¶ÀÍ±ÀÍ¾ÀÎÀÍ¿ÀÍÆÀÍËÀÍÇÀÍÎÀÍÖÀÍŞÀÍæÀÍîÀÍöÀÍşÀÎÀÎÀÎÀÎÀÎEÀÎ$ÀÎÀÎ&ÀÏTdÀÏè  ÀÏúÀĞ  ÀĞÀĞ  ÀĞ&ÀĞ3  ÀĞ@ÀĞN  ÀĞ_ÀĞd  ÀĞsÀĞ{  ÀĞŒÀĞ”  ÀĞ£ÀĞ±  ÀÏTÀÏUÀÏ[ÀÏ·ÀÏaÀÏ\ÀÏiÀÏ¶ÀÏjÀÏqÀÏvÀÏrÀÏyÀÏÀÏ‰ÀÏ‘ÀÏ™ÀÏ ÀÏ¨ÀÏ°ÀÏ¸ÀÏÖÀÏ¿ÀÏ¹ÀÏÁÀĞ¼ŸÀĞÈ  ÀĞãÀĞğ  ÀĞ÷ÀÑ    ÀÒ_ˆlÀÒ¨=/// A shader (as used by [Paint.shader]) that tiles an image. ÀÒÇ…– ÀÖ‹ÀÖ–ƒ/// Creates an image-tiling shader.
///
/// The first argument specifies the image to render. The
/// [decodeImageFromList] function can be used to decode an image from bytes
/// into the form expected here. (In production code, starting from
/// [instantiateImageCodec] may be preferable.)
///
/// The second and third arguments specify the [TileMode] for the x direction
/// and y direction respectively. [TileMode.repeated] can be used for tiling
/// images.
///
/// The fourth argument gives the matrix to apply to the effect. The
/// expression `Matrix4.identity().storage` creates a [Float64List]
/// prepopulated with the identity matrix.
///
/// All the arguments are required and must not be null, except for
/// [filterQuality]. If [filterQuality] is not specified at construction time
/// it will be deduced from the environment where it is used, such as from
/// [Paint.filterQuality].ÀÖ—ÀÖ  ÀÖ¤ÀÖ®  ÀÖ²ÀÖ¼  ÀÖÀÀÖÍ  ÀÖÛÀÖë  ÀÖoÀÖpÀÖvÀÖ‡ÀÖwÀ×À×
À×À×À×À×À×À×&À×+À×,À×-À×.  ÀØaEÀØr   ÀØaÀØbÀØª]ÀØø   ÀØªÀØ«ÀØ±ÀØÇÀØ·ÀØ²ÀØ¿ÀØÆÀØÀÀØÈÀØæÀØÏÀØÉÀØÑÀÙ€éÀÙ˜  ÀÙ§ÀÙ¯  ÀÙµÀÙº  ÀÙ¾ÀÙÃ  ÀÙÇÀÙÌ  ÀÙßÀÙì  ÀÙÀÙÀÙÀÙ]ÀÙÀÙÀÙ"ÀÙ\ÀÙ#ÀÙ*ÀÙ/ÀÙ+ÀÙ2ÀÙ9ÀÙ>ÀÙ:ÀÙAÀÙHÀÙOÀÙVÀÙ^ÀÙƒÀÙeÀÙ_ÀÙgÀÙø€ÑÀÚ¾k/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  ÀÚhÀÚiÀÚoÀÚŒÀÚuÀÚpÀÚ}ÀÚ‹ÀÚ~ÀÚ…ÀÚŠÀÚ†ÀÚÀÚ¬ÀÚ”ÀÚÀÚ– ÀÚÍŒeÀÛµ€Ü/// An instance of [FragmentProgram] creates [Shader] objects (as used by
/// [Paint.shader]).
///
/// For more information, see the website
/// [documentation]( https://docs.flutter.dev/development/ui/advanced/shaders). ÀÛê!ÀÜÀÜÀÜ  ÀÜ!ÀÜ)  ÀÛêÀÛëÀÛñÀÜÀÛòÀİÀİ  Àââ]Àã Àã=Àã>Àã$Àã<Àã%Àã-ÀåC7Àåh ÀåCÀåDÀåJÀå[ÀåKÀå2Àå¤ ÀåÀå€Àå†Àå—Àå‡ Àİ&„+ÀŞ//// Creates a fragment program from the asset with key [assetKey].
///
/// The asset must be a file produced as the output of the `impellerc`
/// compiler. The constructed object should then be reused via the
/// [fragmentShader] method to create [Shader] objects that can be used by
/// [Paint.shader]. ÀŞ‹ÀŞ“   ÀãDûÀãP  ÀãdÀãl   Àå¶aÀæ   Àå¶Àå·Àå½ÀåÓÀåÃÀå¾ÀåËÀåÒÀåÌÀåÔÀåöÀåÛÀåÕÀåİÀæ€ŒÀæ‡  Àæ–Àæ  ÀæÀæÀæ"ÀæIÀæ*Àæ#Àæ2ÀæHÀæ3Àæ:Àæ?Àæ;ÀæBÀæJÀæsÀæQÀæKÀæSÀæ«€…Àæî1/// Returns a fresh instance of [FragmentShader].    Àç4‘şÀê%‚å/// A [Shader] generated from a [FragmentProgram].
///
/// Instances of this class can be obtained from the
/// [FragmentProgram.fragmentShader] method. The float uniforms list is
/// initialized to the size expected by the shader and is zero-filled. Uniforms
/// of float type can then be set by calling [setFloat]. Sampler uniforms are
/// set by calling [setImageSampler].
///
/// A [FragmentShader] can be re-used, and this is an efficient way to avoid
/// allocating and re-initializing the uniform buffer and samplers. However,
/// if two [FragmentShader] objects with different float uniforms or samplers
/// are required to exist simultaneously, they must be obtained from two
/// different calls to [FragmentProgram.fragmentShader]. ÀêG€ÛÀêUÀêVÀêW ÀêXÀêi  ÀêsÀê|  Àê•ÀêŠÀê—Àê¢Àê§Àê¨Àê©ÀêªÀë&Àë4  ÀëC<Àë\ ÀëqÀë|Àë~Àë}Àëƒ(Àë Àë™ Àë°‡Àò¨†œ/// Sets the float uniform at [index] to [value].
///
/// All uniforms defined in a fragment shader that are not samplers must be
/// set through this method. This includes floats and vec2, vec3, and vec4.
/// The correct index for each uniform is determined by the order of the
/// uniforms as defined in the fragment program, ignoring any samplers. For
/// data types that are composed of multiple floats such as a vec4, more than
/// one call to [setFloat] is required.
///
/// For example, given the following uniforms in a fragment program:
///
/// ```glsl
/// uniform float uScale;
/// uniform sampler2D uTexture;
/// uniform vec2 uMagnitude;
/// uniform vec4 uColor;
/// ```
///
/// Then the corresponding Dart code to correctly initialize these uniforms
/// is:
///
/// ```dart
/// void updateShader(ui.FragmentShader shader, Color color, ui.Image image) {
///   shader.setFloat(0, 23);  // uScale
///   shader.setFloat(1, 114); // uMagnitude x
///   shader.setFloat(2, 83);  // uMagnitude y
///
///   // Convert color to premultiplied opacity.
///   shader.setFloat(3, color.red / 255 * color.opacity);   // uColor r
///   shader.setFloat(4, color.green / 255 * color.opacity); // uColor g
///   shader.setFloat(5, color.blue / 255 * color.opacity);  // uColor b
///   shader.setFloat(6, color.opacity);                     // uColor a
///
///   // initialize sampler uniform.
///   shader.setImageSampler(0, image);
/// }
/// ```
///
/// Note how the indexes used does not count the `sampler2D` uniform. This
/// uniform will be set separately with [setImageSampler], with the index starting
/// over at 0.
///
/// Any float uniforms that are left uninitialized will default to `0`. Àò±	Àò¶  Àò¼ÀòÄ   ÀóDüÀô”</// Sets the sampler uniform at [index] to [image].
///
/// The index provided to setImageSampler is the index of the sampler uniform defined
/// in the fragment program, excluding all non-sampler uniforms.
///
/// All the sampler uniforms that a shader expects must be provided or the
/// results will be undefined. Àô¤	Àô©  Àô¯Àô¶   ÀõD…Àös/// Releases the native resources held by the [FragmentShader].
///
/// After this method is called, calling methods on the shader, or attaching
/// it to a [Paint] object will fail with an exception. Calling [dispose]
/// twice will also result in an exception being thrown.  ÀöbÀöcÀöÍ€ÈÀ÷G  À÷TÀ÷e  À÷mÀ÷r  À÷€À÷…  ÀöÍÀöÎÀöÔÀ÷ÀöÜÀöÕÀöäÀ÷ÀöåÀöíÀöõÀöıÀ÷À÷.À÷À÷À÷À÷™€¥Àø  Àø#	Àø(  Àø.Àø6  À÷™À÷šÀ÷ À÷ÍÀ÷¦À÷¡À÷®À÷ÌÀ÷¯À÷¶À÷»À÷·À÷¾À÷ÆÀ÷ÎÀø À÷ÕÀ÷ÏÀ÷×ÀøB~Àø¬   ÀøBÀøCÀøIÀøfÀøOÀøJÀøWÀøeÀøXÀø_ÀødÀø`ÀøgÀøšÀønÀøhÀøpÀøÄlÀù%   ÀøÄÀøÅÀøËÀøèÀøÑÀøÌÀøÙÀøçÀøÚÀøáÀøæÀøâÀøéÀùÀøğÀøêÀøò Àûù¬ŒÀsˆn/// A set of vertex data used by [Canvas.drawVertices].
///
/// Vertex data consists of a series of points in the canvas coordinate space.
/// Based on the [VertexMode], these points are interpreted either as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single shared
/// point ([VertexMode.triangleFan]).
///
/// Each point can be associated with a color. Each triangle is painted as a
/// gradient that blends between the three colors at the three points of that
/// triangle. If no colors are specified, transparent black is assumed for all
/// the points.
///
/// These colors are then blended with the [Paint] specified in the call to
/// [Canvas.drawVertices]. This paint is either a solid color ([Paint.color]),
/// or a bitmap, specified using a shader ([Paint.shader]), typically either a
/// gradient ([Gradient]) or image ([ImageFilter]). The bitmap uses the same
/// coordinate space as the canvas (in the case of an [ImageFilter], this is
/// notably different than the coordinate space of the source image; the source
/// image is tiled according to the filter's configuration, and the image that
/// is sampled when painting the triangles is the infinite one after all the
/// repeating is applied.)
///
/// Each point in the [Vertices] is associated with a specific point on this
/// image. Each triangle is painted by sampling points from this image by
/// interpolating between the three points of the image corresponding to the
/// three points of the triangle.
///
/// The [Vertices.new] constructor configures all this using lists of [Offset]
/// and [Color] objects. The [Vertices.raw] constructor instead uses
/// [Float32List], [Int32List], and [Uint16List] objects, which more closely
/// corresponds to the data format used internally and therefore reduces some of
/// the conversion overhead. The raw constructor is useful if the data is coming
/// from another source (e.g. a file) and can therefore be parsed directly into
/// the underlying representation. À¡, À¢Àªˆ¬/// Creates a set of vertex data for use with [Canvas.drawVertices].
///
/// The `mode` parameter describes how the points should be interpreted: as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single
/// shared point ([VertexMode.triangleFan]).
///
/// The `positions` parameter provides the points in the canvas space that
/// will be use to draw the triangles.
///
/// The `colors` parameter, if specified, provides the color for each point in
/// `positions`. Each triangle is painted as a gradient that blends between
/// the three colors at the three points of that triangle. (These colors are
/// then blended with the [Paint] specified in the call to
/// [Canvas.drawVertices].)
///
/// The `textureCoordinates` parameter, if specified, provides the points in
/// the [Paint] image to sample for the corresponding points in `positions`.
///
/// If the `colors` or `textureCoordinates` parameters are specified, they must
/// be the same length as `positions`.
///
/// The `indices` parameter specifies the order in which the points should be
/// painted. If it is omitted (or present but empty), the points are processed
/// in the order they are given in `positions`, as if the `indices` was a list
/// from 0 to n-1, where _n_ is the number of entries in `positions`. The
/// `indices` parameter, if present and non-empty, must have at least three
/// entries, but may be of any length beyond this. Indicies may refer to
/// offsets in the positions array multiple times, or may skip positions
/// entirely.
///
/// If the `indices` parameter is specified, all values in the list must be
/// valid index values for `positions`.
///
/// The `mode` and `positions` parameters must not be null.
///
/// This constructor converts its parameters into [dart:typed_data] lists
/// (e.g. using [Float32List]s for the coordinates) before sending them to the
/// Flutter engine. If the data provided to this constructor is not already in
/// [List] form, consider using the [Vertices.raw] constructor instead to
/// avoid converting the data twice.À°À¼  ÀÅÀÓ  ÀãÀñ  Àü À  À"À.   ÀÑšÀZÀ[À^Š(/// Creates a set of vertex data for use with [Canvas.drawVertices], using the
/// encoding expected by the Flutter engine.
///
/// The `mode` parameter describes how the points should be interpreted: as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single
/// shared point ([VertexMode.triangleFan]).
///
/// The `positions` parameter provides the points in the canvas space that
/// will be use to draw the triangles. Each point is represented as two
/// numbers in the list, the first giving the x coordinate and the second
/// giving the y coordinate. (As a result, the list must have an even number
/// of entries.)
///
/// The `colors` parameter, if specified, provides the color for each point in
/// `positions`. Each color is represented as ARGB with 8 bit color channels
/// (like [Color.value]'s internal representation), and the list, if
/// specified, must therefore be half the length of `positions`. Each triangle
/// is painted as a gradient that blends between the three colors at the three
/// points of that triangle. (These colors are then blended with the [Paint]
/// specified in the call to [Canvas.drawVertices].)
///
/// The `textureCoordinates` parameter, if specified, provides the points in
/// the [Paint] image to sample for the corresponding points in `positions`.
/// Each point is represented as two numbers in the list, the first giving the
/// x coordinate and the second giving the y coordinate. This list, if
/// specified, must be the same length as `positions`.
///
/// The `indices` parameter specifies the order in which the points should be
/// painted. If it is omitted (or present but empty), the points are processed
/// in the order they are given in `positions`, as if the `indices` was a list
/// from 0 to n-2, where _n_ is the number of pairs in `positions` (i.e. half
/// the length of `positions`). The `indices` parameter, if present and
/// non-empty, must have at least three entries, but may be of any length
/// beyond this. Indicies may refer to offsets in the positions array multiple
/// times, or may skip positions entirely.
///
/// If the `indices` parameter is specified, all values in the list must be
/// valid index values for pairs in `positions`. For example, if there are 12
/// numbers in `positions` (representing 6 coordinates), the `indicies` must
/// be numbers in the range 0..5 inclusive.
///
/// The `mode` and `positions` parameters must not be null.ÀdÀp  ÀyÀ†  À–À¢  À­À»  ÀÒÀß   À&ËÀ&Ğ À&ÜÀ&åÀ'¢€«/// Whether this reference to the underlying vertex data is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   À#oÀ#æ  À#ìÀ#ö  À$À$$  À$FÀ$S  À$zÀ$ˆ  À$¸À$Ä  À$èÀ$õ  À#oÀ#pÀ#vÀ#³À#|À#wÀ#„À#²À#…À#À#”À#œÀ#¤À#¬À#´À#ÍÀ#»À#µÀ#½À%€ôÀ%yn/// Release the resources used by this object. The object is no longer usable
/// after this method is called.   À%ù€ÎÀ&¼k/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À&iÀ&jÀ&pÀ&À&vÀ&qÀ&~À&ŒÀ&À&†À&‹À&‡À&À&ªÀ&•À&À&— À-ÍÀ ˜«À3¿…â/// An interface for recording graphical operations.
///
/// [Canvas] objects are used in creating [Picture] objects, which can
/// themselves be used with a [SceneBuilder] to build a [Scene]. In
/// normal usage, however, this is all handled by the framework.
///
/// A canvas has a current transformation matrix which is applied to all
/// operations. Initially, the transformation matrix is the identity transform.
/// It can be modified using the [translate], [scale], [rotate], [skew],
/// and [transform] methods.
///
/// A canvas also has a current clip region which is applied to all operations.
/// Initially, the clip region is infinite. It can be modified using the
/// [clipRect], [clipRRect], and [clipPath] methods.
///
/// The current transform and clip can be saved and restored using the stack
/// managed by the [save], [saveLayer], and [restore] methods.
///
/// ## Use with the Flutter framework
///
/// The Flutter framework's [RendererBinding] provides a hook for creating
/// [Canvas] objects ([RendererBinding.createCanvas]) that allows tests to hook
/// into the scene creation logic. When creating a [Canvas] that will be used
/// with a [PictureLayer] as part of the [Scene] in the context of the Flutter
/// framework, consider calling [RendererBinding.createCanvas] instead of
/// calling the [Canvas.new] constructor directly.
///
/// This does not apply when using a canvas to generate a bitmap for other
/// purposes, e.g. for generating a PNG image using [Picture.toImage]. À3Ê‚× À6\À6b‚q/// Creates a canvas for recording graphical operations into the
/// given picture recorder.
///
/// Graphical operations that affect pixels entirely outside the given
/// `cullRect` might be discarded by the implementation. However, the
/// implementation might draw outside these bounds if, for example, a command
/// draws partially inside and outside the `cullRect`. To ensure that pixels
/// outside a given region are discarded, consider using a [clipRect]. The
/// `cullRect` is optional; by default, all operations are kept.
///
/// To end the recording, call [PictureRecorder.endRecording] on the
/// given recorder.À6cÀ6t  À6À6†     %À6¥(À7Æ/// Saves a copy of the current transform and clip on the save stack.
///
/// Call [restore] to pop the save stack.
///
/// See also:
///
///  * [saveLayer], which does the same thing but additionally also groups the
///    commands done until the matching [restore].   À7Ñ”šÀLF“•/// Saves a copy of the current transform and clip on the save stack, and then
/// creates a new group which subsequent calls will become a part of. When the
/// save stack is later popped, the group will be flattened into a layer and
/// have the given `paint`'s [Paint.colorFilter] and [Paint.blendMode]
/// applied.
///
/// This lets you create composite effects, for example making a group of
/// drawing commands semi-transparent. Without using [saveLayer], each part of
/// the group would be painted individually, so where they overlap would be
/// darker than where they do not. By using [saveLayer] to group them
/// together, they can be drawn with an opaque color at first, and then the
/// entire group can be made transparent using the [saveLayer]'s paint.
///
/// Call [restore] to pop the save stack and apply the paint to the group.
///
/// ## Using saveLayer with clips
///
/// When a rectangular clip operation (from [clipRect]) is not axis-aligned
/// with the raster buffer, or when the clip operation is not rectilinear
/// (e.g. because it is a rounded rectangle clip created by [clipRRect] or an
/// arbitrarily complicated path clip created by [clipPath]), the edge of the
/// clip needs to be anti-aliased.
///
/// If two draw calls overlap at the edge of such a clipped region, without
/// using [saveLayer], the first drawing will be anti-aliased with the
/// background first, and then the second will be anti-aliased with the result
/// of blending the first drawing and the background. On the other hand, if
/// [saveLayer] is used immediately after establishing the clip, the second
/// drawing will cover the first in the layer, and thus the second alone will
/// be anti-aliased with the background when the layer is clipped and
/// composited (when [restore] is called).
///
/// For example, this [CustomPainter.paint] method paints a clean white
/// rounded rectangle:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.saveLayer(rect, Paint());
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.restore();
/// }
/// ```
///
/// On the other hand, this one renders a red outline, the result of the red
/// paint being anti-aliased with the background at the clip edge, then the
/// white paint being similarly anti-aliased with the background _including
/// the clipped red paint_:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   // (this example renders poorly, prefer the example above)
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// This point is moot if the clip only clips one draw operation. For example,
/// the following paint method paints a pair of clean white rounded
/// rectangles, even though the clips are not done on a separate layer:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(Offset.zero & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(size.center(Offset.zero) & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// (Incidentally, rather than using [clipRRect] and [drawPaint] to draw
/// rounded rectangles like this, prefer the [drawRRect] method. These
/// examples are using [drawPaint] as a proxy for "complicated draw operations
/// that will get clipped", to illustrate the point.)
///
/// ## Performance considerations
///
/// Generally speaking, [saveLayer] is relatively expensive.
///
/// There are a several different hardware architectures for GPUs (graphics
/// processing units, the hardware that handles graphics), but most of them
/// involve batching commands and reordering them for performance. When layers
/// are used, they cause the rendering pipeline to have to switch render
/// target (from one layer to another). Render target switches can flush the
/// GPU's command buffer, which typically means that optimizations that one
/// could get with larger batching are lost. Render target switches also
/// generate a lot of memory churn because the GPU needs to copy out the
/// current frame buffer contents from the part of memory that's optimized for
/// writing, and then needs to copy it back in once the previous render target
/// (layer) is restored.
///
/// See also:
///
///  * [save], which saves the current state, but does not create a new layer
///    for subsequent commands.
///  * [BlendMode], which discusses the use of [Paint.blendMode] with
///    [saveLayer]. ÀLPÀLW  ÀL^ÀLe   ÀLoFÀM«(/// Pops the current save stack, if there is anything to pop.
/// Otherwise, does nothing.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If the state was pushed with [saveLayer], then this call will also
/// cause the new layer to be composited into the previous layer.   ÀM¹‚%ÀOÄó/// Restores the save stack to a previous level as might be obtained from [getSaveCount].
/// If [count] is less than 1, the stack is restored to its initial state.
/// If [count] is greater than the current [getSaveCount] then nothing happens.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If any of the state stack levels restored by this call were pushed with
/// [saveLayer], then this call will also cause those layers to be composited
/// into their previous layers. ÀOÓ	ÀOØ   ÀOâBÀQ"/// Returns the number of items on the save stack, including the
/// initial state. This means it returns 1 for a clean canvas, and
/// that each call to [save] and [saveLayer] increments it, and that
/// each matching call to [restore] decrements it.
///
/// This number cannot go below 1.   ÀQ(€ÅÀQÍ€›/// Add a translation to the current transform, shifting the coordinate space
/// horizontally by the first argument and vertically by the second argument. ÀQ×	ÀQß  ÀQâ	ÀQê   ÀQñ,ÀRş€û/// Add an axis-aligned scale to the current transform, scaling by the first
/// argument in the horizontal direction and the second in the vertical
/// direction.
///
/// If [sy] is unspecified, [sx] will be used for the scale in both
/// directions. ÀS	ÀS  ÀS
ÀS   ÀS!qÀS{R/// Add a rotation to the current transform. The argument is in radians clockwise. ÀS‚ÀSŠ   ÀS–5ÀT°/// Add an axis-aligned skew to the current transform, with the first argument
/// being the horizontal skew in rise over run units clockwise around the
/// origin, and the second argument being the vertical skew in rise over run
/// units clockwise around the origin. ÀTµ	ÀT½  ÀTÀ	ÀTÈ   ÀTÏ€¯ÀU_€ˆ/// Multiply the current transform by the specified 4â¨‰4 transformation matrix
/// specified as a list of values in column-major order. ÀUiÀUv   ÀU‚‚ÀWv×/// Returns the current transform including the combined result of all transform
/// methods executed since the creation of this [Canvas] object, and respecting the
/// save/restore history.
///
/// Methods that can change the current transform include [translate], [scale],
/// [rotate], [skew], and [transform]. The [restore] method can also modify
/// the current transform by restoring it to the same value it had before its
/// associated [save] or [saveLayer] call.   ÀW‰‚ÀYÆ‚/// Reduces the clip region to the intersection of the current clip and the
/// given rectangle.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_rect.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that.
///
/// Use [ClipOp.difference] to subtract the provided rectangle from the
/// current clip. ÀYÏ	ÀYÕ  ÀYÜ ÀYä  ÀYşÀZ  ÀYìÀYòÀYóÀZÀZ‚;À\&ï/// Reduces the clip region to the intersection of the current clip and the
/// given rounded rectangle.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_rrect.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that and some examples of using [clipRRect]. À\0À\7  À\>À\D  À\QÀ\\‚À^2¼/// Reduces the clip region to the intersection of the current clip and the
/// given [Path].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_path.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that. À^;	À^A  À^GÀ^M  À^ZÀ^eŠİÀi-ŠZ/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the local coordinate space under which rendering operations are currently
/// performed.
///
/// The combined clip results are rounded out to an integer pixel boundary before
/// they are transformed back into the local coordinate space which accounts for
/// the pixel roundoff in rendering operations, particularly when antialiasing.
/// Because the [Picture] may eventually be rendered into a scene within the
/// context of transforming widgets or layers, the result may thus be overly
/// conservative due to premature rounding. Using the [getDestinationClipBounds]
/// method combined with the external transforms and rounding in the true device
/// coordinate system will produce more accurate results, but this value may
/// provide a more convenient approximation to compare rendering operations to
/// the established clip.
///
/// {@template dart.ui.canvas.conservativeClipBounds}
/// The conservative estimate of the bounds is based on intersecting the bounds
/// of each clip method that was executed with [ClipOp.intersect] and potentially
/// ignoring any clip method that was executed with [ClipOp.difference]. The
/// [ClipOp] argument is only present on the [clipRect] method.
///
/// To understand how the bounds estimate can be conservative, consider the
/// following two clip method calls:
///
/// ```dart
/// void draw(Canvas canvas) {
///   canvas.clipPath(Path()
///     ..addRect(const Rect.fromLTRB(10, 10, 20, 20))
///     ..addRect(const Rect.fromLTRB(80, 80, 100, 100)));
///   canvas.clipPath(Path()
///     ..addRect(const Rect.fromLTRB(80, 10, 100, 20))
///     ..addRect(const Rect.fromLTRB(10, 80, 20, 100)));
///   // ...
/// }
/// ```
///
/// After executing both of those calls there is no area left in which to draw
/// because the two paths have no overlapping regions. But, in this case,
/// [getLocalClipBounds] would return a rectangle from `10, 10` to `100, 100` because it
/// only intersects the bounds of the two path objects to obtain its conservative
/// estimate.
///
/// The clip bounds are not affected by the bounds of any enclosing
/// [saveLayer] call as the engine does not currently guarantee the strict
/// enforcement of those bounds during rendering.
///
/// Methods that can change the current clip include [clipRect], [clipRRect],
/// and [clipPath]. The [restore] method can also modify the current clip by
/// restoring it to the same value it had before its associated [save] or
/// [saveLayer] call.
/// {@endtemplate}   ÀiFƒŸÀlÊƒb/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the destination coordinate space in which the [Picture] will be rendered.
///
/// Unlike [getLocalClipBounds], the bounds are not rounded out to an integer
/// pixel boundary as the Destination coordinate space may not represent pixels
/// if the [Picture] being constructed will be further transformed when it is
/// rendered or added to a scene. In order to determine the true pixels being
/// affected, those external transforms should be applied first before rounding
/// out the result to integer pixel boundaries. Most typically, [Picture] objects
/// are rendered in a scene with a scale transform representing the Device Pixel
/// Ratio.
///
/// {@macro dart.ui.canvas.conservativeClipBounds}   Àlé€İÀmš€¥/// Paints the given [Color] onto the canvas, applying the given
/// [BlendMode], with the given color being the source and the background
/// being the destination. Àm¤Àm«  Àm±Àm¼   ÀmÊüÀoš¼/// Draws a line between the given points using the given paint. The line is
/// stroked, the value of the [Paint.style] is ignored for this call.
///
/// The `p1` and `p2` arguments are interpreted as offsets from the origin.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_line.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_line_dark.png#gh-dark-mode-only) Ào£	Ào«  Ào®	Ào¶  Ào¹ÀoÀ   ÀoÊ€±Àpd€Œ/// Fills the canvas with the given [Paint].
///
/// To fill the canvas with a solid color and blend mode, consider
/// [drawColor] instead. ÀpnÀpu   Àp‘Àqï`/// Draws a rectangle with the given [Paint]. Whether the rectangle is filled
/// or stroked (or both) is controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rect.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rect_dark.png#gh-dark-mode-only) Àqø	Àqş  ÀrÀr
   ÀrÀsj/// Draws a rounded rectangle with the given [Paint]. Whether the rectangle is
/// filled or stroked (or both) is controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rrect.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rrect_dark.png#gh-dark-mode-only) Às˜ÀsŸ  Às¥Às¬   Às¶HÀtÌ/// Draws a shape consisting of the difference between two rounded rectangles
/// with the given [Paint]. Whether this shape is filled or stroked (or both)
/// is controlled by [Paint.style].
///
/// This shape is almost but not quite entirely unlike an annulus. Àt×ÀtŞ  ÀtäÀtë  ÀtñÀtø   ÀuÇÀv¨”/// Draws an axis-aligned oval that fills the given axis-aligned rectangle
/// with the given [Paint]. Whether the oval is filled or stroked (or both) is
/// controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_oval.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_oval_dark.png#gh-dark-mode-only) Àv±	Àv·  Àv¼ÀvÃ   ÀvÍ‚)ÀxÅä/// Draws a circle centered at the point given by the first argument and
/// that has the radius given by the second argument, with the [Paint] given in
/// the third argument. Whether the circle is filled or stroked (or both) is
/// controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_circle.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_circle_dark.png#gh-dark-mode-only) ÀxĞÀxØ  ÀxÚÀxâ  ÀxéÀxğ   ÀxúƒÛÀ|ƒc/// Draw an arc scaled to fit inside the given rectangle.
///
/// It starts from `startAngle` radians around the oval up to
/// `startAngle` + `sweepAngle` radians around the oval, with zero radians
/// being the point on the right hand side of the oval that crosses the
/// horizontal line that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval. If `useCenter` is true, the arc is
/// closed back to the center, forming a circle sector. Otherwise, the arc is
/// not closed, forming a circle segment.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_draw_arc.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_draw_arc_dark.png#gh-dark-mode-only)
///
/// This method is optimized for drawing arcs and should be faster than [Path.arcTo]. À|‡	À|  À|’À|š  À|¥À|­  À|¸À|¾  À|ÈÀ|Ï   À|ÙÀ}×€î/// Draws the given [Path] with the given [Paint].
///
/// Whether this shape is filled or stroked (or both) is controlled by
/// [Paint.style]. If the path is filled, then sub-paths within it are
/// implicitly closed (see [Path.close]). À}à	À}æ  À}ëÀ}ò   À}ü€İÀ~¦€ /// Draws the given [Image] into the canvas with its top-left corner at the
/// given [Offset]. The image is composited into the canvas using the given [Paint]. À~°À~·  À~½À~Å  À~ÌÀ~Ó   À~İøÀ€™¤/// Draws the subset of the given image described by the `src` argument into
/// the canvas in the axis-aligned rectangle given by the `dst` argument.
///
/// This might sample from outside the `src` rect by up to half the width of
/// an applied filter.
///
/// Multiple calls to this method with different arguments (from the same
/// image) can be batched into a single call to [drawAtlas] to improve
/// performance. À€§À€®  À€´À€º  À€¾À€Ä  À€ÈÀ€Ï   À€ÙƒQÀƒë‚ò/// Draws the given [Image] into the canvas using the given [Paint].
///
/// The image is drawn in nine portions described by splitting the image by
/// drawing two horizontal lines and two vertical lines, where the `center`
/// argument describes the rectangle formed by the four points where these
/// four lines intersect each other. (This forms a 3-by-3 grid of regions,
/// the center region being described by the `center` argument.)
///
/// The four regions in the corners are drawn, without scaling, in the four
/// corners of the destination rectangle described by `dst`. The remaining
/// five regions are drawn by stretching them to fit such that they exactly
/// cover the destination rectangle while maintaining their relative
/// positions. ÀƒùÀ„   À„À„  À„À„  À„À„$   À„.€‚À„“[/// Draw the given picture onto the canvas. To create a picture, see
/// [PictureRecorder]. À„ŸÀ„¨   À„´„IÀˆËƒé/// Draws the text in the given [Paragraph] into this canvas at the given
/// [Offset].
///
/// The [Paragraph] object must have had [Paragraph.layout] called on it
/// first.
///
/// To align the text, set the `textAlign` on the [ParagraphStyle] object
/// passed to the [ParagraphBuilder.new] constructor. For more details see
/// [TextAlign] and the discussion at [ParagraphStyle.new].
///
/// If the text is left aligned or justified, the left margin will be at the
/// position specified by the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is right aligned or justified, the right margin will be at the
/// position described by adding the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is centered, the centering axis will be at the position
/// described by adding half of the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate. ÀˆÙÀˆä  ÀˆîÀˆö   À‰ôÀŠ³–/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as offsets from the origin.
///
/// The `paint` is used for each point ([PointMode.points]) or line
/// ([PointMode.lines] or [PointMode.polygon]), ignoring [Paint.style].
///
/// See also:
///
///  * [drawRawPoints], which takes `points` as a [Float32List] rather than a
///    [List<Offset>]. ÀŠ¾ÀŠÉ  ÀŠÓÀŠá  ÀŠèÀŠï   ÀŠù‚OÀí/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as a list of pairs of floating point
/// numbers, where each pair represents an x and y offset from the origin.
///
/// The `paint` is used for each point ([PointMode.points]) or line
/// ([PointMode.lines] or [PointMode.polygon]), ignoring [Paint.style].
///
/// See also:
///
///  * [drawPoints], which takes `points` as a [List<Offset>] rather than a
///    [List<Float32List>]. ÀÀ  À'À4  À;ÀB   ÀL†;À“E…»/// Draws a set of [Vertices] onto the canvas as one or more triangles.
///
/// The [Paint.color] property specifies the default color to use for the
/// triangles.
///
/// The [Paint.shader] property, if set, overrides the color entirely,
/// replacing it with the colors from the specified [ImageShader], [Gradient],
/// or other shader.
///
/// The `blendMode` parameter is used to control how the colors in the
/// `vertices` are combined with the colors in the `paint`. If there are no
/// colors specified in `vertices` then the `blendMode` has no effect. If
/// there are colors in the `vertices`, then the color taken from the
/// [Paint.shader] or [Paint.color] in the `paint` is blended with the colors
/// specified in the `vertices` using the `blendMode` parameter. For the
/// purposes of this blending, the colors from the `paint` parameter are
/// considered the source, and the colors from the `vertices` are considered
/// the destination. [BlendMode.dst] ignores the `paint` and uses only the
/// colors of the `vertices`; [BlendMode.src] ignores the colors of the
/// `vertices` and uses only the colors in the `paint`.
///
/// All parameters must not be null.
///
/// See also:
///   * [Vertices.new], which creates a set of vertices to draw on the canvas.
///   * [Vertices.raw], which creates the vertices using typed data lists
///     rather than unencoded lists.
///   * [paint], Image shaders can be used to draw images on a triangular mesh. À“RÀ“\  À“eÀ“p  À“zÀ“   À“‹–•À©+””/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color.
///
/// The method takes a list of [Rect] objects that each define a piece of the
/// [atlas] image to be drawn independently. Each [Rect] is associated with an
/// [RSTransform] entry in the [transforms] list which defines the location,
/// rotation, and (uniform) scale with which to draw that portion of the image.
/// Each [Rect] can also be associated with an optional [Color] which will be
/// composed with the associated image part using the [blendMode] before blending
/// the result onto the canvas. The full operation can be broken down as:
///
/// - Blend each rectangular portion of the image specified by an entry in the
/// [rects] argument with its associated entry in the [colors] list using the
/// [blendMode] argument (if a color is specified). In this part of the operation,
/// the image part will be considered the source of the operation and the associated
/// color will be considered the destination.
/// - Blend the result from the first step onto the canvas using the translation,
/// rotation, and scale properties expressed in the associated entry in the
/// [transforms] list using the properties of the [Paint] object.
///
/// If the first stage of the operation which blends each part of the image with
/// a color is needed, then both the [colors] and [blendMode] arguments must
/// not be null and there must be an entry in the [colors] list for each
/// image part. If that stage is not needed, then the [colors] argument can
/// be either null or an empty list and the [blendMode] argument may also be null.
///
/// The optional [cullRect] argument can provide an estimate of the bounds of the
/// coordinates rendered by all components of the atlas to be compared against
/// the clip to quickly reject the operation if it does not intersect.
///
/// An example usage to render many sprites from a single sprite atlas with no
/// rotations or scales:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center);
///   int index;
///   Offset center;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (final Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: 0.0,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.center.dx,
///           translateY: sprite.center.dy,
///         ),
///     ], <Rect>[
///       for (final Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], null, null, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center, this.alpha, this.rotation);
///   int index;
///   Offset center;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (final Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: sprite.rotation,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.center.dx,
///           translateY: sprite.center.dy,
///         ),
///     ], <Rect>[
///       for (final Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], <Color>[
///       for (final Sprite sprite in allSprites)
///         Colors.white.withAlpha(sprite.alpha),
///     ], BlendMode.srcIn, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// The length of the [transforms] and [rects] lists must be equal and
/// if the [colors] argument is not null then it must either be empty or
/// have the same length as the other two lists.
///
/// See also:
///
///  * [drawRawAtlas], which takes its arguments as typed data lists rather
///    than objects. À©5À©<  À©SÀ©f  À©‚À©  À©¥À©³  À©ËÀ©×  À©òÀ©ù  ÀªÀª   Àª$›ÀÄ4˜ä/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color. It is also more efficient
/// than [drawAtlas] as the data in the arguments is already packed in a format
/// that can be directly used by the rendering code.
///
/// A full description of how this method uses its arguments to draw onto the
/// canvas can be found in the description of the [drawAtlas] method.
///
/// The [rstTransforms] argument is interpreted as a list of four-tuples, with
/// each tuple being ([RSTransform.scos], [RSTransform.ssin],
/// [RSTransform.tx], [RSTransform.ty]).
///
/// The [rects] argument is interpreted as a list of four-tuples, with each
/// tuple being ([Rect.left], [Rect.top], [Rect.right], [Rect.bottom]).
///
/// The [colors] argument, which can be null, is interpreted as a list of
/// 32-bit colors, with the same packing as [Color.value]. If the [colors]
/// argument is not null then the [blendMode] argument must also not be null.
///
/// An example usage to render many sprites from a single sprite atlas with no rotations
/// or scales:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center);
///   int index;
///   Offset center;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     for (int i = 0; i < allSprites.length; i++) {
///       Sprite sprite = allSprites[i];
///       final double rectX = sprite.index * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example sets the RSTransform values directly for a common case of no
///       // rotations or scales and just a translation to position the atlas entry. For
///       // more complicated transforms one could use the RSTransform class to compute
///       // the necessary values or do the same math directly.
///       transformList[i * 4 + 0] = 1.0;
///       transformList[i * 4 + 1] = 0.0;
///       transformList[i * 4 + 2] = sprite.center.dx - 5.0;
///       transformList[i * 4 + 3] = sprite.center.dy - 5.0;
///     }
///     Paint paint = Paint();
///     canvas.drawRawAtlas(spriteAtlas, transformList, rectList, null, null, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center, this.alpha, this.rotation);
///   int index;
///   Offset center;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     Int32List colorList = Int32List(allSprites.length);
///     for (int i = 0; i < allSprites.length; i++) {
///       Sprite sprite = allSprites[i];
///       final double rectX = sprite.index * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example uses an RSTransform object to compute the necessary values for
///       // the transform using a factory helper method because the sprites contain
///       // rotation values which are not trivial to work with. But if the math for the
///       // values falls out from other calculations on the sprites then the values could
///       // possibly be generated directly from the sprite update code.
///       final RSTransform transform = RSTransform.fromComponents(
///         rotation: sprite.rotation,
///         scale: 1.0,
///         // Center of the sprite relative to its rect
///         anchorX: 5.0,
///         anchorY: 5.0,
///         // Location at which to draw the center of the sprite
///         translateX: sprite.center.dx,
///         translateY: sprite.center.dy,
///       );
///       transformList[i * 4 + 0] = transform.scos;
///       transformList[i * 4 + 1] = transform.ssin;
///       transformList[i * 4 + 2] = transform.tx;
///       transformList[i * 4 + 3] = transform.ty;
///
///       // This example computes the color value directly, but one could also compute
///       // an actual Color object and use its Color.value getter for the same result.
///       // Since we are using BlendMode.srcIn, only the alpha component matters for
///       // these colors which makes this a simple shift operation.
///       colorList[i] = sprite.alpha << 24;
///     }
///     Paint paint = Paint();
///     canvas.drawRawAtlas(spriteAtlas, transformList, rectList, colorList, BlendMode.srcIn, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// See also:
///
///  * [drawAtlas], which takes its arguments as objects rather than typed
///    data lists. ÀÄAÀÄH  ÀÄbÀÄo  ÀÄ‘ÀÄ  ÀÄ¸ÀÄÄ  ÀÄßÀÄë  ÀÅ	ÀÅ  ÀÅ-ÀÅ4   ÀÅ>8ÀÆ'€×/// Draws a shadow for a [Path] representing the given material elevation.
///
/// The `transparentOccluder` argument should be true if the occluding object
/// is not opaque.
///
/// The arguments must not be null. ÀÆ2	ÀÆ8  ÀÆ=ÀÆD  ÀÆJÀÆR  ÀÆ\ÀÆb    ÀÆzÀ KüÀÆ…  ÀÆÊ“ ÀÆÊÀÆ× ÀÆØÀÆé  ÀÆôÀÆû   ÀÊ>!ÀÊV   DÀÈa€ÜÀÈÙ  ÀÈæÀÈş  ÀÉÀÉ  ÀÉ
ÀÉ  ÀÉ ÀÉ(  ÀÉ.ÀÉ6  ÀÈaÀÈbÀÈhÀÈ­ÀÈnÀÈiÀÈvÀÈ¬ÀÈwÀÈÀÈ†ÀÈ‹ÀÈ‡ÀÈÀÈ–ÀÈÀÈ¦ÀÈ®ÀÈÇÀÈµÀÈ¯ÀÈ·ÀÊdoÀÊÌ   ÀÊdÀÊeÀÊpÀÊqÀÊwÀÊ”ÀÊ}ÀÊxÀÊ…ÀÊ“ÀÊ†ÀÊÀÊ’ÀÊÀÊ•ÀÊºÀÊœÀÊ–ÀÊÀÊ´ÀÊ®ÀÊ¶ÀÊ×ÀÊã  ÀÊë	ÀÊñ   ÀË÷-ÀÌ  ÀÌÀÌ  ÀÌ ÀÌ'  ÀË÷ÀËøÀÍ(€¹ÀÍ˜  ÀÍ°ÀÍÀ  ÀÍÍÀÍ×  ÀÍ(ÀÍ)ÀÍ/ÀÍ\ÀÍ5ÀÍ0ÀÍ=ÀÍ[ÀÍ>ÀÍEÀÍJÀÍFÀÍMÀÍUÀÍ]ÀÍ†ÀÍdÀÍ^ÀÍfÀÍå€õÀÎh  ÀÎsÀÎ{  ÀÎ€
ÀÎˆ  ÀÎŒÀÎ”  ÀÎšÀÎ¢  ÀÎ©ÀÎ¹  ÀÎÆÀÎĞ  ÀÍåÀÍæÀÍìÀÎ9ÀÍòÀÍíÀÍúÀÎ8ÀÍûÀÎÀÎÀÎÀÎ
ÀÎÀÎÀÎ"ÀÎ*ÀÎ2ÀÎ:ÀÎVÀÎAÀÎ;ÀÎCÀÎŞuÀÏI   ÀÎŞÀÎßÀÎêÀÎëÀÎñÀÏÀÎ÷ÀÎòÀÎÿÀÏÀÏ ÀÏÀÏÀÏÀÏÀÏ7ÀÏÀÏÀÏÀÏ1ÀÏ+ÀÏ3ÀÏW€“ÀÏĞ  ÀÏß	ÀÏä  ÀÏWÀÏXÀÏcÀÏdÀÏjÀÏÀÏpÀÏkÀÏxÀÏÀÏyÀÏ€ÀÏ…ÀÏÀÏˆÀÏÀÏ¾ÀÏ–ÀÏÀÏ˜ÀÏ¸ÀÏ²ÀÏºÀÏîÀĞ^   ÀÏîÀÏïÀÏúÀÏûÀĞÀĞÀĞÀĞÀĞÀĞÀĞÀĞÀĞÀĞÀĞ ÀĞMÀĞ'ÀĞ!ÀĞ)ÀĞGÀĞAÀĞIÀĞq€ÀĞî  ÀĞø	ÀÑ   ÀÑ	ÀÑ  ÀĞqÀĞrÀĞ}ÀĞ~ÀĞ„ÀĞ±ÀĞŠÀĞ…ÀĞ’ÀĞ°ÀĞ“ÀĞšÀĞŸÀĞ›ÀĞ¢ÀĞªÀĞ²ÀĞÜÀĞ¹ÀĞ³ÀĞ»ÀĞÖÀĞĞÀĞØÀÑHÀÑ#  ÀÑ)	ÀÑ1  ÀÑ5
ÀÑ>  ÀÑÀÑÀÑ^€ŠÀÑË  ÀÑÒ	ÀÑÚ  ÀÑİ	ÀÑå  ÀÑ^ÀÑ_ÀÑeÀÑ’ÀÑkÀÑfÀÑsÀÑ‘ÀÑtÀÑ{ÀÑ€ÀÑ|ÀÑƒÀÑ‹ÀÑ“ÀÑ¹ÀÑšÀÑ”ÀÑœÀÑ³ÀÑ­ÀÑµÀÑì€‰ÀÒ^  ÀÒeÀÒm  ÀÑìÀÑíÀÑøÀÑùÀÑÿÀÒ$ÀÒÀÒ ÀÒÀÒ#ÀÒÀÒÀÒÀÒÀÒÀÒ%ÀÒLÀÒ,ÀÒ&ÀÒ.ÀÒFÀÒ@ÀÒHÀÒy€“ÀÒñ  ÀÒö	ÀÒş  ÀÓ	ÀÓ	  ÀÒyÀÒzÀÒ…ÀÒ†ÀÒŒÀÒ¹ÀÒ’ÀÒÀÒšÀÒ¸ÀÒ›ÀÒ¢ÀÒ§ÀÒ£ÀÒªÀÒ²ÀÒºÀÒßÀÒÁÀÒ»ÀÒÃÀÒÙÀÒÓÀÒÛÀÓ€²ÀÓ!  ÀÓ+ÀÓ8  ÀÓÀÓÀÓÆ{ÀÔ!  ÀÔ,ÀÔ9  ÀÓÆÀÓÇÀÓÍÀÓòÀÓÓÀÓÎÀÓÛÀÓñÀÓÜÀÓãÀÓèÀÓäÀÓëÀÓóÀÔÀÓúÀÓôÀÓüÀÔE€ÀÔ]   ÀÔEÀÔFÀÔÖ€ÀÕ4  ÀÕBÀÕO  ÀÔÖÀÔ×ÀÔİÀÕÀÔãÀÔŞÀÔëÀÕÀÔìÀÔóÀÔøÀÔôÀÔûÀÕÀÕ"ÀÕ
ÀÕÀÕÀÕ[ØÀÕl  ÀÕu	ÀÕ{  ÀÕ‚ ÀÕŠ  ÀÕ¤ÀÕª  ÀÕ[ÀÕ\ÀÕ’ÀÕ˜ÀÕ™ÀÕ·À×7€ëÀ×Ä  À×ÎÀ×Ö  À×Û
À×ã  À×çÀ×ï  À×õÀ×ı  ÀØ
ÀØ	  ÀØÀØ  À×7À×8À×>À×ˆÀ×DÀ×?À×LÀ×‡À×MÀ×TÀ×YÀ×UÀ×\À×dÀ×lÀ×tÀ×|À×ƒÀ×‰À×²À×À×ŠÀ×’À×¬À×¦À×®ÀØ&€œÀØ7  ÀØAÀØH  ÀØOÀØU  ÀØ&ÀØ'ÀØbÀØÆ€‘ÀÙ'  ÀÙ2ÀÙ?  ÀÙEÀÙK  ÀØÆÀØÇÀØÍÀØøÀØÓÀØÎÀØÛÀØ÷ÀØÜÀØãÀØèÀØäÀØëÀØóÀØùÀÙÀÙ ÀØúÀÙÀÙ[vÀÙl  ÀÙu	ÀÙ{  ÀÙÀÙ‡  ÀÙ[ÀÙ\ÀÙ”ÀÙÕ€•ÀÚ<  ÀÚFÀÚS  ÀÚXÀÚ^  ÀÙÕÀÙÖÀÙÜÀÚÀÙâÀÙİÀÙêÀÚÀÙëÀÙòÀÙ÷ÀÙóÀÙúÀÚÀÚÀÚÀÚ	ÀÚÀÚ*ÀÚÀÚÀÚÀÚn€ÁÀÚ   ÀÚnÀÚoÀÛ3€ŒÀÛ—  ÀÛ«ÀÛ¸  ÀÛ3ÀÛ4ÀÛ:ÀÛ_ÀÛ@ÀÛ;ÀÛHÀÛ^ÀÛIÀÛPÀÛUÀÛQÀÛXÀÛ`ÀÛ…ÀÛgÀÛaÀÛiÀÛÃ€ÍÀÛÔ   ÀÛÃÀÛÄÀÜ”€˜ÀÜş  ÀİÀİ%  ÀÜ”ÀÜ•ÀÜ›ÀÜÀÀÜ¡ÀÜœÀÜ©ÀÜ¿ÀÜªÀÜ±ÀÜ¶ÀÜ²ÀÜ¹ÀÜÁÀÜìÀÜÈÀÜÂÀÜÊÀİ0pÀİA  ÀİKÀİR  ÀİXÀİc  Àİ0Àİ1Àİ¤€•ÀŞ  ÀŞ	ÀŞ$  ÀŞ*ÀŞ/  Àİ¤Àİ¥Àİ«Àİ×Àİ±Àİ¬Àİ¹ÀİÖÀİºÀİÁÀİÆÀİÂÀİÉÀİÑÀİØÀŞÀİßÀİÙÀİáÀİüÀİöÀİşÀŞ=€ÊÀŞN  ÀŞW	ÀŞ_  ÀŞb	ÀŞj  ÀŞmÀŞt  ÀŞ=ÀŞ>Àß€éÀß  Àß—	ÀßŸ  Àß¢	Àßª  Àß­	Àßµ  Àß¸	ÀßÀ  ÀßÃÀßÓ  ÀßàÀßê  ÀßÀßÀßÀß_ÀßÀßÀß Àß^Àß!Àß(Àß-Àß)Àß0Àß8Àß@ÀßHÀßPÀßXÀß`Àß{ÀßgÀßaÀßiÀßøZÀà	  ÀàÀà  ÀßøÀßùÀàV€ŸÀà¹  ÀàÄÀàÔ  ÀàáÀàë  ÀàVÀàWÀà]ÀàŠÀàcÀà^ÀàkÀà‰ÀàlÀàsÀàxÀàtÀà{ÀàƒÀà‹Àà§Àà’ÀàŒÀà”ÀàùÀá
  Àá	Àá  ÀáÀá%  ÀàùÀàúÀâ€óÀâ  ÀâšÀâ¢  Àâ§
Àâ¯  Àâ³Àâ»  ÀâÁÀâÉ  ÀâĞÀâà  ÀâíÀâ÷  ÀâÀâÀâÀâbÀâÀâÀâ#ÀâaÀâ$Àâ+Àâ0Àâ,Àâ3Àâ;ÀâCÀâKÀâSÀâ[ÀâcÀâ~ÀâjÀâdÀâlÀã€Àã  Àã Àã'  Àã-Àã4  ÀãÀãÀã§€ºÀä  ÀäÀä*  Àä0Àä@  ÀäMÀäW  Àã§Àã¨Àã®ÀããÀã´Àã¯Àã¼ÀãâÀã½ÀãÄÀãÉÀãÅÀãÌÀãÔÀãÜÀãäÀä ÀãëÀãåÀãíÀäe€äÀäv  ÀäÀäˆ  ÀäÀä•  Àä›Àä¢  ÀäeÀäfÀåM€×ÀåÁ  ÀåÍÀåÚ  ÀåàÀåí  ÀåóÀæ  ÀæÀæ  ÀåMÀåNÀåTÀå‘ÀåZÀåUÀåbÀåÀåcÀåjÀåoÀåkÀårÀåzÀå‚ÀåŠÀå’Àå¯Àå™Àå“Àå›Àæ(Àæ9  ÀæB	ÀæH  ÀæMÀæT  Àæ(Àæ)Àç=€óÀç¿  ÀçÉÀçÑ  ÀçÖ
ÀçŞ  ÀçâÀçê  ÀçğÀçø  ÀçÿÀè  ÀèÀè&  Àç=Àç>ÀçDÀç‘ÀçJÀçEÀçRÀçÀçSÀçZÀç_Àç[ÀçbÀçjÀçrÀçzÀç‚ÀçŠÀç’Àç­Àç™Àç“Àç›Àè4€¨ÀèE  ÀèPÀèX  ÀèZÀèb  ÀèiÀèp  Àè4Àè5Àèà€ÜÀé\  ÀéhÀép  ÀérÀéz  Àé|Àé„  Àé‹Àé›  Àé¨Àé²  ÀèàÀèáÀèçÀé,ÀèíÀèèÀèõÀé+ÀèöÀèıÀéÀèşÀéÀéÀéÀéÀé%Àé-ÀéJÀé4Àé.Àé6ÀéÀÀéÑ  ÀéÙ	Àéß  ÀéäÀéì  Àé÷Àéÿ  Àê
Àê  ÀêÀê!  ÀéÀÀéÁÀêÌtÀëc  	ÀësÀë{  Àë†
Àë  Àë˜Àë   Àë¬Àë´  ÀëÁÀëÉ  ÀëÚÀëâ  ÀëóÀëù  Àì	Àì  Àì,Àì6  ÀêÌÀêÍÀêÓÀë6ÀêÙÀêÔÀêáÀë5ÀêâÀêéÀêîÀêêÀêñÀêùÀëÀë	ÀëÀëÀë!Àë'Àë/Àë7ÀëQÀë>Àë8Àë@ÀìDxÀìU  Àì^	Àìd  ÀìiÀìp  ÀìDÀìEÀìÀ€¾Àí1  Àí;ÀíH  ÀíMÀí]  ÀíjÀít  ÀìÀÀìÁÀìÇÀíÀìÍÀìÈÀìÕÀíÀìÖÀìİÀìâÀìŞÀìåÀììÀìñÀìíÀìôÀìüÀíÀíÀíÀíÀíÀí‚~Àí“  ÀíÀí¤  ÀíªÀí²  Àí¹ÀíÀ  Àí‚ÀíƒÀïÀï’  ÀïÀï¥  Àï«Àï³  ÀïµÀï½  Àï¿ÀïÏ  ÀïÜÀïæ  ÀïğÀïõ  ÀïÀïÀïÀï`ÀïÀïÀïÀï_ÀïÀï#Àï(Àï$Àï+Àï2Àï7Àï3Àï:ÀïBÀïJÀïRÀïZÀïaÀï}ÀïhÀïbÀïjÀğƒ¦Àğ  Àğ+Àğ2  Àğ8Àğ>  ÀğBÀğH  ÀğLÀğS  ÀğÀğÀó¶õÀôx  ÀôÀô–  Àô¢Àôª  Àô¸ÀôÀ  ÀôÍÀôÕ  ÀôäÀôì  ÀôüÀõ  ÀõÀõ  Àõ'Àõ/  Àõ>ÀõF  ÀõVÀõf  ÀõyÀõƒ  Àõ“Àõ˜   Àó¶Àó·Àó½ÀôBÀóÅÀó¾ÀóÍÀôAÀóÎÀóÕÀóÚÀóÖÀóİÀóäÀóéÀóåÀóìÀóôÀóüÀôÀôÀôÀôÀô$Àô,Àô4Àô<ÀôCÀôcÀôJÀôDÀôLÀõ¯ƒ¸ÀõÀ  ÀõÎÀõÕ  ÀõÛÀõá  ÀõèÀõî  ÀõòÀõù  Àõ¯Àõ°Àùk‚Àú-  ÀúCÀúK  ÀúWÀú_  ÀúpÀúx  ÀúˆÀú  Àú¢Àúª  Àú½ÀúÅ  ÀúÓÀúÛ  ÀúèÀúğ  ÀúÿÀû  ÀûÀû'  Àû:ÀûD  ÀûTÀûY   ÀùkÀùlÀùrÀù÷ÀùzÀùsÀù‚ÀùöÀùƒÀùŠÀùÀù‹Àù’Àù™ÀùÀùšÀù¡Àù©Àù±Àù¹ÀùÁÀùÉÀùÑÀùÙÀùáÀùéÀùñÀùøÀúÀùÿÀùùÀúÀûp€„Àû  ÀûÀû–  ÀûpÀûqÀûø€‰Àü\  ÀüiÀüy  ÀûøÀûùÀûÿÀü+ÀüÀü ÀüÀü*ÀüÀüÀüÀüÀüÀü$Àü)Àü%Àü,ÀüJÀü3Àü-Àü5Àü…GÀü–  Àü¤Àü¯  Àü¹ÀüÁ  Àü…Àü†ÀıĞ€±Àıá  ÀıìÀı÷  ÀşÀş  ÀşÀş  ÀıĞÀıÑÀş…Àş–  Àş¤Àş¯  Àş¹ÀşÆ  ÀşÍÀşÔ  Àş…Àş†Àÿ€ÓÀ   À À ,  À 9À C  À MÀ R  À \À i  ÀÿÀÿÀÿ¤ÀÿàÀÿªÀÿ¥Àÿ²ÀÿßÀÿ³ÀÿºÀÿ¿Àÿ»ÀÿÂÀÿÊÀÿÒÀÿÙÀÿáÀÿşÀÿèÀÿâÀÿêÀ t€ÈÀ …  À ’À œ  À ¥À °  À ºÀ Á  À tÀ uÀ@€İÀ¼  ÀÊÀÔ  ÀİÀâ  ÀìÀü  À	À  À@ÀAÀGÀŠÀMÀHÀUÀ‰ÀVÀ]ÀbÀ^ÀeÀlÀqÀmÀtÀ{ÀƒÀ‹ÀªÀ’ÀŒÀ”À!ˆ"À2  À<ÀC  ÀZÀm  À‰À•  À¬Àº  ÀÒÀŞ  ÀùÀ   ÀÀ!  À!À"À
G„§À
X  À
eÀ
l  À
†À
“  À
µÀ
Â  À
ÜÀ
è  ÀÀ  À-À4  ÀQÀX  À
GÀ
HÀò¥À—  	À©À¹  ÀÌÀÖ  ÀæÀë  ÀÀ  ÀÀ%  À9ÀF  ÀRÀ^  ÀkÀp  À€À  ÀòÀóÀùÀeÀÀúÀ	ÀdÀ
ÀÀÀÀÀ!À)À0À7À<À8À?ÀGÀOÀWÀ^ÀfÀ‚ÀmÀgÀoÀ›€¸À¬  À·	À½  ÀÂÀÉ  ÀÏÀ×  ÀáÀç  À›ÀœÀW€ÎÀĞ  ÀÜÀé  Àî	Àó  ÀùÀ  ÀÀ  ÀWÀXÀ^À ÀdÀ_ÀlÀŸÀmÀtÀyÀuÀ|ÀƒÀˆÀ„À‹À“À›À¡À¾À¨À¢ÀªÀ)KÀ<   À)À* ÀæŠ¸ÀDN/// An object representing a sequence of recorded graphical operations.
///
/// To create a [Picture], use a [PictureRecorder].
///
/// A [Picture] can be placed in a [Scene] using a [SceneBuilder], via
/// the [SceneBuilder.addPicture] method. A [Picture] can also be
/// drawn into a [Canvas], using the [Canvas.drawPicture] method.  ÀPÀ`€è/// A callback that is invoked to report a picture creation.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onCreate] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀmÀ€€ë/// A callback that is invoked to report the picture disposal.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onDispose] directly because [MemoryAllocations]
/// allows multiple callbacks. Àâ€ÇÀ›€§/// Whether this reference to the underlying picture is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   À­€ïÀ‡€É/// Returns the approximate number of bytes allocated for this object.
///
/// The actual size of this picture may be larger, particularly if it contains
/// references to image or other large objects.   ÀDÀ³/// Creates an image from this picture.
///
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped. À»	ÀÀ  ÀÆ
ÀË   ÀÖƒ‚À5ƒ6/// Synchronously creates a handle to an image of this picture.
///
/// {@template dart.ui.painting.Picture.toImageSync}
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped.
///
/// The image object is created and returned synchronously, but is rasterized
/// asynchronously. If the rasterization fails, an exception will be thrown
/// when the image is drawn to a [Canvas].
///
/// If a GPU context is available, this image will be created as GPU resident
/// and not copied back to the host. This means the image will be more
/// efficient to draw.
///
/// If no GPU context is available, the image will be rasterized on the CPU.
/// {@endtemplate} ÀA	ÀF  ÀL
ÀQ   À\€‚ÀÔn/// Release the resources used by this object. The object is no longer usable
/// after this method is called.    À ˆºÀ«  Àò€µÀ¢À£À¤€™/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To create a [Picture], use a [PictureRecorder].  À$…À$Š À$–À$ €õÀ$µ   À$ À$¡À%™€À&   À%™À%šÀ%¥À%¦À%¬À%ËÀ%´À%­À%¼À%ÊÀ%½À%ÄÀ%ÉÀ%ÅÀ%ÌÀ%ÿÀ%ÓÀ%ÍÀ%ÕÀ%ùÀ%óÀ%ûÀ«½ÀÅ  ÀÍ	ÀÒ  ÀØ
Àİ  À«À¬À l€°À Û  À ä	À é  À ï
À ô  À ûÀ!  À lÀ mÀ sÀ ªÀ {À tÀ ƒÀ ©À „À ‹À À ŒÀ “À ›À £À «À ÆÀ ²À ¬À ´À! 5À!2  À!>	À!C  À!I
À!N  À! À!!À"Y€£À"Ç  À"Ô	À"Ù  À"ß
À"ä  À"ëÀ"ó  À"YÀ"ZÀ"`À"•À"fÀ"aÀ"nÀ"”À"oÀ"vÀ"{À"wÀ"~À"†À"À"–À"µÀ"À"—À"ŸÀ# €°À#   À# À#À#´€ÍÀ$vk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À$$À$%À$+À$HÀ$1À$,À$9À$GÀ$:À$AÀ$FÀ$BÀ$IÀ$dÀ$PÀ$JÀ$RÀ&-+À&@   À&-À&. À&\‡UÀ)÷ƒ‹/// Records a [Picture] containing a sequence of graphical operations.
///
/// To begin recording, construct a [Canvas] to record the commands.
/// To end recording, use the [PictureRecorder.endRecording] method.
///
/// ## Use with the Flutter framework
///
/// The Flutter framework's [RendererBinding] provides a hook for creating
/// [PictureRecorder] objects ([RendererBinding.createPictureRecorder]) that
/// allows tests to hook into the scene creation logic. When creating a
/// [PictureRecorder] and [Canvas] that will be used with a [PictureLayer] as
/// part of the [Scene] in the context of the Flutter framework, consider
/// calling [RendererBinding.createPictureRecorder] instead of calling the
/// [PictureRecorder.new] constructor directly.
///
/// This does not apply when using a canvas to generate a bitmap for other
/// purposes, e.g. for generating a PNG image using [Picture.toImage]. À*€× À*·À*Æ€/// Creates a new idle PictureRecorder. To associate it with a
/// [Canvas] and begin recording, pass this [PictureRecorder] to the
/// [Canvas] constructor.   À*æ™À,su/// Whether this object is currently recording commands.
///
/// Specifically, this returns true if a [Canvas] object has been
/// created to record commands and recording has not yet ended via a
/// call to [endRecording], and false if either this
/// [PictureRecorder] has not yet been associated with a [Canvas],
/// or the [endRecording] method has already been called.   À,ƒ,À- 
/// Finishes recording graphical operations.
///
/// Returns a picture containing the graphical operations that have been
/// recorded thus far. After calling this function, both the picture recorder
/// and the canvas objects are invalid and cannot be used further.    À-³„À-¾  À., À.À.+   À1`À1o  À.ª4À.¿   À.ªÀ.«À.EaÀ.—   À.EÀ.FÀ.LÀ.bÀ.RÀ.MÀ.ZÀ.aÀ.[À.cÀ.…À.jÀ.dÀ.lÀ.âæÀ.ö   À.âÀ.ãÀ0Ì€À13  À1AÀ1Q  À0ÌÀ0ÍÀ0ÓÀ0øÀ0ÙÀ0ÔÀ0áÀ0÷À0âÀ0éÀ0îÀ0êÀ0ñÀ0ùÀ1!À1 À0úÀ1À1{LÀ1   À1{À1| À1Ë›À2&T/// A single shadow.
///
/// Multiple shadows are stacked together in a [TextStyle]. À21‚P À3¼À3Âp/// Construct a shadow.
///
/// The default shadow is a black shadow with zero offset and zero blur.
/// Default shadows should be completely covered by the casting element,
/// and not be visible.
///
/// Transparency should be adjusted through the [color] alpha.
///
/// Shadow order matters due to compositing multiple translucent objects not
/// being commutative.À3É(À3Ï  À3÷À3ı  À4À4  À3ÖÀ3ÜÀ3áÀ3ğÀ3âÀ4À4À4À4(À44À4:À4LÀ4À4FÀ4;À4IÀ4N	À4…,À4– À4§À4Ù&À4ê À4ıÀ5'À5 À5&À5$À5)À5.#À5? À5MÀ5KÀ5PÀ5U#À5f À5tÀ5rÀ5wÀ5|&À5 À5À5œÀ5¡À5§€¼À6^€¢/// Color that the shadow will be drawn with.
///
/// The shadows are shapes composited directly over the base canvas, and do not
/// represent optical occlusion. À6h4À7–/// The displacement of the shadow from the casting element.
///
/// Positive x/y offsets will shift the shadow to the right and down, while
/// negative offsets shift the shadow to the left and up. The offsets are
/// relative to the position of the element that is casting it. À7¡iÀ8 O/// The standard deviation of the Gaussian to convolve with the shadow's shape. À9€®À:n/// The [blurRadius] in sigmas instead of logical pixels.
///
/// See the sigma argument to [MaskFilter.blur].   ÀG¦GÀGº   ÀG¦ÀG§À8|À9.h/// Converts a blur radius in pixels to sigmas.
///
/// See the sigma argument to [MaskFilter.blur].
/// À9CÀ9K   À:A‚‹À<Qõ/// Create the [Paint] object that corresponds to this shadow description.
///
/// The [offset] is not represented in the [Paint] object.
/// To honor this as well, the shape should be translated by [offset] before
/// being filled using this [Paint].
///
/// This class does not provide a way to disable shadows to avoid
/// inconsistencies in shadow blur rendering, primarily as a method of
/// reducing test flakiness. [toPaint] should be overridden in subclasses to
/// provide this functionality.   À<Ğ€õÀ=7[/// Returns a new shadow with its [offset] and [blurRadius] scaled by the given
/// factor. À==À=E   À=É…×ÀAÓƒÔ/// Linearly interpolate between two shadows.
///
/// If either shadow is null, this function linearly interpolates from
/// a shadow that matches the other shadow in color but has a zero
/// offset and a zero blurRadius.
///
/// {@template dart.ui.shadow.lerp}
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]).
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController].
/// {@endtemplate} ÀAØ	ÀAá  ÀAã	ÀAì  ÀAîÀAö   ÀC¤ƒÀDi€¥/// Linearly interpolate between two lists of shadows.
///
/// If the lists differ in length, excess items are lerped with null.
///
/// {@macro dart.ui.shadow.lerp} ÀDrÀD  ÀDƒÀD’  ÀD”ÀDœ   ÀF¯€óÀFÉ  ÀFÌÀFÔ  ÀF¯ÀF°ÀH«ƒÓÀH»  ÀHÊÀHÙ   ÀL‚LÀL•   ÀL‚ÀLƒ ÀLÒÌÀM€¯/// A handle to a read-only byte buffer that is managed by the engine.
///
/// The creator of this object is responsible for calling [dispose] when it is
/// no longer needed. ÀMÂ ÀMÑÀMÒÀMÓ ÀMÔÀMÚ   ÀVÕÀVÙ  ÀVåÀVê ÀVûÀV„NÀVÀ1/// The length, in bytes, of the underlying data.   ÀWÀWy/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   ÀMægÀNh^/// Creates a copy of the data from a [Uint8List] suitable for internal use
/// in the engine. ÀNvÀN   ÀOQƒGÀOér/// Create a buffer from the asset with key [assetKey].
///
/// Throws an [Exception] if the asset does not exist. ÀOóÀOû   ÀRœ÷ÀS+i/// Create a buffer from the file with [path].
///
/// Throws an [Exception] if the asset does not exist. ÀS8ÀS@   ÀT—€•ÀTü  ÀUÀU  ÀUÀU#  ÀT—ÀT˜ÀTÀTÆÀT¦ÀTŸÀT®ÀTÅÀT¯ÀT·ÀT¿ÀTÇÀTçÀTÎÀTÈÀTĞÀU0€§ÀU  ÀU­ÀUµ  ÀU¾ÀUÎ  ÀU0ÀU1ÀU7ÀU_ÀU?ÀU8ÀUGÀU^ÀUHÀUPÀUXÀU`ÀU‰ÀUgÀUaÀUiÀUÛ€¥ÀVH  ÀVVÀV^  ÀVgÀVw  ÀUÛÀUÜÀUâÀV
ÀUêÀUãÀUòÀV	ÀUóÀUûÀVÀVÀV3ÀVÀVÀVÀX ‚£ÀZ;‚/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, an [ImageDescriptor] that has not been disposed
/// may still retain a reference to the memory from this buffer even if it
/// has been disposed. Freeing that memory requires disposing all resources
/// that may still hold it.   ÀZÇ€ÕÀ[‘k/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À[7À[8À[>À[[À[DÀ[?À[LÀ[ZÀ[MÀ[TÀ[YÀ[UÀ[\À[À[cÀ[]À[e À[ ‰‰À\e€µ/// A descriptor of data that can be turned into an [Image] via a [Codec].
///
/// Use this class to determine the height, width, and byte size of image data
/// before decoding it. À\y‚çÀ^°À^±À^´Ğ/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `pixelFormat`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.À^ºÀ^Ë  À^ØÀ^æ  À^ğÀ^ş  À_	À_  À_ À_2    À`ËyÀa>d/// The width, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   ÀaH{Àa¼e/// The height, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   ÀaÇ€…Àb>h/// The number of bytes per pixel in the image.
///
/// On web, this is only supported for [raw] images.   À_dcÀ_ÎH/// Creates an image descriptor from encoded data in a supported format. À_ÖÀ_ç   ÀbP€øÀc>€Ş/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).   ÀcLÛÀdï‚/// Creates a [Codec] object which is suitable for decoding the data in the
/// buffer to an [Image].
///
/// If only one of targetWidth or  targetHeight are specified, the other
/// dimension will be scaled according to the aspect ratio of the supplied
/// dimension.
///
/// If either targetWidth or targetHeight is less than or equal to zero, it
/// will be treated as if it is null. ÀeÀe  ÀeÀe    Àe+<Àe6  ÀeÀe£Àe¤Àe¥   Àe¬ƒ£ÀgâÀgãÀgæĞ/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `pixelFormat`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.ÀgìÀgı  Àh
Àh  Àh"Àh0  Àh;ÀhA  ÀhN Àhd   ÀkÀk  Àk¿ÀkÄ  ÀlƒÀlˆ  Àk‡4Àk›   Àk‡ÀkˆÀlH7Àl\   ÀlHÀlIÀm!LÀm5   Àm!Àm"	ÀiS€²ÀiÆ  ÀiÓÀiä  ÀiëÀiü  ÀiSÀiTÀiZÀi‰ÀibÀi[ÀijÀiˆÀikÀisÀizÀiÀi{Ài‚ÀiŠÀi±Ài‘Ài‹Ài“Àj	€ôÀj‡  ÀjÀj¡  Àj¯ÀjÀ  ÀjÇ	ÀjÌ  ÀjÒ
Àj×  ÀjŞÀjã  ÀjìÀjñ  Àj	Àj
ÀjÀjJÀjÀjÀjÀjIÀjÀj'Àj/Àj6Àj=ÀjDÀjKÀjnÀjRÀjLÀjTÀkrÀkw   ÀkÀkÀkÀk6ÀkÀkÀk'Àk5Àk(Àk/Àk4Àk0Àk7ÀkfÀk>Àk8Àk@Àk`ÀkZÀkbÀkĞtÀl7   ÀkĞÀkÑÀk×ÀkõÀkŞÀkØÀkæÀkôÀkçÀkîÀkóÀkïÀköÀl&ÀkıÀk÷ÀkÿÀl ÀlÀl"Àl›€‚Àm	   Àl›ÀlœÀl¢ÀlÀÀl©Àl£Àl±Àl¿Àl²Àl¹Àl¾ÀlºÀlÁÀløÀlÈÀlÂÀlÊÀlòÀlìÀlôÀmqpÀm×   ÀmqÀmrÀm}Àm~Àm„Àm¡ÀmŠÀm…Àm’Àm Àm“ÀmšÀmŸÀm›Àm¢ÀmÅÀm©Àm£Àm«Àmåƒ(Àmÿ  ÀnÀn  Àn#Àn)  ÀmåÀmæÀq€¾ÀqŠ  ÀqœÀq£  Àq¬Àq±  Àq½ÀqÂ  ÀqÀqÀqÀqKÀqÀqÀq&ÀqJÀq'Àq.Àq3Àq/Àq6Àq>ÀqEÀqLÀqxÀqSÀqMÀqUÀqÓ€’Àqæ   ÀqÓÀqÔ À~ZƒùÀÖu/// An exception thrown by [Canvas.drawImage] and related methods when drawing
/// an [Image] created via [Picture.toImageSync] that is in an invalid state.
///
/// This exception may be thrown if the requested image dimensions exceeded the
/// maximum 2D texture size allowed by the GPU, or if no GPU surface or context
/// was available for rasterization at request time. À€BÀ€0À€1À€2 À€3À€9  À€B
À€H   À€SIÀ€•2/// A string containing details about the failure. À€¡iÀO/// If available, the stack trace at the time [Picture.toImageSync] was called.  ÀBÀ"   ÀÀ  ¿­À OùÀ JÈ‹/// Algorithms to use when painting on the canvas.
///
/// When drawing a shape or image onto a canvas, different algorithms can be
/// used to blend the pixels. The different values of [BlendMode] specify
/// different such algorithms.
///
/// Each algorithm has two inputs, the _source_, which is the image being drawn,
/// and the _destination_, which is the image into which the source image is
/// being composited. The destination is often thought of as the _background_.
/// The source and destination both have four color channels, the red, green,
/// blue, and alpha channels. These are typically represented as numbers in the
/// range 0.0 to 1.0. The output of the algorithm also has these same four
/// channels, with values computed from the source and destination.
///
/// The documentation of each value below describes how the algorithm works. In
/// each case, an image shows the output of blending a source image with a
/// destination image. In the images below, the destination is represented by an
/// image with horizontal lines and an opaque landscape photograph, and the
/// source is represented by an image with vertical lines (the same lines but
/// rotated) and a bird clip-art image. The [src] mode shows only the source
/// image, and the [dst] mode shows only the destination image. In the
/// documentation below, the transparency is illustrated by a checkerboard
/// pattern. The [clear] mode drops both the source and destination, resulting
/// in an output that is entirely transparent (illustrated by a solid
/// checkerboard pattern).
///
/// The horizontal and vertical bars in these images show the red, green, and
/// blue channels with varying opacity levels, then all three color channels
/// together with those same varying opacity levels, then all three color
/// channels set to zero with those varying opacity levels, then two bars showing
/// a red/green/blue repeating gradient, the first with full opacity and the
/// second with partial opacity, and finally a bar with the three color channels
/// set to zero but the opacity varying in a repeating gradient.
///
/// ## Application to the [Canvas] API
///
/// When using [Canvas.saveLayer] and [Canvas.restore], the blend mode of the
/// [Paint] given to the [Canvas.saveLayer] will be applied when
/// [Canvas.restore] is called. Each call to [Canvas.saveLayer] introduces a new
/// layer onto which shapes and images are painted; when [Canvas.restore] is
/// called, that layer is then composited onto the parent layer, with the source
/// being the most-recently-drawn shapes and images, and the destination being
/// the parent layer. (For the first [Canvas.saveLayer] call, the parent layer
/// is the canvas itself.)
///
/// See also:
///
///  * [Paint.blendMode], which uses [BlendMode] to define the compositing
///    strategy.  À K€îÀ Lh€Ş/// Drop both the source and destination images, leaving nothing.
///
/// This corresponds to the "clear" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_clear.png) À LrHÀ M·4/// Drop the destination image, only paint the source image.
///
/// Conceptually, the destination is first cleared, then the source image is
/// painted.
///
/// This corresponds to the "Copy" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_src.png) À M¿MÀ O	9/// Drop the source image, only paint the destination image.
///
/// Conceptually, the source image is discarded, leaving the destination
/// untouched.
///
/// This corresponds to the "Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dst.png) À OìÀ PöĞ/// Composite the source image over the destination image.
///
/// This is the default value. It represents the most intuitive case, where
/// shapes are painted on top of what is below, with transparent areas showing
/// the destination layer.
///
/// This corresponds to the "Source over Destination" Porter-Duff operator,
/// also known as the Painter's Algorithm.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOver.png) À Q­À R¨‘/// Composite the source image under the destination image.
///
/// This is the opposite of [srcOver].
///
/// This corresponds to the "Destination over Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOver.png)
///
/// This is useful when the source image should have been painted before the
/// destination image, but could not be. À R´‚šÀ UI‚x/// Show the source image, but only where the two images overlap. The
/// destination image is not rendered, it is treated merely as a mask. The
/// color channels of the destination are ignored, only the opacity has an
/// effect.
///
/// To show the destination image instead, consider [dstIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is absent, rather than where it is present), consider
/// [srcOut].
///
/// This corresponds to the "Source in Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcIn.png) À US‚„À WÒ‚f/// Show the destination image, but only where the two images overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [dstOut].
///
/// This corresponds to the "Destination in Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstIn.png) À WÜ‚˜À Zn‚y/// Show the source image, but only where the two images do not overlap. The
/// destination image is not rendered, it is treated merely as a mask. The color
/// channels of the destination are ignored, only the opacity has an effect.
///
/// To show the destination image instead, consider [dstOut].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [srcIn].
///
/// This corresponds to the "Source out Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOut.png) À Zy‚À ]‚o/// Show the destination image, but only where the two images do not overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcOut].
///
/// To reverse the semantic of the mask (only showing the destination where the
/// source is present, rather than where it is absent), consider [dstIn].
///
/// This corresponds to the "Destination out Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOut.png) À ]‚gÀ _l‚E/// Composite the source image over the destination image, but only where it
/// overlaps the destination.
///
/// This corresponds to the "Source atop Destination" Porter-Duff operator.
///
/// This is essentially the [srcOver] operator, but with the output's opacity
/// channel being set to that of the destination image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the destination on top instead of the source, see
/// [dstATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcATop.png) À _x‚]À aÎ‚;/// Composite the destination image over the source image, but only where it
/// overlaps the source.
///
/// This corresponds to the "Destination atop Source" Porter-Duff operator.
///
/// This is essentially the [dstOver] operator, but with the output's opacity
/// channel being set to that of the source image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the source on top instead of the destination, see
/// [srcATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstATop.png) À aÚ;À c+/// Apply a bitwise `xor` operator to the source and destination images. This
/// leaves transparency where they would overlap.
///
/// This corresponds to the "Source xor Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_xor.png) À cƒOÀ feƒ,/// Sum the components of the source and destination images.
///
/// Transparency in a pixel of one of the images reduces the contribution of
/// that image to the corresponding output pixel, as if the color of that
/// pixel in that image was darker.
///
/// This corresponds to the "Source plus Destination" Porter-Duff operator.
///
/// This is the right blend mode for cross-fading between two images. Consider
/// two images A and B, and an interpolation time variable _t_ (from 0.0 to
/// 1.0). To cross fade between them, A should be drawn with opacity 1.0 - _t_
/// into a new layer using [BlendMode.srcOver], and B should be drawn on top
/// of it, at opacity _t_, into the same layer, using [BlendMode.plus].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_plus.png) À fnƒVÀ i¼ƒ'/// Multiply the color components of the source and destination images.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// When compositing two opaque images, this has similar effect to overlapping
/// two transparencies on a projector.
///
/// For a variant that also multiplies the alpha channel, consider [multiply].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_modulate.png)
///
/// See also:
///
///  * [screen], which does a similar computation but inverted.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À j…!À o-„â/// Multiply the inverse of the components of the source and destination
/// images, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// This is essentially the same as [modulate] blend mode, but with the values
/// of the colors inverted before the multiplication and the result being
/// inverted back before rendering.
///
/// This can only result in the same or lighter colors (multiplying by black,
/// 1.0, results in no change; multiplying by white, 0.0, results in white).
/// Similarly, in the alpha channel, it can only result in more opaque colors.
///
/// This has similar effect to two projectors displaying their images on the
/// same screen simultaneously.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_screen.png)
///
/// See also:
///
///  * [modulate], which does a similar computation but without inverting the
///    values.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À oQƒŞÀ s(ƒ®/// Multiply the components of the source and destination images after
/// adjusting them to favor the destination.
///
/// Specifically, if the destination value is smaller, this multiplies it with
/// the source value, whereas is the source value is smaller, it multiplies
/// the inverse of the source value with the inverse of the destination value,
/// then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_overlay.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [hardLight], which is similar to [overlay] but favors the source image
///    instead of the destination image. À s47À te"/// Composite the source and destination image by choosing the lowest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_darken.png) À tp:À u£$/// Composite the source and destination image by choosing the highest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_lighten.png) À u¯{À w b/// Divide the destination by the inverse of the source.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorDodge.png) À w/‘À x·y/// Divide the inverse of the destination by the source, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorBurn.png) À xÅƒâÀ |ƒ°/// Multiply the components of the source and destination images after
/// adjusting them to favor the source.
///
/// Specifically, if the source value is smaller, this multiplies it with the
/// destination value, whereas is the destination value is smaller, it
/// multiplies the inverse of the destination value with the inverse of the
/// source value, then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hardLight.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [overlay], which is similar to [hardLight] but favors the destination
///    image instead of the source image. À |¬sÀ ~U/// Use [colorDodge] for source values below 0.5 and [colorBurn] for source
/// values above 0.5.
///
/// This results in a similar but softer effect than [overlay].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_softLight.png)
///
/// See also:
///
///  * [color], which is a more subtle tinting effect. À ~$ÅÀ ß¤/// Subtract the smaller value from the bigger value for each channel.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [exclusion] but harsher.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_difference.png) À îÔÀ ¹²/// Subtract double the product of the two images from the sum of the two
/// images.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [difference] but softer.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_exclusion.png) À Ç‚ÙÀ „˜‚´/// Multiply the components of the source and destination images, including
/// the alpha channel.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// Since the alpha channel is also multiplied, a fully-transparent pixel
/// (opacity 0.0) in one image results in a fully transparent pixel in the
/// output. This is similar to [dstIn], but with the colors combined.
///
/// For a variant that multiplies the colors but does not multiply the alpha
/// channel, consider [modulate].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_multiply.png) À „Â‚÷À ‡¶‚Ñ/// Take the hue of the source image, and the saturation and luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which is a similar but stronger effect as it also applies the
///    saturation of the source image.
///  * [HSVColor], which allows colors to be expressed using Hue rather than
///    the red/green/blue channels of [Color]. À ‡¾‚kÀ Š‚D/// Take the saturation of the source image, and the hue and luminosity of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_saturation.png)
///
/// See also:
///
///  * [color], which also applies the hue of the source image.
///  * [luminosity], which applies the luminosity of the source image to the
///    destination. À Š.‚ãÀ ‚½/// Take the hue and saturation of the source image, and the luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue and saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_color.png)
///
/// See also:
///
///  * [hue], which is a similar but weaker effect.
///  * [softLight], which is a similar tinting effect but also tints white.
///  * [saturation], which only applies the saturation of the source image. À ‚À ™‚d/// Take the luminosity of the source image, and the hue and saturation of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their luminosity from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_luminosity.png)
///
/// See also:
///
///  * [saturation], which applies the saturation of the source image to the
///    destination.
///  * [ImageFilter.blur], which can be used with [BackdropFilter] for a
///    related effect.    À ¨Œ{À •"…t/// Quality levels for image sampling in [ImageFilter] and [Shader] objects that sample
/// images and for [Canvas] operations that render images.
///
/// When scaling up typically the quality is lowest at [none], higher at [low] and [medium],
/// and for very large scale factors (over 10x) the highest at [high].
///
/// When scaling down, [medium] provides the best quality especially when scaling an
/// image to less than half its size or for animating the scale factor between such
/// reductions. Otherwise, [low] and [high] provide similar effects for reductions of
/// between 50% and 100% but the image may lose detail and have dropouts below 50%.
///
/// To get high quality when scaling images up and down, or when the scale is
/// unknown, [medium] is typically a good balanced choice.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/filter_quality.png)
///
/// When building for the web using the `--web-renderer=html` option, filter
/// quality has no effect. All images are rendered using the respective
/// browser's default setting.
///
/// See also:
///
///  * [Paint.filterQuality], which is used to pass [FilterQuality] to the
///    engine while using drawImage calls on a [Canvas].
///  * [ImageShader].
///  * [ImageFilter.matrix].
///  * [Canvas.drawImage].
///  * [Canvas.drawImageRect].
///  * [Canvas.drawImageNine].
///  * [Canvas.drawAtlas].  À •³€ÙÀ –ˆ€Ì/// The fastest filtering method, albeit also the lowest quality.
///
/// This value results in a "Nearest Neighbor" algorithm which just
/// repeats or eliminates pixels as an image is scaled up or down. À –‘€²À —@€¦/// Better quality than [none], faster than [medium].
///
/// This value results in a "Bilinear" algorithm which smoothly
/// interpolates between pixels in an image. À —H‚À ™Ğ‚k/// The best all around filtering method that is only worse than [high]
/// at extremely large scale factors.
///
/// This value improves upon the "Bilinear" algorithm specified by [low]
/// by utilizing a Mipmap that pre-computes high quality lower resolutions
/// of the image at half (and quarter and eighth, etc.) sizes and then
/// blends between those to prevent loss of detail at small scale sizes.
///
/// {@template dart.ui.filterQuality.seeAlso}
/// See also:
///
///  * [FilterQuality] class-level documentation that goes into detail about
///    relative qualities of the constant values.
/// {@endtemplate} À ™Û‚EÀ œ‚&/// Best possible quality when scaling up images by scale factors larger than
/// 5-10x.
///
/// When images are scaled down, this can be worse than [medium] for scales
/// smaller than 0.5x, or when animating the scale factor.
///
/// This option is also the slowest.
///
/// This value results in a standard "Bicubic" algorithm which uses a 3rd order
/// equation to smooth the abrupt transitions between pixels while preserving
/// some of the sense of an edge and avoiding sharp peaks in the result.
///
/// {@macro dart.ui.filterQuality.seeAlso}    À œ%†ÆÀ €±/// Styles to use for line endings.
///
/// See also:
///
///  * [Paint.strokeCap] for how this value is used.
///  * [StrokeJoin] for the different kinds of line segment joins.  À &…À §r/// Begin and end contours with a flat edge and no extension.
///
/// ![A butt cap ends line segments with a square end that stops at the end of
/// the line segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/butt_cap.png)
///
/// Compare to the [square] cap, which has the same shape, but extends past
/// the end of the line by half a stroke width. À °ËÀ  vµ/// Begin and end contours with a semi-circle extension.
///
/// ![A round cap adds a rounded end to the line segment that protrudes
/// by one half of the thickness of the line (which is the radius of the cap)
/// past the end of the segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line. À  €‚hÀ ¢â‚I/// Begin and end contours with a half square extension. This is
/// similar to extending each contour by half the stroke width (as
/// given by [Paint.strokeWidth]).
///
/// ![A square cap has a square end that effectively extends the line length
/// by half of the stroke width.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/square_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line.
///
/// Compare to the [butt] cap, which has the same shape, but doesn't extend
/// past the end of the line.    À ¢íˆÀ ¤—g/// Styles to use for line segment joins.
///
/// This only affects line joins for polygons drawn by [Canvas.drawPath] and
/// rectangles, not points drawn as lines with [Canvas.drawPoints].
///
/// See also:
///
/// * [Paint.strokeJoin] and [Paint.strokeMiterLimit] for how this value is
///   used.
/// * [StrokeCap] for the different kinds of line endings.  À ¤¦‚YÀ ¦ú‚7/// Joins between line segments form sharp corners.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.
///   * [Paint.strokeMiterLimit], used to define when a miter is drawn instead
///     of a bevel when the join is set to this value. À §ÌÀ ¨Ë®/// Joins between line segments are semi-circular.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value. À ¨Õ‚À ªç÷/// Joins between line segments connect the corners of the butt ends of the
/// line segments to give a beveled appearance.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.    À ªñ‚ÖÀ «‡T/// Strategies for painting shapes and paths on a canvas.
///
/// See [Paint.style].  À «ó€·À ¬¦€¬/// Apply the [Paint] to the inside of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results in a disc
/// of the given size being painted. À ¬¯À ­¾/// Apply the [Paint] to the edge of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results is a hoop
/// of the given size being painted. The line drawn on the edge will
/// be the width given by the [Paint.strokeWidth] property.    À ­ÉŒ‡À ­ı./// Different ways to clip a widget's content.  À ®‚8À °:‚/// No clip at all.
///
/// This is the default option for most widgets: if the content does not
/// overflow the widget boundary, don't pay any performance cost for clipping.
///
/// If the content does overflow, please explicitly specify the following
/// [Clip] options:
///  * [hardEdge], which is the fastest clipping, but with lower fidelity.
///  * [antiAlias], which is a little slower than [hardEdge], but with smoothed edges.
///  * [antiAliasWithSaveLayer], which is much slower than [antiAlias], and should
///    rarely be used. À °C‚_À ²š‚:/// Clip, but do not apply anti-aliasing.
///
/// This mode enables clipping, but curves and non-axis-aligned straight lines will be
/// jagged as no effort is made to anti-alias.
///
/// Faster than other clipping modes, but slower than [none].
///
/// This is a reasonable choice when clipping is needed, if the container is an axis-
/// aligned rectangle or an axis-aligned rounded rectangle with very small corner radii.
///
/// See also:
///
///  * [antiAlias], which is more reasonable when clipping is needed and the shape is not
///    an axis-aligned rectangle. À ²§ƒ.À µÌƒ /// Clip with anti-aliasing.
///
/// This mode has anti-aliased clipping edges to achieve a smoother look.
///
/// It' s much faster than [antiAliasWithSaveLayer], but slower than [hardEdge].
///
/// This will be the common case when dealing with circles and arcs.
///
/// Different from [hardEdge] and [antiAliasWithSaveLayer], this clipping may have
/// bleeding edge artifacts.
/// (See https://fiddle.skia.org/c/21cb4c2b2515996b537f36e7819288ae for an example.)
///
/// See also:
///
///  * [hardEdge], which is a little faster, but with lower fidelity.
///  * [antiAliasWithSaveLayer], which is much slower, but can avoid the
///    bleeding edges if there's no other way.
///  * [Paint.isAntiAlias], which is the anti-aliasing switch for general draw operations. À µÚ„sÀ º7„4/// Clip with anti-aliasing and saveLayer immediately following the clip.
///
/// This mode not only clips with anti-aliasing, but also allocates an offscreen
/// buffer. All subsequent paints are carried out on that buffer before finally
/// being clipped and composited back.
///
/// This is very slow. It has no bleeding edge artifacts (that [antiAlias] has)
/// but it changes the semantics as an offscreen buffer is now introduced.
/// (See https://github.com/flutter/flutter/issues/18057#issuecomment-394197336
/// for a difference between paint without saveLayer and paint with saveLayer.)
///
/// This will be only rarely needed. One case where you might need this is if
/// you have an image overlaid on a very different background color. In these
/// cases, consider whether you can avoid overlaying multiple colors in one
/// spot (e.g. by having the background color only present where the image is
/// absent). If you can, [antiAlias] would be fine and much faster.
///
/// See also:
///
///  * [antiAlias], which is much faster, and has similar clipping results.    À…,ÀêË/// The color space describes the colors that are available to an [Image].
///
/// This value can help decide which [ImageByteFormat] to use with
/// [Image.toByteData]. Images that are in the [extendedSRGB] color space
/// should use something like [ImageByteFormat.rawExtendedRgba128] so that
/// colors outside of the sRGB gamut aren't lost.
///
/// This is also the result of [Image.colorSpace].
///
/// See also: https://en.wikipedia.org/wiki/Color_space  Àù€ØÀÍ€Ç/// The sRGB color space.
///
/// You may know this as the standard color space for the web or the color
/// space of non-wide-gamut Flutter apps.
///
/// See also: https://en.wikipedia.org/wiki/SRGB ÀÕÀá/// A color space that is backwards compatible with sRGB but can represent
/// colors outside of that gamut with values outside of [0..1]. In order to
/// see the extended values an [ImageByteFormat] like
/// [ImageByteFormat.rawExtendedRgba128] must be used. ÀñQÀ
99/// The Display P3 color space.
///
/// This is a wide gamut color space that has broad hardware support. It's
/// supported in cases like using Impeller on iOS. When used on a platform
/// that doesn't support Display P3, the colors will be clamped to sRGB.
///
/// See also: https://en.wikipedia.org/wiki/DCI-P3    À7‰ÀÃY/// The format in which image bytes should be returned when using
/// [Image.toByteData].  À×€‚ÀRt/// Raw RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with premultiplied alpha, 8 bits per channel. À^€Àİx/// Raw straight RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 8 bits per channel. Àñ€»ÀŸ€¥/// Raw unmodified format.
///
/// Unencoded bytes, in the image's existing format. For example, a grayscale
/// image may use a single 8-bit channel for each pixel. À±‚ÎÀm‚/// Raw extended range RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 32 bit
/// float (IEEE 754 binary32) per channel.
///
/// Example usage:
///
/// ```dart
/// import 'dart:ui' as ui;
/// import 'dart:typed_data';
///
/// Future<Map<String, double>> getFirstPixel(ui.Image image) async {
///   final ByteData data =
///       (await image.toByteData(format: ui.ImageByteFormat.rawExtendedRgba128))!;
///   final Float32List floats = Float32List.view(data.buffer);
///   return <String, double>{
///     'r': floats[0],
///     'g': floats[1],
///     'b': floats[2],
///     'a': floats[3],
///   };
/// }
/// ``` À„‚¾À?‚œ/// PNG format.
///
/// A loss-less compression format for images. This format is well suited for
/// images with hard edges, such as screenshots or sprites, and images with
/// text. Transparency is supported. The PNG format supports images up to
/// 2,147,483,647 pixels in either dimension, though in practice available
/// memory provides a more immediate limitation on maximum image size.
///
/// PNG images normally use the `.png` file extension and the `image/png` MIME
/// type.
///
/// See also:
///
///  * <https://en.wikipedia.org/wiki/Portable_Network_Graphics>, the Wikipedia page on PNG.
///  * <https://tools.ietf.org/rfc/rfc2083.txt>, the PNG standard.    ÀGƒ?À‹>/// The format of pixel data given to [decodeImageFromPixels].  À›€ÙÀl€Ê/// Each pixel is 32 bits, with the highest 8 bits encoding red, the next 8
/// bits encoding green, the next 8 bits encoding blue, and the lowest 8 bits
/// encoding alpha. Premultiplied alpha is used. Ày€ÙÀJ€Ê/// Each pixel is 32 bits, with the highest 8 bits encoding blue, the next 8
/// bits encoding green, the next 8 bits encoding red, and the lowest 8 bits
/// encoding alpha. Premultiplied alpha is used. ÀW,Àx/// Each pixel is 128 bits, where each color component is a 32 bit float that
/// is normalized across the sRGB gamut.  The first float is the red
/// component, followed by: green, blue and alpha. Premultiplied alpha isn't
/// used, matching [ImageByteFormat.rawExtendedRgba128].    ÀÆƒ•À‘c€—/// Determines the winding rule that decides how the interior of a [Path] is
/// calculated.
///
/// This enum is used by the [Path.fillType] property.  À‘t¯À“—/// The interior is defined by a non-zero sum of signed edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses lines going clockwise
/// around the point a different number of times than it crosses lines going
/// counter-clockwise around that point.
///
/// See: <https://en.wikipedia.org/wiki/Nonzero-rule> À“(0À”Q/// The interior is defined by an odd number of edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses an odd number of lines.
///
/// See: <https://en.wikipedia.org/wiki/Even-odd_rule>    À”]ˆLÀ•€ˆ/// Strategies for combining paths.
///
/// See also:
///
/// * [Path.combine], which uses this enum to decide how to combine two paths.  À•#£À–¼„/// Subtract the second path from the first path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// first circle that was not overlapped by the second circle.
///
/// See also:
///
///  * [reverseDifference], which is the same but subtracting the first path
///    from the second. À–Ê‡À˜Hk/// Create a new path that is the intersection of the two paths, leaving the
/// overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be only the overlapping portion
/// of the two circles.
///
/// See also:
///  * [xor], which is the inverse of this operation À˜U$À™t/// Create a new path that is the union (inclusive-or) of the two paths.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a figure-eight like shape
/// matching the outer boundaries of both circles. À™}‚Àšün/// Create a new path that is the exclusive-or of the two paths, leaving
/// everything but the overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the figure-eight like shape less the overlapping parts
///
/// See also:
///  * [intersect], which is the inverse of this operation À›£Àœ•}/// Subtract the first path from the second path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// second circle that was not overlapped by the first circle.
///
/// See also:
///
///  * [difference], which is the same but subtracting the second path
///    from the first.    À'£ƒ{À(4/// Styles to use for blurs in [MaskFilter] objects.  À(`€–À(ğ€‹/// Fuzzy inside and outside. This is useful for painting shadows that are
/// offset from the shape that ostensibly is casting the shadow. À(û€ÍÀ)Ã€Á/// Solid inside, fuzzy outside. This corresponds to drawing the shape, and
/// additionally drawing the blur. This can make objects appear brighter,
/// maybe even as if they were fluorescent. À)Í€æÀ*®€Ú/// Nothing inside, fuzzy outside. This is useful for painting shadows for
/// partially transparent shapes, when they are painted separately but without
/// an offset, so that the shadow doesn't paint below the shape. À*¸cÀ+Y/// Fuzzy inside, nothing outside. This can make shapes appear to be lit from
/// within.    ÀÓ“À—¦†’/// Defines what happens at the edge of a gradient or the sampling of a source image
/// in an [ImageFilter].
///
/// A gradient is defined along a finite inner area. In the case of a linear
/// gradient, it's between the parallel lines that are orthogonal to the line
/// drawn between two points. In the case of radial gradients, it's the disc
/// that covers the circle centered on a particular point up to a given radius.
///
/// An image filter reads source samples from a source image and performs operations
/// on those samples to produce a result image. An image defines color samples only
/// for pixels within the bounds of the image but some filter operations, such as a blur
/// filter, read samples over a wide area to compute the output for a given pixel. Such
/// a filter would need to combine samples from inside the image with hypothetical
/// color values from outside the image.
///
/// This enum is used to define how the gradient or image filter should treat the regions
/// outside that defined inner area.
///
/// See also:
///
///  * [painting.Gradient], the superclass for [LinearGradient] and
///    [RadialGradient], as used by [BoxDecoration] et al, which works in
///    relative coordinates and can create a [Shader] representing the gradient
///    for a particular [Rect] on demand.
///  * [dart:ui.Gradient], the low-level class used when dealing with the
///    [Paint.shader] property directly, with its [Gradient.linear] and
///    [Gradient.radial] constructors.
///  * [dart:ui.ImageFilter.blur], an ImageFilter that may sometimes need to
///    read samples from outside an image to combine with the pixels near the
///    edge of the image.  À—³‚£ÀšQ‚‡/// Samples beyond the edge are clamped to the nearest color in the defined inner area.
///
/// A gradient will paint all the regions outside the inner area with the
/// color at the end of the color stop list closest to that region.
///
/// An image filter will substitute the nearest edge pixel for any samples taken from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png) Àš[ƒ5Àˆƒ/// Samples beyond the edge are repeated from the far end of the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated from 1.0 to 2.0, 2.0 to 3.0, and so forth (and for linear gradients, similarly
/// from -1.0 to 0.0, -2.0 to -1.0, etc).
///
/// An image filter will treat its source image as if it were tiled across the enlarged
/// sample space from which it reads, each tile in the same orientation as the base image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png) À•ƒ|À¡ƒY/// Samples beyond the edge are mirrored back and forth across the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated backwards from 2.0 to 1.0, then forwards from 2.0 to 3.0, then backwards
/// again from 4.0 to 3.0, and so forth (and for linear gradients, similarly in the
/// negative direction).
///
/// An image filter will treat its source image as tiled in an alternating forwards and
/// backwards or upwards and downwards direction across the sample space from which
/// it is reading.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png) À¡‚½À£Î‚Ÿ/// Samples beyond the edge are treated as transparent black.
///
/// A gradient will render transparency over any region that is outside the circle of a
/// radial gradient or outside the parallel lines that define the inner area of a linear
/// gradient.
///
/// An image filter will substitute transparent black for any sample it must read from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)    Àù4‚ÃÀùîw/// Defines how a list of points is interpreted when drawing a set of triangles.
///
/// Used by [Canvas.drawVertices].  ÀùıQÀúEE/// Draw each sequence of three points as the vertices of a triangle. ÀúS[Àú¡K/// Draw each sliding window of three points as the vertices of a triangle. Àú³AÀûé)/// Draw the first point and each sliding window of two points as the vertices
/// of a triangle.
///
/// This mode is not natively supported by most backends, and is instead
/// implemented by unrolling the points into the equivalent
/// [VertexMode.triangles], which is generally more efficient.    À(‡„-À)^€/// Defines how a list of points is interpreted when drawing a set of points.
///
/// Used by [Canvas.drawPoints] and [Canvas.drawRawPoints].  À)l·À+/// Draw each point separately.
///
/// If the [Paint.strokeCap] is [StrokeCap.round], then each point is drawn
/// as a circle with the diameter of the [Paint.strokeWidth], filled as
/// described by the [Paint] (ignoring [Paint.style]).
///
/// Otherwise, each point is drawn as an axis-aligned square with sides of
/// length [Paint.strokeWidth], filled as described by the [Paint] (ignoring
/// [Paint.style]). À+(€éÀ,€×/// Draw each sequence of two points as a line segment.
///
/// If the number of points is odd, then the last point is ignored.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]). À,€›À,ª€‹/// Draw the entire sequence of points as one line.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]).    À,¶À-4x/// Defines how a new clip region should be merged with the existing clip
/// region.
///
/// Used by [Canvas.clipRect].  À-?BÀ-w5/// Subtract the new region from the existing region. À-†BÀ-¿6/// Intersect the new region from the existing region.       „‹o„  „	„£   „üt…  ……   …r€…w  …†…   †€Û†  ††%   †à€†å  †ô†ü   ‡ol‡u  ‡‡ˆ  ‡Š‡’   À
G€ØÀ
K  À
^À
j   À!À,  À?	ÀD   ÀG2pÀGR  ÀG]ÀGe  ÀG2ÀG3ÀG9ÀGJÀG:À]Y‰?Àe1‡‰/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The `list` parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported:
/// {@template dart.ui.imageFormats}
/// JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP. Additional
/// formats may be supported by the underlying platform. Flutter will
/// attempt to call platform API to decode unrecognized formats, and if the
/// platform API supports decoding the image Flutter will be able to render it.
/// {@endtemplate}
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed. ÀeJÀeU  Àe^Àed  ÀerÀex  Àe‡Àe  ÀeÀfšŠ¡ÀnÔˆ+/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The [buffer] parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported: {@macro dart.ui.imageFormats}
///
/// The [buffer] will be disposed by this method once the codec has been created,
/// so the caller must relinquish ownership of the [buffer] when they call this
/// method.
///
/// The [targetWidth] and [targetHeight] arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed.
///
/// ## Compatibility note on the web
///
/// When running Flutter on the web, only the CanvasKit renderer supports image
/// resizing capabilities (not the HTML renderer). So if image resizing is
/// critical to your use case, and you're deploying to the web, you should
/// build using the CanvasKit renderer. Àn÷Ào  ÀoÀo  Ào'Ào-  Ào<ÀoB  ÀoRÀq=‰„ÀxT‡/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API.
///
/// The [buffer] parameter is the binary image data (e.g a PNG or GIF binary
/// data). The data can be for either static or animated images. The following
/// image formats are supported: {@macro dart.ui.imageFormats}
///
/// The [buffer] will be disposed by this method once the codec has been
/// created, so the caller must relinquish ownership of the [buffer] when they
/// call this method.
///
/// The [getTargetSize] parameter, when specified, will be invoked and passed
/// the image's intrinsic size to determine the size to decode the image to.
/// The width and the height of the size it returns must be positive values
/// greater than or equal to 1, or null. It is valid to return a
/// [TargetImageSize] that specifies only one of `width` and `height` with the
/// other remaining null, in which case the omitted dimension will be scaled to
/// maintain the aspect ratio of the original dimensions. When both are null or
/// omitted, the image will be decoded at its native resolution (as will be the
/// case if the [getTargetSize] parameter is omitted).
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform.
///
/// The returned future can complete with an error if the image decoding has
/// failed.
///
/// ## Compatibility note on the web
///
/// When running Flutter on the web, only the CanvasKit renderer supports image
/// resizing capabilities (not the HTML renderer). So if image resizing is
/// critical to your use case, and you're deploying to the web, you should
/// build using the CanvasKit renderer. ÀxuÀx†  Àx‘&Àx«   ÀzÃsÀzÓ  ÀzèÀzí  ÀzüÀ{   Àƒ
©À„@0/// Loads a single image frame from a byte array into an [Image] object.
///
/// This is a convenience wrapper around [instantiateImageCodec]. Prefer using
/// [instantiateImageCodec] which also supports multi frame images and offers
/// better error handling. This function swallows asynchronous errors. À„TÀ„_  À„dÀ„z   À„µ€ïÀ„Â  À„ÜÀ„ç  À„ìÀ…   À…¦‹À‹I…/// Convert an array of pixel values into an [Image] object.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `format`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true. 	À‹bÀ‹m  À‹v	À‹{  À‹ƒ
À‹ˆ  À‹‘À‹  À‹§À‹½  À‹ÊÀ‹Ğ  À‹ÛÀ‹á  À‹ïÀ‹õ  ÀŒÀŒ
  ÀŒÀ7‰oÀ7"  À75À7A  À7HÀ7T   À£Ø±À£ä  À£ùÀ¤   À¥Œ€ëÀ¥–  À¥§À¥´   À¦y›À¦…  À¦–À¦¤   À¨$À¨"  À¨3À¨;  À¨BÀ¨J   Àxh‚¼Àxr Àx|Àx|ÀxÀx   À{&ƒ2À{sB/// A variant of `_futurize` that can communicate specific errors.À{†À{†À{‰"À{¢    ÀˆdÀ¼+/// Signature for [Image] lifecycle events.  ÀßÀæ   ÀG¤mÀGŞ1/// Callback signature for [decodeImageFromList].  ÀHÀH
   À{8dÀ|9€ø/// Signature for a callback that determines the size to which an image should
/// be decoded given its intrinsic size.
///
/// See also:
///
///  * [instantiateImageCodecWithSize], which used this signature for its
///    `getTargetSize` argument.  À|oÀ|t  À|…À|Š   ÀxlÀ®-/// Signature for [Picture] lifecycle events.  ÀÓÀÜ   ÀridÀr¦4/// Generic callback signature, used by [_futurize].Àr°Àr° ÀrÃÀrÆ   ÀrÏ€…Às=/// Generic callback signature, used by [_futurizeWithError].Às(Às( Às;Às>  ÀsEÀsN   ÀsV€ÕÀsñ€’/// Signature for a method that receives a [_Callback].
///
/// Return value should be null on success, and a string error message on
/// failure.ÀsıÀsı ÀtÀt"   Àt-€±Àt’\/// Signature for a method that receives a [_CallbackWithError].
/// See also: [_Callbacker]Àt§Àt§ Àt½ÀtÕ       œÔ <€†€¤€µ€¶€Î€ï-Fz­®û‚E‚•‚æƒ6ƒ„ƒÕ„„„d„Š„‹„ª„ê„ù„û„ü……`…o…q…r…—…ñ† †††/†p†Î†İ†ß†à‡‡]‡l‡n‡o‡›‡Ú‡Ü‡İˆˆˆeˆµ‰‰,‰0‰`‰d‰p‰˜‰ÕŠŠEŠMŠQŠ¢Šñ‹A‹m‹q‹}‹ÊŒŒŒŒnŒ¿!%37„Ğ+|ŠÌÒı+Qx£óAou»‘‘-‘F‘_‘ª‘«‘å‘ë’3’‚’£’·’Õ’ğ““)“S“f“w“Š“œ““ã“é”6”F”k”’”¸”¾•••R•_•’•È•É•ã–)–B–ƒ–„–Î–å–ë——7—]—ª—Ú—à˜#˜)˜q˜­˜é˜ê™9™N™l™Š™¨™©™Ğ™Öš'šIš[š\šš“š”š»šÍšÎšô›››,›K›L›r›™›››Ì›Ò›úœ œ(œNœuœšœÒœä'Fdhi¢¨÷2ab•›ìŸŸ'ŸMŸNŸ…ŸŸËŸÌ   L M …  Ë Ì¡¡+¡1¡‚¡•¡©¡¿¡Ò¡ç¡û¢¢:¢ƒ¢©¢Æ¢ß¢ü££?£E£„£¬£ç¤0¤=¤e¤k¤o¤p¤¹¤ï¤õ¥-¥H¥x¥|¥}¥Æ¦¦¦L¦ˆ¦®¦Ü§§§§b§§•§Í§æ¨¨¨¨f¨œ¨¢¨Ú¨õ©%©)©*©{©¨©®©æª ª1ª5ª6ªtª±ªÑªñª÷«8«<«=«ˆ««â¬ ¬¬D¬b¬•¬Õ­­9­k­œ­ ­¡­Ğ­Ö®®a®g®±®ş¯=¯ƒ¯‰¯Ö° °k°·±±U±¢±ó² ²&²u²•²Ê³ ³6³K³b³w³†³®³¶³Ã³Ú³ü´´9´T´’´ÎµµIµmµxµ€µ†µŠµ‹µÎ¶¶¶f¶­¶ø·G·’·Ò¸¸L¸s¸¯¸È¸Î¸õ¹¹N¹g¹y¹¶¹õº3º^ºgº„º¬ºİºú»»,»w»Ä¼¼;¼D¼J¼N¼O¼œ¼¢¼Í½ ½;½?½@½L½o½‘½¤½ª½Ö½ê½ğ¾¾%¾=¾U¾m¾•¾™¾š¾¦¾á¾â¾î¿¿ª¿¬¿­¿à¿äÀ @1À @{À @šÀ @À @ïÀ A<À A‹À AÙÀ B)À BtÀ B¸À B¼À CÀ CWÀ C¨À CôÀ DBÀ DÀ DÖÀ E!À EpÀ E¶À EÑÀ EÕÀ F#À FpÀ FºÀ GÀ GYÀ GªÀ GëÀ GïÀ HÀ HÀ HhÀ H©À HúÀ IGÀ I˜À IçÀ J6À JQÀ JUÀ JcÀ JgÀ J²À JÃÀ JÔÀ K#À K6À K|À K}À KÁÀ KÇÀ LÀ L	À LfÀ LoÀ LpÀ L¯À LµÀ MÀ MÀ MÀ MTÀ MZÀ MµÀ M¼À M½À MüÀ NÀ NMÀ N^À NdÀ N¦À N¬À OÀ OÀ OÀ OLÀ ORÀ O À OñÀ PÀ PÀ PbÀ PÀ P•À PôÀ PÿÀ Q À Q>À QDÀ QmÀ QsÀ QÁÀ QÇÀ R&À R,À R{À R¦À R±À R²À RúÀ SGÀ S”À S¢À S¨À SçÀ SíÀ T:À T‚À T’À T˜À TäÀ TêÀ UGÀ UPÀ UQÀ UÀ UìÀ V6À V<À VvÀ V|À VÉÀ WÀ W!À WmÀ WsÀ WĞÀ WÙÀ WÚÀ X)À X|À XËÀ XÑÀ YÀ YÀ YdÀ YµÀ Y»À ZÀ ZÀ ZlÀ ZvÀ ZwÀ ZËÀ [À [cÀ [iÀ [¤À [ªÀ [üÀ \HÀ \NÀ \›À \¡À \ÿÀ ]	À ]
À ]YÀ ]yÀ ]À ]ÍÀ ]ÓÀ ^#À ^oÀ ^£À ^©À ^ôÀ _À _À _jÀ _uÀ _vÀ _ÅÀ _àÀ _æÀ `4À `:À `ŠÀ `ÑÀ aÀ aÀ aVÀ agÀ amÀ aÌÀ a×À aØÀ b(À b\À bbÀ b¯À bµÀ cÀ cÀ cÀ cWÀ c]À c¬À cøÀ dÀ d$À drÀ dxÀ dÉÀ eÀ ehÀ e·À fÀ fÀ fcÀ fkÀ flÀ f¶À f¼À gÀ gZÀ g`À g±À gÚÀ gàÀ h1À h7À h—À hÀ h­À h³À hõÀ i=À iYÀ i£À iºÀ iÆÀ iÇÀ jÀ jÀ j[À jÀ j‡À jÓÀ k À kOÀ kUÀ k¦À kòÀ lÀ lÀ lnÀ l½À mÀ mÀ mcÀ m…À m‹À méÀ mïÀ mÿÀ nÀ nUÀ nfÀ n®À nÊÀ oÀ o+À oNÀ oOÀ o˜À oÇÀ oÍÀ pÀ plÀ p½À pÜÀ pâÀ q.À q{À qªÀ q°À rÀ rÀ r%À r+À rdÀ r«À rûÀ s&À s1À s2À s€À sŸÀ s¥À sîÀ sÿÀ tÀ tcÀ tmÀ tnÀ t½À tÜÀ tâÀ u+À u<À uBÀ u¡À u¬À u­À uèÀ uîÀ v:À v‡À v¶À v¼À wÀ w,À w-À w€À w†À wÒÀ xÀ xNÀ xTÀ xµÀ xÂÀ xÃÀ yÀ y6À y<À yŒÀ yÕÀ z#À zPÀ zVÀ z¢À zïÀ {À {$À {…À {‹À {›À {¡À {ÚÀ |!À |pÀ |œÀ |©À |ªÀ |øÀ }À }À }XÀ }^À }¿À }ÅÀ }ÕÀ }ÛÀ ~À ~!À ~"À ~kÀ ~qÀ ~ÀÀ ~×À ~İÀ &À 7À =À uÀ {À İÀ ëÀ ìÀ €8À €FÀ €LÀ €›À €²À €¸À À À À PÀ VÀ ·À ÄÀ ÅÀ ‚À ‚,À ‚2À ‚À ‚ĞÀ ‚ÖÀ ƒ"À ƒoÀ ƒ·À ƒ½À „À „0À „6À „–À „¿À „ÀÀ …À …*À …0À …yÀ …À …ÈÀ †À †>À †DÀ †ŸÀ †¥À †µÀ †»À ‡À ‡4À ‡ƒÀ ‡´À ‡»À ‡¼À ˆÀ ˆ&À ˆ,À ˆuÀ ˆÅÀ ˆòÀ ˆøÀ ‰ZÀ ‰`À ‰pÀ ‰vÀ ‰¸À ŠÀ ŠÀ Š+À Š,À Š}À Š–À ŠœÀ ŠåÀ ŠëÀ ‹4À ‹„À ‹¹À ‹¿À ŒÀ Œ"À Œ2À Œ8À ŒnÀ Œ¼À 
À À À eÀ ~À „À ÍÀ À JÀ PÀ ²À ¸À ÈÀ ÎÀ À 3À ~À —À ¥À §À ¨À  À ;À ?À œÀ ãÀ çÀ ‘<À ‘À ‘æÀ ’:À ’>À ’ŒÀ ’ÇÀ ’ËÀ “$À “(À “uÀ “½À “ÜÀ “àÀ “îÀ “òÀ ”=À ”vÀ ”ŒÀ ”©À ”ÄÀ ”ãÀ •À •À •2À •ˆÀ •°À •±À •õÀ •ûÀ –AÀ –†À –À –À –ÇÀ –ÍÀ —À —>À —EÀ —FÀ —À —¸À —¾À ˜	À ˜VÀ ˜ŸÀ ˜êÀ ˜ğÀ ™ À ™0À ™6À ™…À ™¹À ™ÎÀ ™ØÀ ™ÙÀ š)À š6À š<À šŠÀ šÇÀ šÍÀ šôÀ šúÀ ›LÀ ›œÀ ›çÀ ›íÀ œÀ œ"À œ$À œ%À œIÀ œMÀ œ[À œ_À œ”À œ×À À $À dÀ jÀ »À À %À sÀ ¥À ­À ®À éÀ ïÀ Ÿ9À Ÿ‰À ŸùÀ ŸÿÀ  OÀ  tÀ  }À  ~À  ÁÀ ¡À ¡+À ¡1À ¡€À ¡ñÀ ¡÷À ¢GÀ ¢lÀ ¢rÀ ¢ÀÀ ¢àÀ ¢êÀ ¢ìÀ ¢íÀ £À £À £hÀ £¬À £°À £¾À £ÂÀ ¤À ¤À ¤UÀ ¤’À ¤¤À ¤ÚÀ ¤àÀ ¥IÀ ¥OÀ ¥—À ¥çÀ ¥óÀ ¥ùÀ ¦	À ¦À ¦]À ¦nÀ ¦¿À ¦øÀ §À §À §7À §=À §¤À §ªÀ §òÀ ¨BÀ ¨NÀ ¨TÀ ¨dÀ ¨jÀ ¨¸À ¨ÉÀ ¨ÒÀ ¨ÓÀ ©!À ©SÀ ©YÀ ©ÀÀ ©ÆÀ ªÀ ª^À ªjÀ ªpÀ ª€À ª†À ªÔÀ ªåÀ ªîÀ ªğÀ ªñÀ «+À «/À «FÀ «‚À «—À «âÀ «ğÀ «ñÀ ¬7À ¬}À ¬¤À ¬¬À ¬­À ¬ñÀ ­7À ­~À ­¼À ­ÆÀ ­ÈÀ ­ÉÀ ­øÀ ®À ®À ® À ®kÀ ®¼À ®ÂÀ ¯À ¯$À ¯qÀ ¯ÊÀ °À °8À °@À °AÀ °mÀ °sÀ °ÌÀ °ıÀ ±À ±CÀ ±IÀ ±¡À ±üÀ ²À ²À ²À ²tÀ ²˜À ²¤À ²¥À ²ÄÀ ²ÊÀ ³À ³À ³oÀ ³uÀ ³¼À ³ÂÀ ´À ´6À ´À ´“À ´£À ´©À ´ñÀ µ<À µmÀ µÊÀ µ×À µØÀ ¶$À ¶*À ¶}À ¶ÏÀ ¶øÀ ¶şÀ ·PÀ ·À ·ïÀ ¸AÀ ¸GÀ ¸—À ¸çÀ ¹5À ¹…À ¹ËÀ ¹ÑÀ ¹áÀ ¹çÀ º5À ºOÀ ºQÀ ºRÀ º”À º˜À ºŞÀ ºıÀ »À »YÀ »oÀ »zÀ »{À »ÂÀ »ÈÀ ¼À ¼QÀ ¼WÀ ¼¥À ¼õÀ ½=À ½YÀ ½©À ½úÀ ¾À ¾kÀ ¾”À ¾˜À ¾™À ¾ÈÀ ¾ÍÀ ¿À ¿cÀ ¿²À À À ÀOÀ ÀTÀ À¤À ÀõÀ ÁÀ ÁÀ ÁSÀ ÁTÀ ÁuÀ Á‘À ÁÅÀ ÁÆÀ ÁòÀ ÂÀ ÂEÀ ÂoÀ Â˜À ÂÂÀ ÂìÀ ÃÀ Ã:À ÃeÀ ÃÀ Ã¹À ÃêÀ ÄÀ ÄCÀ ÄwÀ Ä§À ÄÓÀ ÄÔÀ ÅÀ ÅRÀ Å’À ÅĞÀ ÆÀ ÆPÀ ÆÀ ÆÄÀ ÇÀ ÇDÀ Ç„À ÇĞÀ ÈÀ ÈVÀ È¨À ÈòÀ É4À É5À ÉvÀ É¸À É¹À ÉıÀ ÊÀ Ê:À ÊUÀ ÊVÀ Ê„À ÊÇÀ ÊËÀ ÊÌÀ ÊòÀ ËÀ ËHÀ ËœÀ ËÀ ËãÀ ËñÀ Ë÷À ÌÀ Ì(À ÌoÀ ÌsÀ Ì“À ÌãÀ ÍÀ Í4À ÍxÀ Í|À Í}À ÍµÀ ÍåÀ ÍæÀ ÎÀ Î%À ÎEÀ ÎKÀ Î[À ÎaÀ Î§À ÎØÀ Ï À Ï&À ÏnÀ ÏƒÀ Ï—À ÏäÀ Ğ5À Ğ„À ĞÀ ĞãÀ ÑÀ ÑXÀ ÑoÀ Ñ…À Ñ—À Ñ­À ÑÁÀ ÑâÀ ÑæÀ ÑçÀ ÒÀ ÒEÀ ÒŠÀ ÒÎÀ ÓÀ ÓfÀ ÓÀ Ó…À Ó†À Ó¾À ÓÿÀ Ô À ÔLÀ ÔRÀ Ô”À ÔåÀ Õ6À ÕWÀ Õ]À ÕªÀ ÕËÀ ÕÑÀ ÕøÀ ÕşÀ ÖÀ ÖÀ ÖcÀ Ö—À ÖáÀ Ö÷À ×À ×`À ×›À ×ŸÀ ×ÂÀ ×üÀ Ø>À ØBÀ ØCÀ Ø‡À ØÀ ØµÀ ØÑÀ Ù#À Ù'À ÙJÀ ÙoÀ Ù­À Ù±À Ù²À ÙìÀ Ú;À ÚxÀ Ú~À Ú»À ÚÖÀ ÛÀ ÛÀ Û@À ÛbÀ Û¨À Û¬À Û­À ÛîÀ ÜÀ Ü$À ÜVÀ ÜrÀ ÜÄÀ ÜÈÀ ÜëÀ İÀ İRÀ İVÀ İWÀ İ˜À İÀ İïÀ Ş:À Ş@À ŞzÀ Ş€À ŞÀ Ş¤À ßÀ ßÀ ßzÀ ß€À ßçÀ ßíÀ à9À àŠÀ à–À àœÀ à¬À à²À áÀ á-À ávÀ áµÀ áÓÀ â'À â+À âPÀ âuÀ â¸À â¼À â½À âõÀ ã,À ã-À ãxÀ ãÆÀ äÀ ä^À ä¬À ä²À ä÷À äıÀ åKÀ åoÀ åuÀ åŞÀ åäÀ æMÀ æSÀ æ¼À æÂÀ çÀ ç_À çkÀ çqÀ çÀ ç‡À çÑÀ çìÀ è5À èUÀ èÀ è¢À èÉÀ éÀ éRÀ éVÀ éWÀ é§À éåÀ éëÀ êÀ ê.À êrÀ ê“À ê¨À êÉÀ êéÀ ëDÀ ë‹À ë–À ëœÀ ë­À ë±À ë×À ëğÀ ìBÀ ìŠÀ ìÒÀ ìßÀ í,À í^À í°À î	À îZÀ î`À îdÀ îeÀ î·À ïÀ ïWÀ ï]À ï…À ïÒÀ ïöÀ ğPÀ ğTÀ ğÀ ğ¤À ğêÀ ğîÀ ğïÀ ñ)À ñ/À ñeÀ ñkÀ ñ{À ñÀ ñ½À ñõÀ ò'À òoÀ ò†À ò¶À òºÀ òØÀ òèÀ òöÀ ó%À ó\À óeÀ óxÀ ó‚À ó’À ó·À óáÀ ôAÀ ôKÀ ôSÀ ôfÀ ôpÀ ô¨À ô¬À ô­À ôôÀ õÀ õÀ õ1À õ7À õˆÀ õ©À ö À ö"À ö&À öNÀ ö”À ö´À öÒÀ ÷ À ÷À ÷À ÷[À ÷aÀ ÷eÀ ÷fÀ ÷¡À ÷§À ÷îÀ øÀ øÀ øÀ øIÀ øcÀ øuÀ øÀ øßÀ øêÀ øòÀ øüÀ ùÀ ùÀ ùÀ ùSÀ ùtÀ ùËÀ ùíÀ ùñÀ úÀ ú2À úPÀ ú~À ú†À ú“À úÔÀ û*À ûUÀ û™À û¡À û§À û«À û¬À ûëÀ ûñÀ ü=À ü‡À ü¸À üÒÀ ıÀ ıÀ ı>À ıˆÀ ıŒÀ ıÀ ı™À ı¯À ıèÀ şÀ şÀ ş=À şXÀ ştÀ şÀ ş»À şÛÀ ÿÀ ÿ&À ÿIÀ ÿQÀ ÿzÀ ÿŸÀ ÿ§À ÿÓÀ À eÀ oÀ ~À ¤À ¬À ÄÀ ÊÀ âÀÀ+À1ÀaÀ‰À¡À§ÀØÀÀÀ"ÀAÀ~À–ÀœÀºÀõÀÀÀBÀƒÀ›À¡À»ÀîÀÀÀ+ÀhÀ€À†ÀÀ×ÀİÀôÀÀÀÀÀdÀhÀ«ÀõÀ@ÀrÀvÀ©À­ÀåÀ÷ÀÀÀfÀ’À˜ÀËÀÓÀ ÀnÀ¦ÀßÀïÀ	À	À	dÀ	±À	üÀ
À
7À
DÀ
FÀ
GÀ
wÀ
À
©À
¹À
ÛÀ
ëÀ
ÀÀÀ À!ÀLÀ^ÀjÀˆÀ”ÀºÀÆÀéÀöÀ0À4À6À7ÀyÀ‘ÀßÀ,ÀtÀ¾ÀÕÀìÀòÀPÀ[À\À|À‚ÀÛÀîÀïÀÀÀbÀÀ®À¯ÀÕÀÛÀ'ÀTÀZÀoÀuÀƒÀ¡ÀÁÀÇÀÀ-ÀƒÀÅÀæÀ ÀÀ4ÀNÀYÀaÀkÀÀ‚À”ÀšÀêÀ8À„ÀÑÀÀ ÀqÀ}ÀƒÀ“À™ÀøÀ=ÀDÀFÀGÀ†À™ÀçÀ7ÀjÀvÀwÀÆÀÀHÀTÀUÀ¥ÀìÀ;ÀvÀ…À‡ÀˆÀ´ÀíÀîÀ$À(ÀhÀlÀºÀÒÀÖÀ%ÀtÀ»ÀÀQÀ_ÀcÀ¯ÀşÀEÀIÀWÀ[ÀÉÀÀ>ÀÀ›ÀÍÀİÀÀÀ"ÀAÀ[À_À`ÀÀÀ´ÀµÀóÀùÀDÀ†À§ÀÎÀÏÀ À À _À ¢À ÃÀ ëÀ ìÀ!À!À!LÀ!_À!`À!¢À!¶À!·À!ÑÀ"À"OÀ"UÀ"¦À"ÁÀ"ÇÀ#À#]À#¬À#ÌÀ#ßÀ#úÀ$'À$SÀ$iÀ$ À$µÀ$ØÀ$ğÀ$öÀ$úÀ$ûÀ%?À%EÀ%“À%©À%ÄÀ%ØÀ%èÀ&À&À&!À&À&“À&”À&ÉÀ&ÏÀ'À'+À'1À'vÀ'ÅÀ(À(À(_À(xÀ(ÈÀ)À)aÀ)­À*À*/À*]À*aÀ*bÀ*À*¤À*ğÀ+?À+kÀ+qÀ+ÀÀ,À,AÀ,À,ºÀ,ØÀ-À-*À-8À-XÀ-fÀ-À-À-ëÀ-ñÀ-õÀ-öÀ.GÀ.iÀ.oÀ.¯À.åÀ/À/À/gÀ/zÀ/„À/—À/›À/œÀ/ÍÀ/ÓÀ0"À0qÀ0ÂÀ1À1ZÀ1¨À1ôÀ2À2À2fÀ2À2•À2İÀ3.À3DÀ3JÀ3€À3†À3”À3¯À3ÏÀ3çÀ3íÀ4%À4dÀ4ƒÀ4ÍÀ4ŞÀ4ğÀ5À5`À5®À5ÔÀ6
À6À66À6>À6DÀ6fÀ6šÀ6åÀ7À7SÀ7—À7ÔÀ7íÀ7óÀ8/À8_À8eÀ8‚À8œÀ8¢À8ÄÀ8âÀ8ıÀ9À9À9'À9JÀ9PÀ9kÀ9qÀ9”À9ÍÀ9×À9İÀ:À:À:À: À:eÀ:³À:×À:éÀ:şÀ;À;AÀ;’À;àÀ<"À<+À<1À<PÀ<{À<À<€À<ÌÀ=À=À=eÀ=¯À=ÿÀ>NÀ>˜À>åÀ?À?À?+À?UÀ?WÀ?XÀ?rÀ?§À?ğÀ@À@À@^À@€À@œÀ@ªÀ@«À@úÀAÀAÀAeÀA€ÀAÀAÖÀBÀBlÀBœÀBÓÀBäÀCÀCÀCÀC!ÀC%ÀC&ÀCbÀC¸ÀDÀDÀD,ÀD?ÀDWÀDcÀD{ÀDÈÀDàÀE*ÀEbÀEiÀEÀEÀE“ÀE”ÀEßÀFÀFFÀFbÀFcÀFŒÀFÀFÓÀFòÀFóÀFÿÀG/ÀG1ÀG2ÀGLÀGmÀG¡ÀG£ÀG¤ÀGÖÀHÀHÀHGÀHKÀH‡ÀH¡ÀH¥ÀHïÀI8ÀI†ÀIÌÀJÀJ@ÀJDÀJ}ÀJÀJÀJ™ÀJÓÀKÀK2ÀKÀKÊÀKçÀL3ÀLRÀLsÀLyÀLÀL…ÀL›ÀLŸÀL«ÀL¸ÀLòÀM3ÀMsÀM²ÀMşÀNÀNgÀN¯ÀNĞÀNÖÀNŞÀNğÀO:ÀOVÀO\ÀOšÀO¶ÀOôÀOõÀP$ÀP*ÀPwÀP’ÀP“ÀP¼ÀPÂÀQ
ÀQÀQ\ÀQqÀQsÀQtÀQ”ÀQ˜ÀQàÀQúÀQşÀR6ÀRSÀRjÀRÀR¦ÀR§ÀRÖÀRÜÀSÀS5ÀSPÀSQÀSyÀSÀSÃÀSÉÀTÀT ÀTaÀT‘ÀTµÀT¶ÀUÀU)ÀU/ÀUzÀUŸÀU±ÀU³ÀU´ÀV ÀVÀVNÀViÀVnÀV§ÀVÅÀVÙÀVÚÀVôÀVõÀWÀW<ÀW=ÀW‘ÀW±ÀW²ÀWÑÀWÒÀWŞÀX(ÀX)ÀX‚ÀX§ÀX¨ÀX´ÀXßÀY'ÀYÀYªÀYÍÀZ.ÀZ8ÀZqÀZ€ÀZ¨ÀZäÀ[&À[2À[:À[BÀ[[À[yÀ[À[œÀ[ À[¡À[İÀ\.À\~À\À\‹À\ÍÀ\èÀ\éÀ\õÀ]VÀ]XÀ]YÀ]|À]€À]ÏÀ^À^mÀ^À^”À^æÀ_4À_OÀ_À_´À`À`KÀ`—À`çÀ`úÀ`şÀaIÀa“ÀaãÀb2Àb~ÀbÏÀcÀcfÀc¢Àc¦ÀcğÀd:ÀdŠÀdÆÀdÊÀeÀe#ÀeHÀe\ÀepÀe…Àe£Àe®ÀeúÀf$Àf0ÀfNÀfnÀf’Àf—Àf™ÀfšÀf½ÀfÁÀgÀg`Àg®ÀgÑÀgÕÀh)ÀhwÀh°Àh´ÀiÀiVÀibÀifÀi±ÀiûÀjKÀjšÀjæÀk7Àk†ÀkÎÀl
ÀlÀlXÀl¢ÀlòÀm.Àm2ÀmÀm‹ÀmÀm´Àm¸ÀnÀnSÀnÀnÆÀnõÀoÀo%Ào:ÀoXÀo]Ào…Ào‘ÀoĞÀoíÀp1ÀpYÀpcÀpªÀpÔÀpŞÀpæÀq.Àq5Àq:Àq<Àq=Àq`ÀqdÀq¯Àq³Àr ÀrOÀrÀr’ÀrÛÀs*Às@ÀsDÀs’ÀsßÀt+ÀtlÀt»ÀuÀu[Àu«ÀuâÀuæÀv0ÀvzÀv®Àv²ÀvÿÀwÀwÀw4Àw8ÀwˆÀwÓÀxÀxFÀxsÀxÀx¹ÀxÄÀxîÀy:ÀyBÀyÀyÜÀzÀzEÀzjÀz‘Àz˜Àz¦Àz¼ÀzÀÀzÂÀzÃÀ{À{5À{7À{8À{‡À{°À{´À{ÂÀ{ÆÀ|À|1À|mÀ|ƒÀ|šÀ|À|À|ãÀ|çÀ|õÀ|ùÀ}EÀ}ƒÀ}«À}ÃÀ}ïÀ}õÀ~DÀ~\À~À~»À~éÀ~êÀÀÀmÀ½À€À€XÀ€ƒÀ€‰À€¿À€ÓÀ€ÔÀÀ	ÀYÀ¨ÀõÀ‚CÀ‚mÀ‚sÀ‚©À‚¾À‚¿À‚ËÀƒÀƒ	Àƒ
ÀƒSÀƒWÀƒ¦ÀƒôÀ„;À„…À„²À„´À„µÀ…À…LÀ…†À…£À…¥À…¦À…ãÀ…çÀ†5À†€À†˜À†œÀ†èÀ‡9À‡xÀ‡|À‡ÇÀˆÀˆaÀˆ°ÀˆüÀ‰MÀ‰œÀ‰äÀŠ ÀŠ$ÀŠnÀŠ¸À‹À‹DÀ‹`À‹tÀ‹À‹À‹¥À‹ÈÀ‹ÙÀ‹íÀŒÀŒ ÀŒ%ÀŒBÀŒvÀŒzÀŒ˜ÀŒÎÀŒÒÀŒÓÀŒûÀ À^ÀnÀ„ÀœÀ¸ÀÕÀŞÀßÀüÀBÀlÀvÀ¿ÀëÀõÀıÀşÀÀ*ÀNÀtÀ~ÀœÀàÀûÀÀ"ÀHÀdÀ„À…À±À½ÀÃÀÅÀÆÀ‘À‘#À‘'À‘^À‘rÀ‘¼À‘ÂÀ’À’bÀ’±À’ÜÀ’âÀ“À“%À“&À“hÀ“nÀ“¿À”À”À”OÀ”ZÀ”\À”]À”À”…À”“À”—À”æÀ•À•!À•UÀ•[À•©À•ôÀ–5À–;À–KÀ–QÀ– À–ºÀ–ÈÀ—À—=À—CÀ—‘À—ßÀ—ùÀ—ÿÀ˜À˜FÀ˜SÀ˜À˜¤À˜òÀ™=À™rÀ™{À™ÆÀ™ÿÀšÀšSÀš§Àš­Àš½ÀšúÀ›À›5À›;À›‰À›ÔÀœÀœÀœ+Àœ1ÀœzÀœ“Àœ¨ÀœªÀœ«ÀœüÀÀiÀŒÀ’ÀâÀ+À|ÀÅÀßÀåÀŸ4ÀŸ€ÀŸºÀŸÀÀ À 0À BÀ DÀ EÀ À çÀ¡À¡À¡À¡*À¡rÀ¡À¡À¡À¡ÂÀ¡ÆÀ¢À¢À¢RÀ¢‘À¢¥À¢©À¢ïÀ£À£À£]À£ À£ÈÀ£ÌÀ¤À¤IÀ¤_À¤ÌÀ¤ğÀ¥À¥À¥9À¥?À¥ŒÀ¥ÛÀ¥şÀ¦2À¦bÀ¦yÀ¦}À¦~À¦¼À¦ÂÀ§À§$À§HÀ§IÀ§~À§¡À§¢À§êÀ¨À¨À¨_À¨lÀ¨À¨À¨×À©	À©6À©7À©zÀ©ºÀ©ÉÀ©ÏÀª@ÀªµÀªûÀªüÀ«?À«†À«ËÀ«ØÀ¬&À¬'À¬lÀ¬³À¬ÂÀ¬ÈÀ­5À­¦À­øÀ­ùÀ®>À®…À®ÊÀ®ßÀ¯9À¯:À¯€À¯ÄÀ°	À°PÀ°uÀ°{À°èÀ±YÀ±ŸÀ± À±æÀ²*À²oÀ²¶À²üÀ³$À³rÀ³sÀ³¶À³ØÀ³ŞÀ´!À´EÀ´KÀ´’À´ÒÀµÀµ]Àµ¤ÀµèÀ¶À¶À¶aÀ¶—À¶èÀ¶éÀ·8À·}À·ƒÀ·ÒÀ¸À¸_À¸†À¸ŒÀ¸ÑÀ¹ À¹lÀ¹rÀ¹•À¹¶À¹ÑÀ¹ìÀºÀºÀºÀº]Àº¢Àº¨ÀºÜÀºâÀ»1À»À»ÂÀ¼À¼À¼UÀ¼£À¼ğÀ½À½"À½<À½]À½xÀ½“À½®À½´À½µÀ½üÀ¾À¾.À¾/À¾qÀ¾ŸÀ¾¥À¾÷À¿EÀ¿`À¿aÀ¿©À¿æÀÀ%ÀÀfÀÀ¬ÀÀğÀÁ4ÀÁ@ÀÁFÀÁ²ÀÂ"ÀÂ(ÀÂ˜ÀÃÀÃLÀÃMÀÃŸÀÃ­ÀÃ³ÀÄÀÄ'ÀÄ-ÀÄtÀÄ¨ÀÄ©ÀÄëÀÅ.ÀÅ>ÀÅ\ÀÅ]ÀÅ£ÀÅ©ÀÅöÀÆDÀÆoÀÆ±ÀÆ²ÀÆøÀÇ7ÀÇtÀÇzÀÇÇÀÈÀÈCÀÈŒÀÈÀÈÒÀÉÀÉ#ÀÉ$ÀÉiÀÉ­ÀÉÈÀÉØÀÉÙÀÊ)ÀÊvÀÊ•ÀÊ›ÀÊãÀÊéÀË.ÀËMÀËNÀËÀË½ÀËÚÀËÛÀÌÀÌKÀÌrÀÌsÀÌ¨ÀÌ®ÀÌşÀÍKÀÍ–ÀÍÕÀÍÛÀÎ,ÀÎ{ÀÎÍÀÏÀÏdÀÏ²ÀÏÀÀĞÀĞÀĞÀĞfÀĞyÀĞÀĞÏÀÑÀÑWÀÑ ÀÑÌÀÒÀÒ0ÀÒ6ÀÒ­ÀÒ±ÀÒ²ÀÓÀÓ2ÀÓ8ÀÓ„ÀÓÌÀÔÀÔjÀÔ´ÀÔìÀÔòÀÕ=ÀÕŠÀÕÓÀÖÀÖÀÖ]ÀÖªÀÖúÀ×=À×ŠÀ××ÀØ&ÀØvÀØÅÀØËÀÙÀÙhÀÙœÀÙ¢ÀÙóÀÚ>ÀÚxÀÚzÀÚ{ÀÚÅÀÚíÀÛÀÛÀÛ`ÀÛ¥ÀÛ¸ÀÛ¹ÀÛòÀÜÀÜÀÜZÀÜ€ÀÜÀÜÀÜÑÀÜİÀİÀİÀİsÀİ’Àİ“ÀİíÀŞÀŞÀŞ&ÀŞ„ÀŞ°ÀŞ±ÀŞ½Àß#ÀßYÀßZÀßfÀßÄÀßğÀßñÀßıÀàcÀà™ÀàšÀà¦ÀáÀánÀáoÀá{ÀáüÀâ'ÀâZÀâ[ÀâgÀâæÀãAÀãBÀãNÀãÕÀä8Àä9ÀäEÀä¼ÀåÀåÀåÀå—ÀåîÀåïÀåûÀæMÀæmÀæÌÀæĞÀæÑÀçTÀçÚÀçÛÀççÀè
Àè+ÀèFÀèaÀè|ÀèƒÀè§ÀèËÀé%Àé)Àé*Àé°Àê=Àê>ÀêJÀêeÀêÀê Àê»ÀêÖÀêñÀêøÀë!ÀëEÀë±ÀëµÀë¶ÀìDÀìiÀìÀì•Àì«ÀìÁÀìØÀìíÀíÀíÀíÀí-ÀíMÀí‰ÀíÀíÀíıÀîMÀîNÀîZÀîvÀî–ÀîÒÀîÖÀî×ÀïFÀï–Àï—Àï£ÀïäÀğÀğWÀğ[Àğ\ÀğÚÀñOÀñPÀñ\Àñ‘ÀñÃÀñÇÀñÈÀòÀòWÀòXÀòdÀòƒÀò¥ÀòÉÀòÍÀòÎÀóÀóFÀóGÀóSÀó–ÀóºÀóÕÀóıÀôKÀôXÀô“Àô™ÀôÀôÀôşÀõ@ÀõAÀõ³ÀöÀöÀö ÀöjÀöÀö©ÀöÑÀ÷%À÷2À÷tÀ÷zÀ÷~À÷À÷æÀø/Àø0Àø¨ÀùÀùÀùÀùhÀùÀù‚ÀùÀùÛÀùôÀùõÀúÀú!ÀúDÀúnÀúrÀúsÀúÓÀûÀûÀûÀû-ÀûQÀûÀû§Àû¸Àû¼Àû½ÀüÀüPÀüQÀü]Àü…Àü«ÀüÙÀüøÀı	ÀıÀıÀıaÀı Àı¡Àı­ÀıÂÀıíÀş+Àş/Àş0ÀşuÀşšÀş›ÀşüÀÿFÀÿGÀÿSÀÿÀÿ»Àÿ¿ÀÿÀÀÿÌÀÿëÀÿíÀÿîÀ 0À 4À BÀ  À °À áÀ çÀÀ:À;À€À†ÀÛÀÀDÀŒÀÀ‘À°À¶À	ÀMÀfÀgÀ”ÀšÀëÀ=ÀYÀpÀqÀ¡À§À÷ÀFÀbÀhÀ¶ÀÀTÀ¢À³ÀøÀ1À3À4À|À€ÀÑÀÀcÀgÀ­À±ÀıÀ	LÀ	jÀ	nÀ	¸À
À
)À
iÀ
˜À
îÀ
ïÀÀÀ$ÀVÀXÀYÀ¨ÀÂÀıÀ(À)ÀDÀgÀhÀtÀÀÂÀãÀûÀ^ÀºÀ.À7À=ÀWÀ[À\ÀhÀ|À£ÀÓÀæÀìÀÀÀÀÀÀ\À`À¨ÀóÀAÀeÀiÀ·ÀÀRÀ¢ÀğÀşÀÀ/ÀmÀ¯ÀâÀãÀÀÀhÀ²ÀûÀÀÀ8À>ÀŒÀÒÀ"ÀAÀXÀYÀ„ÀŠÀÚÀ!ÀoÀ¾À÷ÀıÀKÀ›ÀêÀ#À=À>À]À^À®ÀÕÀÛÀ*ÀwÀÀ•ÀÊÀĞÀÀHÀ‰ÀÀÀ×ÀİÀÀcÀ±ÀÀÀÀÀ‡À‰ÀŠÀÅÀúÀÀ#À$ÀyÀ»À¼ÀàÀVÀxÀ|À}ÀŞÀÀÀPÀ€ÀÎÀ À LÀ hÀ {À ˆÀ À ÄÀ éÀ òÀ øÀ üÀ ıÀ!XÀ!À!ŸÀ!ŞÀ"À"{À"©À"ìÀ"ıÀ#À#À#rÀ#àÀ#áÀ$À${À$ŸÀ$£À$¤À%À%/À%0À%[À%`À%µÀ%ßÀ%÷À&#À&3À&PÀ&VÀ&gÀ&kÀ&lÀ&ÆÀ&ìÀ&íÀ'9À'?À'€À' À'¢À'£À'ØÀ(À(%À(]À(^À(«À(îÀ(øÀ(ùÀ)GÀ)“À)ÁÀ)ÊÀ)ËÀ*À*iÀ*¬À*µÀ*¶À+À+À+À+À+ À+mÀ+½À+ÏÀ+ÓÀ,$À,7À,‚À,ˆÀ,¼À,ÂÀ-À-À-hÀ-¶À.À.À.À.lÀ.rÀ.˜À.À.®À.´À/À/À/+À/<À/AÀ/BÀ/\À/sÀ/tÀ/ºÀ0À0/À0eÀ0fÀ0rÀ0•À0´À0ÖÀ0ùÀ0ıÀ0şÀ1
À1=À1>À1JÀ1›À1À1À1¿À1üÀ1şÀ1ÿÀ2:À2]À2iÀ2¯À2±À2²À2åÀ3
À3)À35À3sÀ3ŠÀ3³À3ÚÀ4À4+À4PÀ4TÀ4VÀ4WÀ4À4¡À4ÍÀ4ÎÀ4ëÀ4ìÀ4øÀ56À5MÀ5eÀ5ˆÀ5ªÀ5ÌÀ5ãÀ6À6*À6LÀ6cÀ6‡À6©À6ÌÀ6äÀ7À7À7À7À7bÀ7²À7şÀ8À8À8+À8@À8VÀ8iÀ8qÀ8…À8ãÀ9BÀ9À9ÂÀ9ÊÀ9ÏÀ9àÀ:À:)À:rÀ:°À:ÊÀ;À;"À;sÀ;yÀ;¼À;úÀ<À<SÀ<nÀ<¾À<ÄÀ<ØÀ<òÀ=À=-À=_À=…À=·À=ÚÀ=õÀ=ıÀ>À><À>ZÀ>À>ÃÀ>õÀ?À?JÀ?RÀ?qÀ?À?¬À?ŞÀ@À@À@BÀ@tÀ@|À@€À@‚À@ƒÀ@ÔÀA#ÀAqÀA½ÀAîÀAòÀB;ÀBHÀBsÀBÀÀCÀCUÀC[ÀC¬ÀCúÀD'ÀDbÀDzÀDšÀD²ÀDÎÀDÏÀEÀE`ÀEuÀE{ÀEÈÀEğÀEöÀF)ÀF\ÀFÀFÂÀFõÀFûÀGJÀG–ÀGœÀGªÀGêÀHÀHÀH/ÀHFÀHPÀHZÀH`ÀHrÀHxÀH™ÀHŸÀH­ÀHëÀIÀI#ÀI?ÀI[ÀIeÀIoÀIuÀIüÀJÀJÀJMÀJpÀJ“ÀJ¶ÀJÙÀJãÀJíÀJóÀK|ÀK‚ÀKÀKÑÀK÷ÀLÀLCÀLiÀLsÀL}ÀL­ÀLÄÀLßÀLùÀMÀMÀMdÀMtÀMœÀM³ÀMÎÀMæÀNÀNÀN^ÀNyÀN¡ÀN¸ÀNÓÀNëÀOÀOÀO,ÀOKÀOjÀO}ÀO~ÀO®ÀOãÀP'ÀPpÀP¹ÀPºÀPÒÀPŞÀQ+ÀQ,ÀQUÀQjÀQÀQµÀQÌÀQÖÀQşÀRÀREÀRcÀRzÀR„ÀRÏÀRùÀSÀSRÀSvÀS«ÀSºÀSüÀTÀTÀTÀTÀT6ÀTbÀTvÀT|ÀTœÀT¼ÀTóÀUÀU@ÀUDÀUEÀUQÀUfÀUÀUóÀU÷ÀUøÀVÀV%ÀV:ÀVQÀVŠÀV£ÀVÒÀVöÀW(ÀWLÀW~ÀWÀW²ÀW¸ÀW¼ÀW½ÀWÉÀWßÀWôÀXÀXDÀX]ÀXŒÀX°ÀXâÀYÀY8ÀYGÀYãÀYéÀYíÀYïÀYğÀZ.ÀZ2ÀZ‚ÀZÍÀ[À[5À[pÀ[’À[ÊÀ[ŞÀ\À\#À\$À\HÀ\‚À\–À\ÏÀ\ÓÀ]À]GÀ][À]yÀ]}À]~À]­À]òÀ^À^$À^(À^)À^wÀ^À^ºÀ^»À^ûÀ_À_À_À_¶À_·À`
À`;À`<À` À`ÊÀ`ËÀa/ÀaYÀa[Àa\ÀaÀa“Àa¡Àa¥ÀaôÀbAÀbÀb¸ÀcÀc/ÀcLÀcÀcËÀcÌÀdÀdwÀdĞÀdÔÀdÕÀe"ÀehÀe·ÀeúÀeşÀeÿÀfCÀf•ÀfãÀg%Àg)Àg*ÀgnÀgtÀgÂÀhÀh>ÀhÀh­ÀhëÀhñÀiSÀiWÀiXÀi¢Ài¨Ài÷Àj.ÀjSÀj¯Àj÷ÀjûÀjüÀkMÀkšÀkÁÀkÂÀlÀlCÀlcÀleÀlfÀl˜ÀlãÀläÀlşÀm#Àm$ÀmEÀm‰Àm•ÀmÌÀmÍÀmÙÀnÀnÀn)ÀnmÀnnÀnzÀnÀnÉÀnİÀnãÀo
Ào:ÀolÀopÀoqÀo}ÀoÅÀoÇÀoÈÀp ÀpdÀpeÀp|Àp“Àp®Àp¯ÀpÃÀqÀqÀqHÀqIÀqdÀq|Àq§ÀqÔÀrÀr0Àr6Àr:Àr;ÀrGÀr‘Àr’ÀrÀréÀrêÀröÀsÀsEÀsYÀs_ÀsŒÀs®ÀsĞÀs÷ÀsûÀsüÀtÀt;Àt=Àt>ÀtpÀt¸Àt¹ÀtÑÀtéÀtêÀu.Àu:ÀuqÀurÀu~Àu¾Àu¿ÀuËÀvÀvÀvÀv<ÀvhÀv|Àv‚Àv©ÀvÍÀvòÀvöÀv÷ÀwÀw8Àw:Àw;ÀwlÀw³Àw´ÀwÌÀwäÀwåÀx(Àx4ÀxkÀxlÀxxÀx·Àx¸ÀxÄÀyÀyÀyÀy4Ày`ÀytÀyzÀy ÀyÄÀyéÀyíÀyîÀyúÀz/Àz1Àz2ÀzeÀz¶Àz·ÀzØÀzùÀzúÀ{À{ZÀ{fÀ{À{À{ªÀ|À|À|!À|wÀ|xÀ|„À|§À|ÓÀ|çÀ|íÀ}À}AÀ}nÀ}rÀ}sÀ}À}¼À}¾À}¿À}şÀ~À~RÀ~¥À~éÀ$À`À•À®ÀÂÀ€À€
À€À€XÀ€À€ÏÀ€èÀ€üÀ-À1À2ÀvÀÈÀ÷À‚À‚$À‚TÀ‚XÀ‚YÀ‚À‚£À‚ñÀƒ;ÀƒlÀƒ…Àƒ©ÀƒçÀƒíÀ„À„;À„?À„@À„rÀ„¥À„¾À„ÒÀ…À…<À…@À…AÀ…tÀ…¨À…ÁÀ…ÕÀ†+À†À†ºÀ†¾À†¿À†ÿÀ‡À‡ À‡À‡ÕÀ‡ÖÀˆ?Àˆ|Àˆ}ÀˆåÀ‰!À‰"À‰|À‰ÁÀ‰ÂÀŠ!ÀŠ^ÀŠ_ÀŠÏÀ‹"À‹#À‹qÀ‹—À‹´À‹¶À‹·À‹ıÀŒ2ÀŒgÀŒ±ÀŒÍÀŒéÀŒ÷ÀŒøÀÀÀAÀGÀ˜À³ÀËÀÛÀüÀÀÀ.À2À3ÀƒÀ¦À¬ÀùÀCÀŒÀÖÀÜÀ!À4ÀDÀ’À¯ÀÂÀÌÀĞÀÒÀÓÀ‘(À‘AÀ‘EÀ‘’À‘àÀ’-À’}À’À’ÖÀ“*À“ƒÀ“ÛÀ”.À”WÀ”[À”µÀ”ÚÀ”ŞÀ”ìÀ”ğÀ•4À•~À•ÎÀ•øÀ–BÀ–ŠÀ–±À–şÀ—LÀ—fÀ—¡À—±À˜À˜À˜]À˜£À˜©À™À™!À™'À™ŠÀ™íÀšOÀšXÀšYÀšªÀš°À›À›fÀ›’À›˜À›òÀœOÀœUÀœ»À!À†À’À“ÀæÀìÀDÀœÀòÀŸÀŸÀŸmÀŸÃÀŸØÀŸŞÀ BÀ ¦À¡	À¡À¡À¡TÀ¡ZÀ¡´À¢À¢À¢%À¢~À¢À¢¤À£À£jÀ£ÌÀ£ÕÀ£×À£ØÀ¤À¤7À¤qÀ¤šÀ¤´À¤÷À¥À¥5À¥TÀ¥sÀ¥wÀ¥ˆÀ¥ŠÀ¥‹À¥ŒÀ¥½À¥åÀ¦À¦@À¦aÀ¦eÀ¦vÀ¦xÀ¦yÀ¦­À¦ÕÀ§À§8À§VÀ§yÀ§À§ÀÀ§ßÀ§şÀ¨À¨À¨À¨À¨SÀ¨uÀ¨—À¨ÄÀ¨İÀ¨öÀ©À©(À©9À©;À©<À©„À©ˆÀ©ÚÀ©íÀ©ñÀ©ÿÀªÀªyÀª}Àª¢Àª×ÀªİÀ«,À«}À«ÇÀ¬À¬gÀ¬¸À­À­*À­0À­À­µÀ­»À®À®À®åÀ¯KÀ¯QÀ¯œÀ¯âÀ¯ıÀ°À°PÀ°£À°ãÀ°öÀ±À±À±0À±NÀ±vÀ±À±µÀ±ØÀ²À²'À²TÀ²˜À²ÛÀ³CÀ³WÀ³²À³¶À³·À´À´"À´(À´wÀ´ÈÀµÀµaÀµ²À¶À¶SÀ¶uÀ¶{À¶ÉÀ¶ÿÀ·À·hÀ·ËÀ¸/À¸•À¸›À¸ìÀ¹2À¹MÀ¹SÀ¹ À¹óÀº3Àº9Àº…ÀºÓÀ»À»kÀ»ºÀ»ßÀ»òÀ¼À¼À¼2À¼PÀ¼xÀ¼’À¼¥À¼ÂÀ¼éÀ½%À½8À½eÀ½ÍÀ¾À¾À¾vÀ¾ÒÀ¿À¿,À¿–À¿£ÀÀÀÀ"ÀÀ®ÀÀ´ÀÀ¸ÀÀ¹ÀÁ	ÀÁ'ÀÁ-ÀÁxÀÁÆÀÂÀÂÀÂVÀÂ§ÀÂñÀÃ@ÀÃ‘ÀÃâÀÄ2ÀÄTÀÄZÀÄªÀÄëÀÄñÀÅSÀÅµÀÆÀÆ}ÀÆƒÀÆÒÀÇ"ÀÇEÀÇKÀÇ˜ÀÇëÀÈ+ÀÈ=ÀÈPÀÈjÀÈˆÀÈ°ÀÈÍÀÈğÀÉ
ÀÉ1ÀÉWÀÉ“ÀÉ¦ÀÉÓÀÊÀÊ~ÀÊ’ÀËÀËÀËÀËIÀËiÀËjÀËÙÀÌ^ÀÌ_ÀÌŞÀÌûÀÍÀÍ'ÀÍ<ÀÍVÀÍuÀÍ‰ÀÍ¦ÀÍ§ÀÎGÀÎeÀÎzÀÎÀÎ©ÀÎ¼ÀÎÏÀÎçÀÏÀÏ ÀÏ4ÀÏQÀÏRÀÏØÀÏôÀĞ
ÀĞ ÀĞ:ÀĞYÀĞmÀĞ†ÀĞÀĞ¹ÀĞºÀĞİÀÑÀÑ1ÀÑQÀÑ©ÀÑ±ÀÑ¾ÀÑîÀÒJÀÒRÀÒXÀÒ\ÀÒ^ÀÒ_ÀÒÀÒÅÀÒëÀÒñÀÓ-ÀÓ|ÀÓÂÀÓôÀÓúÀÔJÀÔ™ÀÔ§ÀÔ­ÀÔôÀÕ:ÀÕgÀÕmÀÕ³ÀÖÀÖPÀÖmÀÖ‰ÀÖ×ÀÖùÀ× À×"À×2À×RÀ×À×–À×ªÀØÀØ6ÀØTÀØZÀØ^ÀØ_ÀØkÀØ~ÀØ“ÀØ£ÀØ§ÀØ¨ÀØèÀÙÀÙ	ÀÙ…ÀÙõÀÙöÀÚAÀÚfÀÚ®ÀÚÊÀÚÌÀÚÍÀÛÀÛ,ÀÛ0ÀÛZÀÛªÀÛèÀÜÀÜ4ÀÜHÀÜ|ÀÜ™ÀÜ¸ÀÜ¾ÀÜÎÀÜëÀÜşÀİÀİÀİÀİ#Àİ$ÀİiÀİoÀİ¸ÀİıÀŞJÀŞ`ÀŞÀŞãÀß,ÀßvÀß£ÀßëÀà-ÀàHÀà}ÀàƒÀàµÀáÀá0ÀáFÀáNÀáRÀáSÀáŒÀáßÀâ,ÀâzÀâËÀâàÀãÀãAÀãBÀãwÀãÂÀäÀä<Àä|Àä—Àä¥Àä«Àä¬ÀäèÀåÀå6Àå<Àå@ÀåAÀå]Àå|Àå}Àå™Àå³Àå´ÀåøÀæÀæÀæuÀæ¨Àæ©ÀæİÀç1Àç3Àç4ÀçgÀçkÀç ÀçèÀè8Àè†Àè¬Àè°ÀèıÀéJÀé˜ÀéáÀêÀêEÀê®ÀêÊÀêÙÀêûÀëÀëÀë#Àë$Àë@ÀëAÀëÀë­Àë®ÀëâÀëèÀì6Àì„ÀìÏÀíÀímÀí—ÀíÀíäÀíêÀíøÀîÀî6ÀîUÀîpÀîzÀî€ÀîÎÀîØÀîŞÀîìÀï=ÀïhÀï™ÀïÊÀïĞÀğÀğNÀğ™ÀğäÀñ/Àñ5Àñ\Àñ†ÀñÀñ˜ÀñÀñëÀò@ÀòQÀòWÀò¡ÀòÌÀó!Àó=ÀóAÀóBÀóxÀó~ÀóÖÀôÀôÀôlÀôÀô¾ÀõÀõ=ÀõAÀõBÀõ„ÀõŠÀõÙÀö%Àö`ÀölÀöÀö”Àö¶ÀöÆÀöÊÀöËÀ÷0À÷–À÷—ÀøÀø?Àø@ÀøœÀøÁÀøÂÀùÀù1Àù3Àù4Àù…Àù‰Àù¬ÀùéÀùûÀúCÀúPÀúQÀúŸÀú°Àú±ÀûÀûÀûÀûhÀû¦ÀûçÀûöÀûøÀûùÀü1Àü5Àü„ÀüÊÀıÀıaÀı±Àı×ÀıÛÀş(ÀşvÀşÅÀşÕÀşÙÀÿ%ÀÿtÀÿÃÀ À ]À ­À üÀIÀdÀhÀµÀÿÀLÀnÀrÀÁÀÀSÀ¤ÀõÀEÀhÀŸÀæÀìÀ:À‡ÀÕÀ ÀOÀUÀ¢ÀËÀÑÀ"ÀpÀ¿ÀüÀÀ ÀoÀ¾ÀÄÀ	À	?À	EÀ	•À	æÀ
7À
ƒÀ
ÑÀÀgÀwÀ}ÀËÀõÀûÀ9À?À‹ÀÜÀ-ÀyÀ À¬ÀÁÀßÀøÀÀ6À=À|ÀÇÀÍÀ$À{ÀÀ‘À®ÀğÀ$ÀEÀ“ÀÜÀ)À8ÀDÀNÀVÀiÀsÀ¹À	À6ÀDÀxÀ™À§ÀŞÀÀÀÀ‚ÀÄÀÊÀÎÀÏÀ ÀOÀUÀ£ÀğÀ>À‰À¸À¾ÀÀUÀ¡ÀğÀÀ	ÀZÀ©ÀğÀAÀ’ÀáÀÀÀmÀ¼ÀÀVÀÀ•ÀåÀ6À‡À×À!ÀmÀ¾ÀëÀñÀ?ÀÀŞÀÀÀPÀ`ÀuÀ’À©ÀÎÀçÀîÀÀƒÀ‰ÀÌÀ À À tÀ ËÀ ÑÀ áÀ şÀ!@À!xÀ!™À!çÀ"5À"‚À"‘À"À"§À"¯À"ÂÀ"ÌÀ# À#bÀ#hÀ#lÀ#mÀ#ÏÀ$À$)À$]À$›À$ËÀ$şÀ$ÿÀ%OÀ%rÀ%…À%À%­À%ÅÀ%ØÀ%âÀ%òÀ%öÀ%÷À&BÀ&gÀ&¬À&ÈÀ&ÉÀ&ãÀ'-À'3À'À'—À'²À'ÆÀ'ÖÀ'òÀ(À(À(€À(„À(†À(‡À(ÕÀ(ÙÀ)À)YÀ)jÀ)ŒÀ)’À)àÀ**À*cÀ*iÀ*¶À+À+À+%À+&À+`À+fÀ+¬À+²À+ôÀ,
À,À,À,JÀ,PÀ,’À,¨À,³À,µÀ,¶À- À-À-À-/À-=À-uÀ-ƒÀ-„À-½À-ÊÀ-ÌÀ-ÍÀ.À.À.MÀ.‘À.ÒÀ.ÖÀ/À/oÀ/¸À/ÕÀ/ÙÀ0)À0rÀ0§À0«À0øÀ17À1;À1aÀ1eÀ1°À2 À2NÀ2À2çÀ3À3À3iÀ3°À3ÈÀ4À4)À4/À4xÀ4ÀÀ5À5_À5¬À5ïÀ5õÀ6<À6RÀ6¢À6£À6ëÀ6ñÀ7À7#À73À79À7ŠÀ7¿À7ÎÀ7ÏÀ8 À8qÀ8ÀÀ9	À9À9À9jÀ9»À:	À:QÀ:ŸÀ:éÀ:ïÀ;<À;BÀ;fÀ;lÀ;ºÀ<À<VÀ<¦À<ËÀ<ÑÀ=À=hÀ=¹À>À>UÀ>¥À>íÀ?À? À?jÀ?ƒÀ?‰À?—À?ÄÀ?ìÀ@À@CÀ@lÀ@£À@ÜÀ@öÀAÀAÀA"ÀA(ÀAwÀAÅÀBÀB1ÀB7ÀBEÀBrÀBµÀBİÀBôÀC4ÀCkÀC¤ÀC¾ÀCÆÀCĞÀCÖÀD'ÀDmÀD·ÀD½ÀDËÀDøÀEÀEcÀEœÀE¶ÀEÍÀF.ÀFgÀFÀF‰ÀF“ÀF™ÀFäÀG-ÀG~ÀG¶ÀG¼ÀGàÀGæÀH%ÀH+ÀHyÀHÇÀIÀIcÀI²ÀJ ÀJKÀJ–ÀJçÀK8ÀKSÀKYÀKiÀKoÀK¿ÀKáÀL)ÀL?ÀLlÀLmÀL­ÀLÌÀLÒÀMÀMÀM`ÀM¤ÀM¶ÀM·ÀNÀN`ÀN²ÀN¸ÀN÷ÀNıÀOKÀO›ÀO½ÀOßÀOàÀP#ÀPhÀP¯ÀPäÀPêÀQÀQ%ÀQ&ÀQvÀQÆÀQîÀQïÀR>ÀRˆÀR™ÀRŸÀRåÀR÷ÀSÀSÀStÀS“ÀS”ÀSåÀT1ÀT€ÀT©ÀTÌÀTÍÀUÀUXÀUÀU€ÀUÓÀV)ÀVEÀVKÀVÀVëÀW;ÀWhÀW†ÀW‡ÀWÕÀWìÀWòÀXHÀXNÀX’ÀX˜ÀXêÀY2ÀY[ÀYaÀY«ÀY¿ÀZÀZÀZiÀZˆÀZÀZåÀZëÀ[/À[5À[‡À[ÏÀ\À\YÀ\ZÀ\¨À\¼À\ÂÀ]À]À]bÀ]hÀ]ºÀ^À^+À^bÀ^cÀ^´À_À_YÀ_jÀ_pÀ_ÄÀ`À`iÀ`¸ÀaÀaZÀa­ÀaüÀbMÀbiÀboÀb§ÀbùÀcMÀcœÀcŞÀcäÀd2ÀdYÀd_ÀdmÀdÀd­ÀdæÀe#ÀeBÀe|Àe¸ÀeÇÀeÏÀeÙÀeßÀf0Àf|Àf×Àg+Àg;ÀgAÀg‡ÀgÔÀhÀhÀh^Àh­ÀhùÀiÀi&ÀiCÀiDÀi•ÀiçÀj:Àj@ÀjÀjâÀk2Àk‚ÀkÔÀl(Àl{ÀlˆÀlÀlÃÀlæÀlçÀm*ÀmvÀm“ÀmÇÀmÈÀnÀn_ÀneÀn³Àn¹Ào$Ào“ÀoÇÀoÈÀo÷ÀoıÀpBÀp]Àp|Àp}ÀpÍÀqÀqÀqyÀqèÀrÀrÀrcÀr¥Àr«ÀsÀs‡Às³Às´ÀtÀtTÀtzÀt€ÀtÅÀtÿÀu ÀuMÀuÀuÁÀuÇÀv2Àv¡ÀvÊÀvËÀwÀwhÀw·ÀwÚÀwàÀxMÀx¾Àx÷ÀxøÀy4Ày:ÀyzÀyÇÀzÀzeÀz¶À{À{2À{8À{§À|À| À|xÀ|ÖÀ|×À}À}À}[À}¤À}ĞÀ}ùÀ}úÀ~HÀ~ŸÀ~ÚÀ~ÛÀ*ÀvÀ|ÀËÀäÀêÀ€6À€À€’À€ÖÀ€×ÀÀ$ÀrÀÀÀ‚À‚ZÀ‚À‚£À‚ñÀƒ>ÀƒŒÀƒÓÀƒäÀ„+À„,À„sÀ„ŒÀ„±À„²À„şÀ…À…À…_À…lÀ…rÀ…¾À†À†IÀ†OÀ†À†êÀ†ğÀ‡AÀ‡À‡ÛÀ‡áÀˆ+ÀˆwÀˆÄÀˆşÀˆÿÀ‰DÀ‰JÀ‰‘À‰—À‰İÀŠ'ÀŠ-ÀŠ=ÀŠCÀŠ“ÀŠ¬ÀŠöÀŠ÷À‹<À‹BÀ‹’À‹ßÀ‹åÀŒ+ÀŒuÀŒ{ÀŒ‹ÀŒ‘ÀŒßÀŒıÀIÀJÀ”ÀšÀæÀ÷ÀıÀFÀ—À®À´ÀıÀKÀ—ÀßÀ/ÀzÀÅÀ‘À‘aÀ‘«À‘åÀ‘ëÀ’À’À’(À’yÀ’ÅÀ’ìÀ“>À“ˆÀ“‰À“ÍÀ“ÓÀ”$À”}À”ĞÀ•$À•\À•bÀ•²À–À–RÀ–¤À–ôÀ—HÀ—”À—šÀ—ëÀ˜;À˜À˜çÀ™À™kÀ™¹À™ıÀšÀšVÀš¥ÀšğÀ›>À›“À›™À›íÀœ>Àœ‡ÀœÀœŞÀœùÀœÿÀÀ"ÀKÀ^ÀuÀ}ÀƒÀ±ÀçÀíÀFÀdÀ…À‹ÀÀÌÀíÀŸ$ÀŸXÀŸ‚ÀŸ¡ÀŸ½ÀŸúÀ À 6À |À ªÀ ØÀ éÀ şÀ¡2À¡uÀ¡œÀ¡¦À¡¬À¡»À¡ÃÀ¡ÍÀ¡ÓÀ¢,À¢2À¢@À¢UÀ¢™À¢¬À¢ÃÀ¢ÖÀ¢ïÀ¢÷À¢ıÀ£+À£aÀ£gÀ£ÀÀ£ŞÀ£ÿÀ¤À¤À¤FÀ¤gÀ¤À¤ÒÀ¤üÀ¥'À¥CÀ¥€À¥À¥¼À¦À¦0À¦^À¦oÀ¦„À¦¸À¦ûÀ§À§EÀ§yÀ§¥À§¯À§µÀ§ÄÀ§ÌÀ§ÖÀ§ÜÀ¨%À¨pÀ¨£À¨©À¨¹À¨¿À©À©$À©BÀ©qÀ©”À©ºÀ©áÀªÀª!Àª"ÀªfÀªlÀª½À«À«iÀ«½À¬À¬aÀ¬˜À¬À¬îÀ­6À­<À­À­ÍÀ­øÀ­şÀ®LÀ®–À®œÀ®èÀ¯5À¯…À¯‹À¯æÀ¯÷À¯ıÀ°À° À°IÀ°\À°sÀ°{À°À°¯À°åÀ°ëÀ±DÀ±bÀ±ƒÀ±‰À±›À±ÊÀ²À²iÀ²ºÀ²ÖÀ³À³eÀ³À³ÈÀ³şÀ´'À´NÀ´~À´¦À´¬ÀµÀµ`ÀµºÀµüÀ¶(À¶TÀ¶“À¶ÒÀ¶ŞÀ¶ÿÀ·]À·gÀ·mÀ·|À·„À·À·”À·íÀ·óÀ¸À¸À¸ZÀ¸mÀ¸„À¸—À¸°À¸¸À¸¾À¸ìÀ¹"À¹(À¹À¹ŸÀ¹ÀÀ¹ÆÀ¹ØÀºÀºWÀº¦Àº÷À»À»XÀ»¢À»àÀ¼À¼CÀ¼yÀ¼¢À¼ÉÀ¼ùÀ½!À½'À½‚À½ÙÀ¾4À¾‘À¾ÜÀ¿"À¿KÀ¿eÀ¿ À¿¼À¿ØÀÀÀÀHÀÀtÀÀƒÀÀºÀÀñÀÁ&ÀÁ[ÀÁaÀÁ»ÀÂÀÂmÀÂ´ÀÂãÀÂïÀÃÀÃ~ÀÃˆÀÃÀÃÀÃ¥ÀÃ¯ÀÃµÀÃÅÀÃËÀÄÀÄ-ÀÄNÀÄ}ÀÄ¤ÀÄËÀÄõÀÅÀÅ;ÀÅ<ÀÅ‰ÀÅÀÅßÀÅôÀÅúÀÆ ÀÆwÀÆyÀÆzÀÆÈÀÇ	ÀÇ)ÀÇ†ÀÇŒÀÇÀÀÇßÀÇşÀÈZÀÈ^ÀÈ_ÀÈÉÀÉ>ÀÉ?ÀÉ›ÀÉ÷ÀÊ<ÀÊaÀÊbÀÊnÀÊ¼ÀÊÔÀÊÕÀÊøÀËÀË,ÀËUÀË~ÀË§ÀËĞÀËÙÀËßÀËğÀËôÀËõÀÌÀÌ/ÀÌIÀÌ…ÀÌ’ÀÌ¶ÀÍÀÍ!ÀÍ%ÀÍ&ÀÍˆÀÍâÀÍãÀÎXÀÎÛÀÎÜÀÎèÀÏ9ÀÏTÀÏUÀÏaÀÏÀÀÏëÀÏìÀÏøÀĞOÀĞnÀĞoÀĞ{ÀĞŞÀÑÀÑÀÑÀÑ[ÀÑ\ÀÑ»ÀÑéÀÑêÀÑöÀÒNÀÒvÀÒwÀÒƒÀÒáÀÓÀÓÀÓÀÓBÀÓbÀÓ ÀÓ¦ÀÓ¿ÀÓÃÀÓÄÀÔÀÔBÀÔCÀÔOÀÔnÀÔŸÀÔ»ÀÔÏÀÔÓÀÔÔÀÕ$ÀÕXÀÕYÀÕeÀÕÁÀÕáÀÕûÀÖHÀÖ–ÀÖØÀ×0À×4À×5À×´ÀØ#ÀØ$ÀØ0ÀØkÀØÀØ¿ÀØÃÀØÄÀÙÀÙXÀÙYÀÙeÀÙÀÙÎÀÙÒÀÙÓÀÚ,ÀÚkÀÚlÀÚxÀÚ–ÀÚÅÀÚæÀÛ,ÀÛ0ÀÛ1ÀÛ‡ÀÛÀÀÛÁÀÛÍÀÛñÀÜ ÀÜGÀÜÀÜ‘ÀÜ’ÀÜîÀİ-Àİ.Àİ:ÀİoÀİÀİ¡Àİ¢ÀŞÀŞ:ÀŞ;ÀŞGÀŞ|ÀŞœÀŞ¼ÀßÀßÀß	Àß}ÀßõÀßöÀàÀà"ÀàOÀàSÀàTÀà©ÀàöÀà÷ÀáÀá-ÀáMÀágÀá¥ÀâÀâÀâÀâÀâ€ÀãÀãÀãÀã<Àã^Àã Àã¤Àã¥ÀäÀäbÀäcÀäoÀäªÀäÌÀäîÀåFÀåJÀåKÀå±Àæ%Àæ&Àæ2Àæ\Àæ|Àæ–ÀæÔÀç0Àç6Àç:Àç;Àç¯Àè1Àè2Àè>ÀèxÀè—ÀèÙÀèİÀèŞÀéLÀé½Àé¾ÀéÊÀê)ÀêIÀêÅÀêÉÀêÊÀëSÀëmÀë€Àë’Àë¦Àë»ÀëÔÀëíÀìÀì&ÀìAÀìBÀìNÀìxÀì¹Àì½Àì¾Àí!ÀíÀí€ÀíŒÀíÈÀíêÀîÀîÀî©Àî÷ÀîıÀïÀïÀïÀğ	Àğ
ÀğÀğ[Àğ}ÀğœÀğ»ÀğòÀñ%ÀñWÀñ‹ÀñÀÀñóÀò%ÀòYÀòÀòÇÀòıÀóBÀó[Àó©Àó¯Àó³Àó´ÀôeÀôˆÀôœÀô²ÀôÇÀôŞÀôöÀõÀõ!Àõ8ÀõPÀõsÀõÀõ¬Àõ­Àõ¹ÀöÀö#ÀöEÀödÀö›ÀöÑÀ÷À÷=À÷uÀ÷¨À÷ÚÀøÀøCÀø|Àø²Àø÷ÀùÀù^ÀùdÀùhÀùiÀúÀú=ÀúQÀújÀú‚ÀúœÀú·ÀúÍÀúâÀúùÀûÀû4ÀûNÀûmÀûnÀûzÀû ÀûÄÀûñÀûõÀûöÀüLÀü‚ÀüƒÀüÀüÊÀıÀıBÀıfÀı‘ÀıÉÀıÍÀıÎÀıÚÀş%Àş~Àş‚ÀşƒÀşÀşÜÀşşÀÿIÀÿOÀÿ–ÀÿšÀÿ›À  À qÀ rÀ ~À ÉÀ îÀ9À=À>À¬ÀÀÀ+ÀIÀxÀ›ÀÁÀèÀ	À)ÀKÀÀÀ·ÀáÀ,À2ÀÀçÀíÀîÀ5ÀtÀuÀŸÀ¿ÀäÀ	À.ÀdÀ†À¨ÀŞÀÀHÀ|À¢ÀÇÀîÀÀÀÀ†ÀÇÀÿÀ	 À	&À	…À	ËÀ	ÒÀ	ÓÀ	ìÀ
:À
@À
DÀ
EÀ
QÀ
rÀ
¡À
ÈÀ
ïÀÀ=À`À‘À’ÀºÀçÀ5À;ÀYÀ·À½ÀùÀrÀxÀ°À±À×À,ÀvÀ}À~À—ÀåÀëÀïÀğÀ„À£ÀÆÀàÀşÀÀ3ÀLÀeÀzÀ˜À™À¥ÀıÀPÀTÀUÀÀÀ&À'À3ÀuÀwÀxÀ¦ÀåÀæÀ.À2ÀfÀjÀ±ÀóÀ5ÀNÀÀ“ÀŞÀ ÀAÀjÀkÀ¬À²ÀıÀ@ÀaÀ‹ÀŒÀ¶À¼ÀÀZÀ£ÀÓÀÔÀÀÀSÀ¢ÀñÀ:À@ÀÀŞÀÀÀaÀªÀÃÀÉÀÀ-ÀYÀZÀªÀÍÀßÀàÀ&À,ÀzÀÀªÀ«ÀôÀúÀKÀ}ÀÀŸÀ ÀğÀ:ÀVÀ\À’À¨À©ÀµÀæÀşÀ#ÀWÀ]ÀsÀÃÀàÀúÀ À JÀ TÀ ^À eÀ iÀ jÀ ÈÀ!À!À!*À!WÀ!oÀ!”À!ÈÀ!ÎÀ!ÏÀ!ôÀ"À"RÀ"VÀ"WÀ"·À"ıÀ"şÀ#
À#À#5À#EÀ#]À#pÀ#zÀ#À#­À#±À#²À#ıÀ$"À$fÀ$‚À$ƒÀ$À$À$ªÀ$ÅÀ$ÙÀ$éÀ%À%À%"À%’À%–À%—À%£À&À&*À&+À&7À&YÀ&[À&\À&£À&§À&ìÀ'1À'5À'[À'_À'ªÀ'÷À(?À(À(×À)"À)RÀ)VÀ)¡À)èÀ*	À*JÀ*‘À*­À*ãÀ*äÀ+À+%À+iÀ+°À+çÀ,,À,hÀ,€À,À,°À,¶À-À-QÀ-–À-°À-²À-³À.À.BÀ.CÀ.‡À.§À.¨À.´À.ßÀ.àÀ.ìÀ/À/"À/fÀ/lÀ/£À/¿À/ŞÀ/òÀ0EÀ0ŒÀ0±À0ÅÀ0ÉÀ0ÊÀ1#À1]À1^À1xÀ1yÀ1…À1ÈÀ1ÊÀ1ËÀ1àÀ1äÀ2 À2/À2IÀ2OÀ2šÀ2åÀ2ÿÀ3À3FÀ3LÀ3›À3´À3ÅÀ3óÀ4À4-À4‚À4ƒÀ4³À4×À5À5,À5SÀ5zÀ5¤À5¥À5ÕÀ5ÛÀ6-À6PÀ6eÀ6fÀ6¥À6«À6ùÀ7EÀ7‡À7À7ŸÀ7ñÀ8À8À8?À8EÀ8xÀ8~À8«À9À9TÀ9ˆÀ9ŒÀ9À9ÉÀ9ÏÀ:À:>À:?À:ŒÀ:’À:ÏÀ;À;EÀ;KÀ;À;ØÀ<'À<IÀ<]À<pÀ<†À<ÉÀ<ÍÀ<ÎÀ= À=.À=NÀ=aÀ=uÀ=”À=»À=ÂÀ=ÆÀ=ÇÀ=÷À=ıÀ>FÀ>‹À>¯À>µÀ>ÛÀ?(À?rÀ?½À@	À@WÀ@§À@ôÀA8ÀA>ÀAÀA­ÀAÂÀAúÀBÀB&ÀB;ÀBJÀBkÀBsÀB€ÀB—ÀB²ÀBÁÀBØÀCÀCBÀC„ÀCÀC—ÀCÀC¡ÀC¢ÀCÛÀCáÀD)ÀD/ÀDRÀD ÀDÂÀDÕÀDÛÀDñÀEÀE3ÀEnÀEÀEÍÀEÓÀF
ÀF1ÀF7ÀFnÀFÀF•ÀF¨ÀF¬ÀF­ÀF¹ÀFÜÀFşÀGÀGÀG2ÀGRÀGtÀGŸÀG£ÀG¤ÀG°ÀGîÀGïÀH;ÀHÀH©ÀHãÀHşÀIÀIÀIÀI\ÀI’ÀI“ÀI­ÀIúÀJ,ÀJaÀJbÀJ›ÀJâÀJãÀKÀKGÀKHÀKÀK¬ÀK­ÀKüÀL6ÀL\ÀLbÀLcÀL{ÀLÀL€ÀLŒÀLÏÀLÑÀLÒÀMÀMÀMlÀM‚ÀMÀÀMãÀMäÀN2ÀNGÀNˆÀNÍÀNÿÀO,ÀOJÀONÀOOÀO‰ÀOÀOÈÀPÀPKÀP”ÀPŞÀQÀQSÀQÀQ¿ÀQûÀRÀR0ÀR\ÀRdÀRÀR•ÀR™ÀRšÀRËÀRÑÀS
ÀSGÀS‚ÀS³ÀSèÀTÀTÀTWÀT_ÀTˆÀTÀT”ÀT•ÀTéÀU-ÀU.ÀU‹ÀUØÀUÙÀV5ÀVÀV‚ÀV¶ÀVÓÀVâÀVãÀWÀWÀW,ÀW2ÀWƒÀWÀW¶ÀWÆÀWçÀWúÀXÀXÀXÀXÀXnÀX‘ÀX—ÀXäÀY.ÀY{ÀYÈÀZÀZ4ÀZGÀZWÀZvÀZ“ÀZ¦ÀZ°ÀZÀÀZÄÀZÅÀ[À[5À[À[À[ŸÀ[ À[ëÀ[ïÀ\>À\VÀ\wÀ\°À\¶À]À]XÀ]rÀ]xÀ]ÆÀ^À^ZÀ^—À^¶À^ÔÀ^ìÀ_À_À_>À_aÀ_bÀ_­À_ğÀ`:À`lÀ`¤À`ÄÀ`ÈÀ`ÉÀ`óÀ`ùÀa4ÀaEÀaFÀaqÀawÀa²ÀaÄÀaÅÀa÷ÀaıÀb4ÀbMÀbNÀbÀbÁÀbÇÀcÀc7ÀcIÀcJÀc˜Àc´ÀcºÀdÀdRÀdcÀdiÀd·ÀdßÀe(Àe*Àe+Àe‹Àe©ÀeªÀeãÀeéÀf9Àf‹Àf¥Àf«ÀfùÀgLÀgÀgÊÀgèÀhÀhÀh7ÀhJÀhpÀhwÀh‹Àh¡ÀhæÀhşÀiLÀiPÀiQÀi³ÀjÀjÀjpÀjşÀjÿÀkÀkÀkhÀk„Àk…Àk‘Àk¼Àk½ÀkÍÀkÎÀl(ÀlEÀlFÀlRÀl€ÀlÀl˜Àl™ÀlúÀmÀmÀm+ÀmnÀmoÀm{ÀmÇÀmâÀmãÀmïÀn?ÀnrÀnŒÀn’ÀnÇÀnâÀnèÀnéÀo Ào;ÀoXÀo–ÀoÕÀpÀpIÀpOÀppÀp’Àp“Àp½ÀpøÀq
ÀqÀqÀqzÀqĞÀqÑÀqİÀrfÀrhÀriÀrÀrÎÀrÏÀsÀsUÀsVÀsÀs’ÀsÜÀséÀt,Àt-ÀtnÀtŠÀtßÀtàÀu/ÀuDÀuGÀu”Àu±Àu´Àv ÀvÀvÀvÀv#ÀvWÀvZÀv•ÀvÒÀv×ÀvÚÀvùÀw)Àw.Àw5Àw8ÀwÀwãÀxÀxÀxhÀxœÀxÒÀyÀy]ÀyšÀy°ÀyÜÀyñÀzÀz2ÀzAÀzÀz‰Àz–Àz³Àz¹Àz¿ÀzÑÀzèÀ{À{À{#À{%À{&À{iÀ{¯À{åÀ|,À|pÀ|­À|ÃÀ|şÀ}À}0À}=À}QÀ}‡À}–À}ßÀ}çÀ}íÀ}óÀ~À~À~8À~<À~WÀ~YÀ~ZÀ~©À~÷À~ûÀKÀ›ÀĞÀ€À€PÀ€QÀ€†À€À€ŸÀ€ñÀÀÀÀ/À‰À¢ÀºÀ‚À‚*À‚0À‚NÀ‚RÀ‚T   dart.ui€¬ W_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaint
ColorSpace_colorSpaceToIndex_indexToColorSpaceImageByteFormatPixelFormatImage_Image
_wrapImage	FrameInfoCodec_NativeCodecinstantiateImageCodecinstantiateImageCodecFromBufferinstantiateImageCodecWithSize_getDefaultImageSizeTargetImageSizedecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayer_NativeEngineLayerPath_NativePathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilter_ColorTransform_IdentityColorTransform_ClampTransform_MatrixColorTransform_getColorTransformColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeWideColorList_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgramFragmentShader
VertexModeVertices	PointModeClipOpCanvas_NativeCanvasPicture_NativePicturePictureRecorder_NativePictureRecorderShadowImmutableBufferImageDescriptor_NativeImageDescriptor	_futurize_futurizeWithErrorPictureRasterizationException Íê